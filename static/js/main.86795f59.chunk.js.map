{"version":3,"sources":["priority_queue.js","logo.svg","App.js","reportWebVitals.js","MainSvg.js","dataHacker.js","CSVData.js","GapMinderNew.js","ManuallyTree.js","Example1.js","LocalCluster.js","util.js","BSpline.js","AdaptiveIsovalue.js","HierarchicalCluster.js","BMOAlgo.js","AlgorithmEntry.js","IndexUI.js","BubbleDemo.js","KelpDiagram.js","KelpFusion.js","CalOverLap.js","index.js"],"names":["PriorityQueue","d","this","_d","_elements","module","exports","prototype","checkEdgeCrossing","P1","P2","Q1","Q2","Math","min","x","max","y","isEmpty","size","peek","Error","modify_Prim","e1","e2","thisid","weightcross","szbefore","length","i","s","start","e","end","id","clusterid2","hasOwnProperty","cat","score","splice","tmp","enq","sz","parseInt","adjust","searchFather","f","m","j","_compare","modify_Kruskal_V2","fs","clusterid1","fe","push","modify_Kruskal","fa","deq","first","last","pop","current","largest","left","right","_swap","element","parent","floor","forEach","fn","a","b","aux","pid","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","colors","jsgraphs","require","POINT_EDGE_EPS","Component","clustering","calDistance","x1","y1","x2","y2","sqrt","pow","getVecNorm","vec","normalizeVec","norm","drawCircle","r","fill","stroke","d3","append","attr","drawRect","width","height","color","drawLine","on","PointToSegDist","cross","d2","px","py","calTanPoint","cx","cy","radius","point","vc1c2","radC1C2","acos","theta","p1","cos","sin","p2","PI","calCommonTanPoint","r1","r2","tanPoints","delta1","delta2","vecpq","dir","newpointp","newpointq","dir2","newpointp2","newpointq2","intersecx","intersecy","tanpoints1","tanpoints2","p3","delta","abs","drawArc","startp","endp","center","pathstr","largearcflag","vec1","vec2","crossmul","getDegreeTwoVec","norm1","norm2","rotatePoint","rx0","ry0","alpha","crossMul","BSpline","points","degree","copy","dimension","baseFunc","basisDeg2","baseFuncRangeInt","basisDeg3","basisDeg4","basisDeg5","seqAt","dim","margin","n","getInterpol","seq","t","rangeInt","tInt","result","calcAt","res","g","offsetX","offsetY","viewWidth","viewHeight","MarchingSquaresJS","IsoInsideTest","AreaCal","IntersectionQuery","ShapeInfo","Intersection","Point2D","buffer","nodeR1","nodeR0","edgeR1","edgeR0","intervals","pixelGroup","gapBetween","fixdis","control_points","initialControlPoints","is_selected","eps","nearpts","hasChangeView","prepoints","svgwidth","svgheight","minItemArea","Number","MAX_VALUE","editSeg","lineFunction","curve","lineFunction_reDraw","clone","obj","Date","setTime","getTime","Array","Object","AdaptiveIsovalue","onChangeEdgeWidth","value","setState","edgeWidth","changeEdgeWidth","selectedEdge","onChangeNodeR0","onChangeNodeR1","onChangeEdgeR0","onChangeEdgeR1","onChangePixelGroup","onChangeGap","state","hasSelectEdge","isfirstcreate","pointData","canvasWidth","canvasHeight","maxX","maxY","minX","minY","maxDis","MIN_VALUE","catPointDict","catEdgeDict","edges","maxDistance","itemShape","itemBBox","catEnergyField","catNotGroup","activeRegion","energyField","field","editMode","editIndex","updatedEnergyPoints","edgeControlPoints","hasMST","updateIdx","hasBubbles","firstFlag","X","Y","Width","Height","props","onRef","document","getElementById","getBoundingClientRect","oncontextmenu","pdict","flag","c","catArray","nowcat","edict","filledges","catarr","startpoint","editPoints","editEdges","HpointData","Hedges","console","time","shape","parseFloat","toString","cats","split","catarray","multicat","centralizeData","calEdgeLength","calActiveRegion","updatePoints","updateEdges","preProcessPoints","preProcessEdges","calEnergyField_Part","timeEnd","calFinalEnergeField_Part","fillCrossingEdge_Part","remove","findOutLine","calOutLine","calEdgeControlPoints","that","log","selectAll","filter","init","createMST","loadEdgeData","handleCreated","ViewFlag","minx","miny","maxx","maxy","virtrual","vpoints","virtrualNodes","p","call","extent","scaleExtent","transform","event","items","index","getElementsByTagName","getAttribute","getBBox","bbox","sortArr","avgdis","tempcontrolpoints","k","controlpoints","minDis","minindex","edge","dis","order","iscontinue","temppoints","lastindex","sort","dw","firstOutline","secondOutline","dot","dx","dy","drawPathData","reDraw","stopPropagation","handleClick","vstart","vend","v","thisindex","minlength","maxlength","endpoint","vpoint","nowp","nextp","edgelength","maxEdgeLength","minEdgeLength","nextProps","nextState","nextContext","fieldData","startY","boundingY","startX","boundingX","endY","boundingHeight","endX","boundingWidth","finalField","isoDict","calISOLine","polygontest","tmp_polygon","prelength","polygon","selectidx","curlen","meandis","sidx","isthis","st_idx","pt_len","j_pt","idx1","idx2","ve1","ve2","ve3","ve3_len","test_pt","is_use_inner","j_y","j_x","path_Info","curdata","drawISOLinesV2","JSON","stringify","calEnergyField","calFinalEnergeField","fillCrossingEdge","createGapInBoundary","drawEdges","drawPointData","ceil","centerX","centerY","barrierMap","item","lx1","ly1","lx2","ly2","projlenSq","dotprod","lenSq","distancetoendnode","distancetoedge","mindis","distancetostartnode","totaldistance","getPointEdgeDistance","enddis","sp","se","selength","distancetonode","rect1","rect2","maxpdis","k1","isGroup","isgroup","k2","calDistanceToEdge","pointMap","pointBarrierMap","edgeBarrierMap","pointIndexMap","edgeIndexMap","edgeIndexMap2","subUpdate","members","startx","endx","starty","endy","realx","realy","distance","calDistanceToItem","energy","EDGELENGTH_THRESH","startid","endid","calDistanceToEdgeV2","distancetoEdge","distancetoNode","totalDistance","newR1","delflag","it","relativex","relativey","hasSameCat","samecat","c1","cat1","c2","cat2","area_abc","area_abd","area_cda","gap","deletePoints","isboundary","isolines","isolinepoints","isoLineMap","relativepoints","isoInsidePoints","pointInPolygon","notDeleteIndex","nodePoints","totalInside","isolineIndex","deleteindex","isdelete","newisolines","catarr1","catarr2","gfield","finalvalue","isInside","thisPointID","gpointIndexMap","thisEdgeID","gedgeIndexMap","thiscat","gbarrierMap","gwidth","gheight","othervalue","otherinside","otherPointID","otherEdgeID","othercat","isContained","gpointBarrierMap","Set","updateidx","preK","bounding","smoothEnergyField","idx","val","lines","val1","val2","tmpx","uy","ux","target","map","style","dat","Polygon","max_y","min_y","max_x","min_x","NET","ymax","AET","curi","CurSize","fx","fy","relativeotherx","relativeothery","P_1","P_2","p_x1","shift","p_x2","x_begin","x_end","cut","len","bx1","by1","bx2","by2","dragstarted","execflag","_groups","attributes","tmp_idx","isnum","iidx","jidx","v1","v2","dragged","sourceEvent","ex","ey","reDrawData","cur_len","tmp_pts","q","tmpDict","sid","cur_idx","s_pts","tmpPath","node","totLen","getTotalLength","r1_idx","dis1","r2_idx","dis2","tmp_p","getPointAtLength","tmpdis1","tmpdis2","dragended","v3","fillPolygon","button","pointpath","data","isoLines","polygons","linearRing","noFrame","isoLineDict","tpoints","splinePoints","spline","kernel","sum","kernelsize","anchor","C","ny","nx","exp","normalizeKernel","isSingular","edgeCrossingList","start1","end1","linesToCheck1","vlength","start2","end2","linesToCheck2","l1","l2","crossInfo","newFieldDict","crossingPoints","fillArea","crosspoint","otherid","line","crossline","dl","lineLength","vec3","linedirvec","normdirvec","step","topBoundPoints","bottomBoundPoints","lastTop","lastBottom","rightstop","topstop","bottomstop","newanchor1","disalongline","topfind","bottomfind","newpointtop","newxtop","newytop","otherx","othery","newpointbottom","newxbottom","newybottom","fillPolyPoints","leftstop","newanchor2","fillPolygonForEdge","getGaussianKernel","sx","sy","cur_width","cur_height","newField","newvalue","formatpoints","isInterior","parentID","updateEnergyPoints","span","onChange","disabled","onClick","getData","bind","hasLoadData","removeOverlaps","defaultProps","preEdgeDict","curEdgeDict","FileSaver","weightMess","maxCross","DISTANCE_THRESHHOLD","priority_queue","svgid","opsvgid","preEdges","tmpEditEdges","editView","BeforeWidth","BeforeHeight","ScreenWidth","ScreenHeight","HierarchicalCluster","ref","child","read","hasinit","hasEdit","hascreated","issplit","graph","clustergraph","isSelect","selectItem","clusterDict","clustergraphInfo","clusterArr","noiseDict","intersecEdges","vis","heap1","heap2","QTree","edgesdict","draggedIndex","draggedEdgeIndex","draggedEdgeSeg","nodeStartDict","nodeEndDict","lastClickIndex","lastClickItem","deletedEdge","addedEdge","tempEdges","window","screen","availHeight","availWidth","dissum","disnum","tmpp1","calEPS","optimizeMST","applyEdit","beginTime","generateTreeWithHierarchical","endTime","countEdgeCrossingWithRouting","hasCreate","Graph","V","label","disArray","messArray","tempedges","mess","calEdgeMess","weight","calEdgeWeight","node1","node2","crossnum","edgecat","sortedEdges","removeEdggeList","sortEdgesGlobal","DepthFirstSearch","hasPathTo","checkNewEdge","addEdge","checkConnect","tempEdgeList","scores","calEdgeWeightWithCrossing","minCost","maxindex","sortEdgesGlobalWithMinDis","edgesnum","nodesnum","dfs","id1","id2","removelist","num","isPointInEdgeRange","calPointEdgeDistance","calVecCosine","vec4","seg1","SVGElement","select","empty","insert","drawOneEdge","each","savedData","fetch","method","headers","mode","cache","json","removeindex","countEdgeCrossing","isedit","newGraph","cc","ConnectedComponents","componentCount","newClusterDict","componentId","idnum","getElementsByClassName","newEdges","recalculateSpanningTreeAfterEdit","drawOneEdgeAfterEdit","tmpe","recalculateSpanningTree","new","ei","thisedge","pcat","linesToCheck","ids","swap","checkline","intersecInfo","findCrossingBetweenEdgeRect","rec","rect","line1","line3","line2","line4","point1","point2","vnode","cornerpointindex","cornerpoint","iternum","vnode1","vnode2","centerpoint","movevec","movenorm","checkVNodeInBound","minCross","bestVnode","potentialNode","pnode","count","node3","temppoint","samepoiint","newid","index1","index2","newedge","isLocalTree","surfaceRoutingEdge","oneEdge","dragControlPoint","edgeindex","segindex","bubbleState","editReDraw","dragEdge","handleMouseDown","newline","edgeIndex","segIndex","thisedgeindex","thissegindex","deleteEdge","findCircle","catEdges","nodeDegree","finish","circleEdges","has","lastcat","checkCircle","isAdded","worstindex","worstscore","worstEdge","drag","nodeindex","st","en","rerouting","w","h","deleteEdges","reroutingEdges","pointedgedis","preEdge","tmpp","vnodes1","flag1","st1_p","en1_p","st2_p","en2_p","vnodes2","path","clickIndex","hasLinked","lines1","vnodes","lines2","p4","midx","midy","midnode","initWithNoCluster","preAddedClusters","catclusters","startclusterid","endclusterid","merged","newclusterdict","createGraphWithCluster","createLocalTree","hierarchicalMergeV2","dbscan","DBSCAN","dataset","pointDataSet","clusters","run","clusterPoints","noise","g2","cluster1","cluster2","calClusterDistance","minstart","minend","minScore","bestStart","bestEnd","minScoreWithDis","links","minIndex","minScoreWithDistance","minIndexWithDistance","hasBest","checkConnectBetweenTwoCluster","rectangle","top","intersections","intersect","status","pointInRectangle","weightCross","isDeleted","checkConnectBetweenTwoClusterV2","totcluster","optimalLinks1","optimalLinks2","addLinks","checkConnectBetweenAllCluster","bestLink","unionFather","checkConnectBetweenAllClusterV2","optimalLinks","link","findOptimalLink","findMinScore","sortEdgesGlobalWithCluster","findLinkBetweenCluster","checkConnectBetweenCluster","clusterstart","clusterend","infostr","handleManually","afterEditReDraw","content","blob","Blob","type","saveAs","marginTop","checkedChildren","unCheckedChildren","editBackbone","editMST","AlgorithmEntry","alert","finishInput","svg","svgsaver","Header","Select","Option","Layout","Footer","Sider","Content","columns","title","dataIndex","render","text","keynum","GroupDict","cur_set","rowSelection","selectedRowKeys","selectedRows","getCheckboxProps","record","name","colorArray","is_input","IndexUI","updateview","GroupData","key","dataFile","scaleX","scaleY","selValue","hasCreateMST","menu","Item","rel","savePNG","saveSVG","box","handleMousedown","undefined","Scale","tmpg","handleDeleteNode","addNewPoints","set","tmp_index","findIndex","curcat","tmpcat","tmpGroupData","scale_ratio_x","scale_ratio_y","transform_dx","transform_dy","ratio","filename","drawInit","saveData","saveSvgAsPng","viewbox","svgstr","html","options","p5","pad1","pad2","background","textAlign","fontFamily","fontWeight","fontSize","theme","padding","className","float","border","showSearch","placeholder","changeSel","handleUpload","overlay","arrow","DownOutlined","pagination","position","scroll","dataSource","BubbleDemo","d3Voronoi","re","tanPointsNum","deltaDeg","triangulate","EdgeWidth","neighbors","pathDataToPolys","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.86795f59.chunk.js","sourcesContent":["//https://github.com/janogonzalez/priorityqueuejs\n\nmodule.exports = PriorityQueue;\n\nfunction PriorityQueue(d) {\n    this._d = d;\n    this._elements = [];\n}\n\nPriorityQueue.prototype.checkEdgeCrossing = function(P1,P2,Q1,Q2){\n    if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\n        if(\n            ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\n            ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\n        ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false\n    }\n}\n\nPriorityQueue.prototype.isEmpty = function() {\n    return this.size() === 0;\n};\n\nPriorityQueue.prototype.peek = function() {\n    if (this.isEmpty()) throw new Error('PriorityQueue is empty');\n    return this._elements[0];\n};\n\nPriorityQueue.prototype.modify_Prim = function(e1,e2,thisid,weightcross){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    let szbefore = this._elements.length;\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let id = this._d[this._elements[i]].clusterid2;\n        if((!this._d.hasOwnProperty(this._elements[i])) || id == thisid){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n    }\n    let tmp = this._elements;\n    this._elements = [];\n    for(let i = 0;i< tmp.length;i++){\n        this.enq(tmp[i]);\n    }\n\n    let sz = this._elements.length;\n    if(sz <= 1 || sz == szbefore){\n        return;\n    }\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n}\n\nPriorityQueue.prototype.searchFather = function (f,x){\n    while(x!=f[x]){\n        f[x] = f[f[x]];\n        x = f[x];\n    }\n    return x;\n}\n\nPriorityQueue.prototype.adjust = function(start, m){\n    let i = start;\n    let j = 2 * i + 1;\n    let tmp = this._elements[i];\n    while(j <= m){\n        if(j < m && this._compare(j, j + 1)){\n            j ++;\n        }\n        if(this._d[tmp].score <= this._d[this._elements[j]].score){\n            break;\n        }\n        else{\n            this._elements[i] = this._elements[j];\n            //V1\n            //this._d[this._elements[i]].pid = i;\n            i = j;\n            j = 2 * j + 1;\n        }\n    }\n    this._elements[i] = tmp;\n    //V1\n    //this._d[this._elements[i]].pid = i;\n}\n//function(e1,e2,f,weightcross,fa)\n\nPriorityQueue.prototype.modify_Kruskal_V2 = function(e1,e2,f,weightcross){\n\n    //let szbefore = this._elements.length;\n    let tmp = []\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n        let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n        if((!this._d.hasOwnProperty(this._elements[i]))){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(fs == fe){\n            delete this._d[this._elements[i]];\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n        tmp.push(this._elements[i])\n    }\n\n    let sz = tmp.length;\n\n    if(sz <= 1){\n        return;\n    }\n\n    this._elements=[]\n\n    for(let i = 0;i < sz;i ++){\n        this.enq(tmp[i]);\n    }\n\n    //for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n    //    this.adjust(i,sz - 1);\n    //}\n\n}\n\nPriorityQueue.prototype.modify_Kruskal = function(e1,e2,f,weightcross,fa){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    //let szbefore = this._elements.length;\n    //for(let i = this._elements.length - 1;i >= 0;i --){\n    //    let s = this._d[this._elements[i]].start;\n    //    let e = this._d[this._elements[i]].end;\n    //    let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n    //    let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n    //    if((!this._d.hasOwnProperty(this._elements[i]))){\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(fs == fa && fe == fa){\n    //        delete this._d[this._elements[i]];\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n    //        this._d[this._elements[i]].score += weightcross\n    //    }\n    //}\n\n    let sz = this._elements.length;\n\n    //if(sz <= 1 || sz == szbefore){\n    //    return;\n    //}\n\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n    //for(let i = 0;i < sz;i ++){\n    //    this._d[this._elements[i]].pid = i;\n    //}\n\n}\n\nPriorityQueue.prototype.deq = function() {\n    //let a = this._elements.length\n    //console.log(\"deq before: \" + a)\n    //delete this._d[this._elements[0]];\n    var first = this.peek();\n    //V1\n    //this._d[first].pid = -1;\n    var last = this._elements.pop();\n    var size = this.size();\n    if (size === 0) return first;\n\n    this._elements[0] = last;\n    var current = 0;\n\n    while (current < size) {\n        var largest = current;\n        var left = (2 * current) + 1;\n        var right = (2 * current) + 2;\n\n        if (left < size && this._compare(left, largest) >= 0) {\n            largest = left;\n        }\n\n        if (right < size && this._compare(right, largest) >= 0) {\n            largest = right;\n        }\n\n        if (largest === current) break;\n\n        this._swap(largest, current);\n        current = largest;\n    }\n    //let b = this._elements.length\n    //console.log(\"deq after: \" + b)\n    return first;\n};\n\nPriorityQueue.prototype.enq = function(element) {\n    //let a = this._elements.length\n    //console.log(\"enq before: \" + a)\n    var size = this._elements.push(element);\n    var current = size - 1;\n\n    while (current > 0) {\n        var parent = Math.floor((current - 1) / 2);\n        if (this._compare(current, parent) <= 0) break;\n        this._swap(parent, current);\n        current = parent;\n    }\n   //let b = this._elements.length\n   //console.log(\"enq after: \" + b)\n    return size;\n};\n\nPriorityQueue.prototype.size = function() {\n    return this._elements.length;\n};\n\nPriorityQueue.prototype.forEach = function(fn) {\n    return this._elements.forEach(fn);\n};\n\nPriorityQueue.prototype._compare = function(a, b) {\n    return this._d[this._elements[b]].score - this._d[this._elements[a]].score;\n};\n\nPriorityQueue.prototype._swap = function(a, b) {\n    var aux = this._elements[a];\n    this._d[this._elements[a]].pid = b;\n    this._d[this._elements[b]].pid = a;\n    this._elements[a] = this._elements[b];\n    this._elements[b] = aux;\n};","export default __webpack_public_path__ + \"static/media/logo.2d27ead7.svg\";","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#434343','#8701ec','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass MainSvg extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample3.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n               this.centralizeData()\r\n                this.calEPS()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n            for (let i=0;i<sortedEdges.length;i++){\r\n                let start=sortedEdges[i][0]\r\n                let end=sortedEdges[i][1]\r\n                let weight=sortedEdges[i][2]\r\n                let dis=sortedEdges[i][3]\r\n                let mess=sortedEdges[i][4]\r\n\r\n                if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                    continue\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n                if(!dfs.hasPathTo(end)){\r\n                    if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                        this.graph.addEdge(start,end)\r\n                        // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                        this.edges.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            mess:mess\r\n                        })\r\n                        // this.graph.node(start).label=true\r\n                        // this.graph.node(end).label=true\r\n                    }\r\n                    else{\r\n                        removeEdggeList.push({\r\n                            start:start,\r\n                            end:end,\r\n                            weight:weight,\r\n                            dis:dis,\r\n                            crossnum:-1,\r\n                            mess:mess\r\n                        })\r\n                    }\r\n                    // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                    // console.log(this.graph.adj(start))\r\n                    // this.drawLine(this.pointData)\r\n                }\r\n            }\r\n\r\n        while(!this.checkConnect()){\r\n                let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n            // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n/*        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index=i\r\n            d3.select(\"svg\")\r\n                .append(\"circle\")\r\n                .attr(\"cx\",this.pointData[i].x)\r\n                .attr(\"cy\",this.pointData[i].y)\r\n                .attr(\"r\",this.pointData[i].radius)\r\n                .attr(\"fill\",colors[this.pointData[i].cat])\r\n                .attr(\"catefory\",this.pointData[i].cat)\r\n                .attr(\"index\",index)\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.pointData[index])\r\n                })\r\n                .on(\"drag\",function(){\r\n                    console.log(\"drag!\")\r\n                })\r\n                .call(drag)\r\n        }\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        let maxOneCross=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let oneCrossNum=0\r\n\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                        oneCrossNum+=1\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(oneCrossNum>maxOneCross){\r\n                maxOneCross=oneCrossNum\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n        console.log(\"max crossing num of one edge: \"+maxOneCross)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.savePointData.bind(this)}> Save </button>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default MainSvg","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\n\r\n\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass DataHacker extends Component{\r\n    constructor() {\r\n        super();\r\n        this.globalCategory=0\r\n        this.points=[]\r\n        this.numOfPoints=0\r\n        this.nowCategory=0\r\n        this.jsonoutput=null\r\n        this.input=null\r\n        this.width=60\r\n        this.height=70\r\n    }\r\n\r\n    componentDidMount() {\r\n        d3.select(\"svg\")\r\n            .on(\"click\",this.leftClick.bind(this))\r\n/*        for (let i=0;i<11;i++){\r\n            d3.select(\"svg\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",(i+1)*1000/11)\r\n                .attr(\"y1\",0)\r\n                .attr(\"x2\",(i+1)*1000/11)\r\n                .attr(\"y2\",1000)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", \"2px\");\r\n\r\n        }*/\r\n\r\n    }\r\n\r\n\r\n    drawPoint(x,y,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",7)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n    }\r\n\r\n    drawRect(x,y,w,h,color,cat,index){\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"width\",w)\r\n            .attr(\"height\",h)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .on(\"click\",this.deletePoint.bind(this))\r\n        d3.select(\"svg\")\r\n            .append(\"text\")\r\n            .attr(\"x\",x-w/2)\r\n            .attr(\"y\",y-h/2)\r\n            .attr(\"index\",index)\r\n            .style(\"font-size\",12)\r\n            .text(index)\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n    leftClick(e){\r\n        // console.log(e)\r\n        let x=e.offsetX\r\n        let y=e.offsetY\r\n        // this.drawRect(x,y,this.width,this.height,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.drawPoint(x,y,colors[this.nowCategory],this.nowCategory,this.numOfPoints)\r\n        this.points.push({\r\n            x:x,\r\n            y:y,\r\n            cat:this.nowCategory,\r\n            id:this.numOfPoints,\r\n            radius:7\r\n            // width:this.width,\r\n            // height:this.height\r\n        })\r\n        this.numOfPoints+=1\r\n        // console.log(this.points)\r\n    }\r\n\r\n    savePoints(){\r\n        let tempPoints=[]\r\n        let num=0\r\n        for (let i=0;i<this.points.length;i++){\r\n            if(this.points[i]!=-1){\r\n                this.points[i].id=num\r\n                num+=1\r\n                tempPoints.push(this.points[i])\r\n            }\r\n        }\r\n        this.points=tempPoints\r\n        d3.select(\"svg\").selectAll(\"circle\").remove()\r\n        d3.select(\"svg\").selectAll(\"text\").remove()\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            // this.drawRect(this.points[i].x,this.points[i].y,this.points[i].width,this.points[i].height,colors[this.points[i].cat],this.points[i].cat,i)\r\n            this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n\r\n        }\r\n        this.numOfPoints=this.points.length\r\n\r\n        for (let i=0;i<this.points.length;i++){\r\n            this.points[i].cat=this.points[i].cat.toString()\r\n            this.points[i].shape=\"circle\"\r\n\r\n        }\r\n\r\n        // console.log(this.points)\r\n        let res=JSON.stringify(this.points)\r\n        this.jsonoutput.innerHTML=res\r\n        console.log(res)\r\n    }\r\n\r\n    addCategory(){\r\n        this.globalCategory+=1\r\n        this.nowCategory=this.globalCategory\r\n        console.log(this.globalCategory)\r\n    }\r\n\r\n    loadPoints(){\r\n        fetch('/data/savedDate.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.points=data\r\n                this.numOfPoints=this.points.length-1\r\n                let categories=[]\r\n\r\n                for (let i=0;i<this.points.length;i++){\r\n                    this.drawPoint(this.points[i].x,this.points[i].y,colors[this.points[i].cat],this.points[i].cat,i)\r\n                    if(categories.indexOf(this.points[i].cat)<0){\r\n                        categories.push(this.points[i].cat)\r\n                    }\r\n                }\r\n                this.globalCategory=categories.length-1\r\n                 this.nowCategory=this.globalCategory\r\n                console.log(this.points)\r\n            })\r\n    }\r\n\r\n    switchCategory(){\r\n        let cat=parseInt(this.input.value)\r\n        this.nowCategory=cat\r\n        // this.input.value=\"\"\r\n        console.log(cat)\r\n    }\r\n    changeWidthHeight(){\r\n        let wh=this.input2.value.split(\",\")\r\n        console.log(this.input.value)\r\n        let w=parseFloat(wh[0])\r\n        let h=parseFloat(wh[1])\r\n        this.width=w\r\n        this.height=h\r\n        // this.input.value=\"\"\r\n        console.log(w,h)\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <svg id={\"hacksvg\"} width={\"1000px\"} height={\"1000px\"} >\r\n                </svg>\r\n                <button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>\r\n                <input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>\r\n                <button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>\r\n                <button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>\r\n                <button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>\r\n                <input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>\r\n                <button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>\r\n                <label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>\r\n\r\n                </label>\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default DataHacker","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass CSVData extends Component{\r\n    constructor() {\r\n        super();\r\n        this.population=null\r\n        this.lifeExp=null\r\n        this.fertility=null\r\n        this.geoInfo=null\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.getPopulation()\r\n    }\r\n\r\n    getPopulation(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/population_total.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.population=data\r\n                console.log(\"population\")\r\n                console.log(that.population)\r\n                that.getLifeExpectancy()\r\n            })\r\n    }\r\n\r\n    getLifeExpectancy(){\r\n        let that=this\r\n        d3.csv(\"data/GapMinder/life_expectancy_years.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.lifeExp=data\r\n                console.log(\"lifeexp\")\r\n                console.log(that.lifeExp)\r\n                that.getFertility()\r\n            })\r\n    }\r\n\r\n    getFertility(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/children_per_woman_total_fertility.csv\",function(data){\r\n            return {\r\n                country:data.country,\r\n                value:data.value\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.fertility=data\r\n                console.log(\"fertility\")\r\n                console.log(that.fertility)\r\n                that.getGroInfo()\r\n            })\r\n    }\r\n\r\n    getGroInfo(){\r\n        let that=this\r\n\r\n        d3.csv(\"data/GapMinder/ddf--entities--geo--country.csv\",function(data){\r\n            return {\r\n                country:data.name,\r\n                value:data.worldregion\r\n            }\r\n        })\r\n            .then(function(data){\r\n                that.geoInfo=data\r\n                console.log(that.geoInfo)\r\n                that.dataFusion()\r\n            })\r\n    }\r\n\r\n    dataFusion(){\r\n        let datapoint=[]\r\n        let countrylist={}\r\n        let catnum=0\r\n        let catDict={}\r\n\r\n        for (let i=0;i<this.fertility.length;i++){\r\n            if(this.fertility[i].value==\"\"){\r\n                continue\r\n            }\r\n            let country=this.fertility[i].country\r\n            let hascat=false\r\n\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(!catDict.hasOwnProperty(this.geoInfo[j].value)){\r\n                    catDict[this.geoInfo[j].value]=catnum\r\n                    catnum+=1\r\n                }\r\n                if(country==this.geoInfo[j].country){\r\n                    // datapoint[i].geo=this.geoInfo[j].value\r\n                    // datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    hascat=true\r\n                    break\r\n                }\r\n            }\r\n            if(!hascat){\r\n                console.log(this.fertility[i].country)\r\n                continue\r\n            }\r\n            else{\r\n                datapoint.push({\r\n                    country:this.fertility[i].country,\r\n                    fertility:parseFloat(this.fertility[i].value)\r\n                })\r\n            }\r\n\r\n        }\r\n\r\n        for (let i=0;i<datapoint.length;i++){\r\n            let country=datapoint[i].country\r\n\r\n            for (let j=0;j<this.population.length;j++){\r\n                if(country==this.population[j].country){\r\n                    datapoint[i].population=parseInt(this.population[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.lifeExp.length;j++){\r\n                if(country==this.lifeExp[j].country){\r\n                    datapoint[i].lifeExp=parseFloat(this.lifeExp[j].value)\r\n                    break\r\n                }\r\n            }\r\n            for (let j=0;j<this.geoInfo.length;j++){\r\n                if(country==this.geoInfo[j].country){\r\n                    datapoint[i].geo=this.geoInfo[j].value\r\n                    datapoint[i].cat=catDict[this.geoInfo[j].value]\r\n                    break\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n\r\n\r\n        this.data=datapoint\r\n        // console.log(JSON.stringify(datapoint))\r\n        console.log(datapoint)\r\n        this.drawScatterPlot()\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",5)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([0,800])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([1000,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([3,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    getCSV(){\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    render(){\r\n        return (<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default CSVData","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass GapMinderNew extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.population=[]\r\n        this.fertility=[]\r\n        this.lifeExp=[]\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/population.csv\",function(data){\r\n            // console.log(data)\r\n                // console.log(data[i])\r\n                let country=data.Country\r\n                that.data.push({\r\n                    country:country,\r\n                    population:parseInt(data.Pop1985),\r\n                    fertility:parseFloat(data.F1985),\r\n                    lifeExp:parseFloat(data.L1985),\r\n                    geo:data.Group\r\n                })\r\n        }).then(function(data){\r\n            let catDict={}\r\n            let catnum=0\r\n            for (let i=0;i<that.data.length;i++){\r\n                if(!catDict.hasOwnProperty(that.data[i].geo)){\r\n                    catDict[that.data[i].geo]=catnum\r\n                    catnum++\r\n                }\r\n            }\r\n            for (let i=0;i<that.data.length;i++){\r\n                that.data[i].cat=catDict[that.data[i].geo]\r\n            }\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n\r\n        let xscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.fertility)})),d3.max(this.data.map((d)=>{return d.fertility}))])\r\n            .range([50,900])\r\n        let yscale=d3.scaleLinear().domain([d3.min(this.data.map((d)=>{return parseFloat(d.lifeExp)})),d3.max(this.data.map((d)=>{return d.lifeExp}))])\r\n            .range([900,0])\r\n        let rscale=d3.scaleSqrt().domain([d3.min(this.data.map((d)=>{return d.population})),d3.max(this.data.map((d)=>{return d.population}))])\r\n            .range([5,20])\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(xscale(this.data[i].fertility),yscale(this.data[i].lifeExp),rscale(this.data[i].population),colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",x)\r\n            .attr(\"cy\",y)\r\n            .attr(\"r\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"circle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default GapMinderNew","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\n\r\n\r\nclass ManuallyTree extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n/*        let centerx=minx+(maxx-minx)/2\r\n        let centery=miny+(maxy-miny)/2\r\n        let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x+=move[0]\r\n            this.pointData[i].y+=move[1]\r\n        }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x-=this.minX-20\r\n            this.pointData[i].y-=this.minY-20\r\n        }*/\r\n    }\r\n\r\n    calEPS(){\r\n        POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                // this.calEPS()\r\n                // this.createGraph()\r\n                // this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                // this.drawEdges()\r\n                this.drawPointData()\r\n                // this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n        }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default ManuallyTree","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#ffcc99','#001aff','#c0c0c0','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass Example1 extends  Component{\r\n    constructor() {\r\n        super();\r\n        this.data=[]\r\n        this.pointData=[]\r\n    }\r\n\r\n    componentDidMount() {\r\n        let that=this\r\n        d3.csv(\"data/GapMinder-new/ex1.csv\",function(data){\r\n            // console.log(data)\r\n            // console.log(data[i])\r\n            let country=data.Country\r\n            that.data.push({\r\n                x:parseInt(data.xfield),\r\n                y:parseFloat(data.yfield),\r\n                cat:data.cat\r\n            })\r\n        }).then(function(data){\r\n            console.log(that.data)\r\n            that.drawScatterPlot()\r\n\r\n        })\r\n\r\n    }\r\n\r\n    drawScatterPlot(){\r\n\r\n        for (let i=0;i<this.data.length;i++){\r\n            this.data[i].id=i\r\n            this.drawPoint(this.data[i].x,this.data[i].y,10,colors[this.data[i].cat],this.data[i].cat,i)\r\n        }\r\n\r\n\r\n        this.savePointData()\r\n    }\r\n\r\n    drawPoint(x,y,r,color,cat,index){\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let that=this\r\n        d3.select(\"svg\")\r\n            .append(\"rect\")\r\n            .attr(\"x\",x-r)\r\n            .attr(\"y\",y-r)\r\n            .attr(\"width\",r)\r\n            .attr(\"height\",r)\r\n            .attr(\"fill\",color)\r\n            .attr(\"catefory\",cat)\r\n            .attr(\"index\",index)\r\n            .attr(\"stroke\",\"black\")\r\n            .on(\"mouseover\",function(d,i){\r\n                console.log(that.data[index])\r\n            })\r\n            .call(drag)\r\n        this.pointData.push({\r\n            x:x,\r\n            y:y,\r\n            cat:cat,\r\n            id:index,\r\n            shape:\"rectangle\",\r\n            radius:r,\r\n            width:r,\r\n            height:r\r\n        })\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    render() {\r\n        return(<div id={\"svgcontainer\"}>\r\n            <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n            </svg>\r\n            <button onClick={this.savePointData.bind(this)}> Save </button>\r\n        </div>)\r\n    }\r\n}\r\n\r\nexport default Example1","\r\nimport ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport * as d3 from \"d3\"\r\n\r\nvar colors=['#fbb132','#8701ec','#434343','#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=20\r\n\r\nvar clustering = require('density-clustering');\r\n\r\n\r\nclass LocalCluster extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n/*                d3.select(\"svg\")\r\n            .append(\"circle\")\r\n            .attr(\"cx\",POINT_EDGE_EPS)\r\n            .attr(\"cy\",POINT_EDGE_EPS)\r\n            .attr(\"r\",POINT_EDGE_EPS)\r\n            .attr(\"fill\",\"black\")*/\r\n        console.log(POINT_EDGE_EPS)\r\n    }\r\n\r\n    getData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                // this.findCluster()\r\n                this.createGraph()\r\n                this.calBackboneWithMinDis()\r\n                // this.calBackbone()\r\n                this.drawPointData()\r\n                // this.generateTreeWithHierarchical()\r\n                this.drawEdges()\r\n                this.countEdgeCrossing()\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n\r\n    checkConnectBetweenCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(\"svg\").append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .on(\"mouseover\",function(d,i){\r\n                    console.log(that.edges[index])\r\n                })\r\n        }\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        console.log(this.edges)\r\n        d3.selectAll(\"line\").remove()\r\n        let that=this\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let node1=this.edges[i].start\r\n            let node2=this.edges[i].end\r\n\r\n            d3.select(\"svg\").append(\"line\")\r\n                .attr(\"x1\",this.pointData[node1].x)\r\n                .attr(\"y1\",this.pointData[node1].y)\r\n                .attr(\"x2\",this.pointData[node2].x)\r\n                .attr(\"y2\",this.pointData[node2].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",i)\r\n                .on(\"click\",function(){\r\n                    let removeindex=d3.select(this).attr(\"index\")\r\n                    that.edges[removeindex].isdelete=true\r\n                    d3.select(this).remove()\r\n                    console.log(that.edges)\r\n                })\r\n        }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/BubbleSetEdge2.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(\"svg\").append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"svg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",colors[this.pointData[i].cat])\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"click\",that.clickItem.bind(that))\r\n                // .on(\"drag\",function(){\r\n                //     console.log(\"drag!\")\r\n                // })\r\n                .call(drag)\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n        // console.log(this.edges)\r\n/*        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }*/\r\n\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        this.findCluster()\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                this.createLocalTree(this.clusterDict[k][i])\r\n            }\r\n        }\r\n\r\n        this.mergeCluster()\r\n    }\r\n\r\n    findCluster(){\r\n        for (var k in this.catPointDict){\r\n            console.log(k)\r\n            this.clusterDict[k]=[]\r\n            this.noiseDict[k]=[]\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n            var clusters = dbscan.run(dataset, POINT_EDGE_EPS, 2);\r\n            console.log(clusters, dbscan.noise);\r\n            let point\r\n            for(let i=0;i<clusters.length;i++){\r\n                let clusterPoints=[]\r\n                for (let j=0;j<clusters[i].length;j++){\r\n                     clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                    // console.log(point)\r\n/*                    let point=dataset[clusters[i][j]]\r\n                    d3.select(\"svg\")\r\n                        .append(\"circle\")\r\n                        .attr(\"cx\",point[0])\r\n                        .attr(\"cy\",point[1])\r\n                        .attr(\"r\",10)\r\n                        .attr(\"fill\",\"none\")\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",2)*/\r\n                }\r\n                // this.createLocalTree(clusterPoints)\r\n                this.clusterDict[k].push(clusterPoints)\r\n            }\r\n            for (let i=0;i<dbscan.noise.length;i++){\r\n                this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        console.log(this.clusterArr)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        this.clustergraph=g\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let mincrossnum=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n\r\n                }\r\n                if(crossnum<mincrossnum){\r\n                    mincrossnum=crossnum\r\n                    minstart=start\r\n                    minend=end\r\n                }\r\n                else if(crossnum==mincrossnum){\r\n                    let dis1=this.calDistance(minstart,minend)\r\n                    let dis2=this.calDistance(start,end)\r\n                    if(dis2<dis1){\r\n                        mincrossnum=crossnum\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [minstart,minend,mincrossnum]\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    render(){\r\n        return (\r\n            <div id={\"svgcontainer\"}>\r\n                <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n                </svg>\r\n                <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n                <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default LocalCluster","import * as d3 from \"d3\";\r\n\r\nexport function add(a,b){\r\n    return a+b\r\n}\r\n\r\nexport function calDistance(x1,y1,x2,y2){\r\n    return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2))\r\n}\r\n\r\nexport function getVecNorm(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    return norm\r\n}\r\n\r\nexport function normalizeVec(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    let newvec=[vec[0]/norm,vec[1]/norm]\r\n    return newvec\r\n}\r\n\r\nexport function drawCircle(x,y,r,fill,stroke){\r\n    d3.select(\"#mainsvg\")\r\n        .append(\"circle\")\r\n        .attr(\"class\",\"elespace\")\r\n        .attr(\"cx\",x)\r\n        .attr(\"cy\",y)\r\n        .attr(\"r\",r)\r\n        .attr(\"fill\",fill)\r\n        .attr(\"stroke\",stroke)\r\n        .attr(\"stroke-width\",1)\r\n}\r\n\r\nexport function drawRect(x,y,width,height,color){\r\n    d3.select(\"svg\")\r\n        .append(\"rect\")\r\n        .attr(\"x\",x-width/2)\r\n        .attr(\"y\",y-height/2)\r\n        .attr(\"width\",width)\r\n        .attr(\"height\",height)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",color)\r\n        .attr(\"stroke-width\",2)\r\n}\r\n\r\nexport function drawPolygon(points,dx,dy,color){\r\n    d3.select(\"svg\").append(\"path\")\r\n        .style(\"fill\", \"none\")\r\n        .style(\"stroke\",color)\r\n        .style(\"stroke-width\", 0.5)\r\n        .attr(\"d\", function () {\r\n            var p = \"\";\r\n            p += (d3.line()\r\n                    .x(function (dat) {\r\n                        return dat[0]+dx;\r\n                    })\r\n                    .y(function (dat) {\r\n                        return dat[1]+dy;\r\n                    })\r\n            )(points)+ \"\";\r\n            return p;\r\n        })\r\n        .on('mouseover', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"red\")\r\n                .style(\"stroke-width\", 2);\r\n        })\r\n        .on('mouseout', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"black\")\r\n                .style(\"stroke-width\", 0.5);\r\n        });\r\n}\r\nexport function drawLine(start,end,color,width){\r\n    d3.select(\"svg\").append(\"line\")\r\n        .attr(\"x1\",start[0])\r\n        .attr(\"y1\",start[1])\r\n        .attr(\"x2\",end[0])\r\n        .attr(\"y2\",end[1])\r\n        .attr(\"stroke-width\",width)\r\n        .attr(\"stroke\",color)\r\n        .on(\"mouseover\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",\"red\")\r\n        })\r\n        .on(\"mouseout\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",color)\r\n        })\r\n}\r\n\r\nexport function  isContained(catarr,cat){\r\n    catarr=catarr.split(\",\")\r\n    for(let i=0;i<catarr.length;i++){\r\n        if(catarr[i]==cat){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function  PointToSegDist( x,  y,  x1,  y1,  x2,  y2)\r\n{\r\n     let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n    // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n    if (cross <= 0) return -1\r\n\r\n     let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n    // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n    if (cross >= d2) return -1\r\n\r\n\r\n\r\n    let r = cross / d2;\r\n    let px = x1 + (x2 - x1) * r;\r\n    let py = y1 + (y2 - y1) * r;\r\n    return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));\r\n}\r\n\r\nfunction calLineCirclePoint(){\r\n    //ax+by+c=0\r\n}\r\n\r\nexport function calTanPoint(cx,cy,radius,point) {\r\n    //\r\n    let d = Math.sqrt(Math.pow(cx - point.x,2) + Math.pow(cy - point.y,2));\r\n    let vc1c2 = {x:point.x - cx,y:-point.y + cy}; //y\r\n    let radC1C2 = Math.acos(vc1c2.x / Math.sqrt(Math.pow(vc1c2.x,2) + Math.pow(vc1c2.y,2)));\r\n    let theta = Math.acos(radius/d);\r\n    if(point.y < cy){\r\n        let p1 = {x:cx + Math.cos(theta + radC1C2)*radius,y:cy - Math.sin(theta + radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(theta - radC1C2)*radius,y:cy + Math.sin(theta - radC1C2)*radius};\r\n        return {p1:p1,p2:p2};\r\n    }else{\r\n        radC1C2 = Math.PI - radC1C2;\r\n        let p1 = {x:cx + Math.cos(Math.PI - theta - radC1C2)*radius,y:cy + Math.sin(Math.PI - theta - radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(Math.PI - (theta - radC1C2))*radius,y:cy - Math.sin(Math.PI - (theta - radC1C2))*radius};\r\n        return {p1:p1,p2:p2};\r\n    }\r\n}\r\n\r\nexport function calCommonTanPoint(x1,y1,r1,x2,y2,r2){\r\n    let tanPoints=[]\r\n    let delta1=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1+r2,2)//+\r\n    let delta2=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1-r2,2)//-\r\n\r\n    let p1=r1*(x2*x2+y2*y2-x1*x2-y1*y2)\r\n    let p2=r2*(x1*x1+y1*y1-x1*x2-y1*y2)\r\n    let q=x1*y2-x2*y1\r\n\r\n    //four points\r\n    let vecpq=[x2-x1,y2-y1]\r\n    let normvec=[-vecpq[1],vecpq[0]]\r\n    let dir=normalizeVec(normvec)\r\n    let newpointp=[x1+r1*dir[0],y1+r1*dir[1]]\r\n    let newpointq=[x2+r2*dir[0],y2+r2*dir[1]]\r\n\r\n    tanPoints.push([newpointp,newpointq])\r\n\r\n    let dir2=[-1*dir[0],-1*dir[1]]\r\n    let newpointp2=[x1+r1*dir2[0],y1+r1*dir2[1]]\r\n    let newpointq2=[x2+r2*dir2[0],y2+r2*dir2[1]]\r\n\r\n    tanPoints.push([newpointp2,newpointq2])\r\n\r\n\r\n    if(delta1<0&&delta2<0){\r\n        return []\r\n    }\r\n    else if(delta1<0&&delta2>0){\r\n        //, just four points, two lines\r\n        return tanPoints\r\n    }\r\n    else if(delta1==0&&delta2>0){\r\n        //, five points, two lines\r\n        return tanPoints\r\n\r\n    }\r\n    else if(delta1>0&&delta2>0){\r\n        //, eight points, four lines\r\n        let intersecx=(r1*x2+r2*x1)/(r1+r2)\r\n        let intersecy=(r1*y2+r2*y1)/(r1+r2)\r\n        let tanpoints1=calTanPoint(x1,y1,r1,{x:intersecx,y:intersecy})\r\n        let tanpoints2=calTanPoint(x2,y2,r2,{x:intersecx,y:intersecy})\r\n\r\n        let p1=tanpoints1.p1\r\n        let p2={x:intersecx,y:intersecy}\r\n        let p3=tanpoints2.p1\r\n\r\n        let delta=(p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x)\r\n        if(Math.abs(delta)<=0.000001){\r\n            //p1p1\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n\r\n        }\r\n    else{\r\n        //p1p2\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n        }\r\n\r\n    return tanPoints\r\n\r\n    }\r\n\r\n    else{\r\n        return []\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport function drawArc(startp,endp,center,radius){\r\n    let pathstr=\"\"\r\n    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n    let largearcflag=0\r\n    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n    if(crossmul>0){\r\n        largearcflag=1\r\n    }\r\n    else if(crossmul<=0){\r\n        largearcflag=0\r\n    }\r\n    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n    d3.select(\"svg\")\r\n        .append(\"path\")\r\n        .attr(\"d\",pathstr)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",\"black\")\r\n        .attr(\"stroke-width\",\"1\")\r\n}\r\n\r\nexport function getDegreeTwoVec(vec1,vec2){\r\n    let norm1=getVecNorm(vec1)\r\n    let norm2=getVecNorm(vec2)\r\n    let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n\r\n    let cos=dot/(norm1*norm2)\r\n\r\n    return Math.acos(cos)\r\n\r\n}\r\n\r\nexport function rotatePoint(x,y,rx0,ry0,alpha){\r\n    let x0= (x - rx0)*Math.cos(alpha) - (y - ry0)*Math.sin(alpha) + rx0 ;\r\n    let y0= (x - rx0)*Math.sin(alpha) + (y - ry0)*Math.cos(alpha) + ry0 ;\r\n    return [x0,y0]\r\n}\r\n\r\nexport function crossMul(vec1,vec2){\r\n\r\n    return vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n}\r\n\r\nexport function clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}","var BSpline = function(points,degree,copy){\r\n    if(copy){\r\n        this.points = []\r\n        for(var i = 0;i<points.length;i++){\r\n            this.points.push(points[i]);\r\n        }\r\n    }else{\r\n        this.points = points;\r\n    }\r\n    this.degree = degree;\r\n    this.dimension = points[0].length;\r\n    if(degree == 2){\r\n        this.baseFunc = this.basisDeg2;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 3){\r\n        this.baseFunc = this.basisDeg3;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 4){\r\n        this.baseFunc = this.basisDeg4;\r\n        this.baseFuncRangeInt = 3;\r\n    }else if(degree == 5){\r\n        this.baseFunc = this.basisDeg5;\r\n        this.baseFuncRangeInt = 3;\r\n    } \r\n};\r\n\r\nBSpline.prototype.seqAt = function(dim){\r\n    var points = this.points;\r\n    var margin = this.degree + 1;\r\n    return function(n){\r\n        if(n < margin){\r\n            return points[0][dim];\r\n        }else if(points.length + margin <= n){\r\n            return points[points.length-1][dim];\r\n        }else{\r\n            return points[n-margin][dim];\r\n        }\r\n    };\r\n};\r\n\r\nBSpline.prototype.basisDeg2 = function(x){\r\n    if(-0.5 <= x && x < 0.5){\r\n        return 0.75 - x*x;\r\n    }else if(0.5 <= x && x <= 1.5){\r\n        return 1.125 + (-1.5 + x/2.0)*x;\r\n    }else if(-1.5 <= x && x < -0.5){\r\n        return 1.125 + (1.5 + x/2.0)*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg3 = function(x){\r\n    if(-1 <= x && x < 0){\r\n        return 2.0/3.0 + (-1.0 - x/2.0)*x*x;\r\n    }else if(1 <= x && x <= 2){\r\n        return 4.0/3.0 + x*(-2.0 + (1.0 - x/6.0)*x);\r\n    }else if(-2 <= x && x < -1){\r\n        return 4.0/3.0 + x*(2.0 + (1.0 + x/6.0)*x);\r\n    }else if(0 <= x && x < 1){\r\n        return 2.0/3.0 + (-1.0 + x/2.0)*x*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg4 = function(x){\r\n    if(-1.5 <= x && x < -0.5){\r\n        return 55.0/96.0 + x*(-(5.0/24.0) + x*(-(5.0/4.0) + (-(5.0/6.0) - x/6.0)*x));\r\n    }else if(0.5 <= x && x < 1.5){\r\n        return 55.0/96.0 + x*(5.0/24.0 + x*(-(5.0/4.0) + (5.0/6.0 - x/6.0)*x));\r\n    }else if(1.5 <= x && x <= 2.5){\r\n        return 625.0/384.0 + x*(-(125.0/48.0) + x*(25.0/16.0 + (-(5.0/12.0) + x/24.0)*x));\r\n    }else if(-2.5 <= x && x <= -1.5){\r\n        return 625.0/384.0 + x*(125.0/48.0 + x*(25.0/16.0 + (5.0/12.0 + x/24.0)*x));\r\n    }else if(-1.5 <= x && x < 1.5){\r\n        return 115.0/192.0 + x*x*(-(5.0/8.0) + x*x/4.0);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg5 = function(x){\r\n    if(-2 <= x && x < -1){\r\n        return 17.0/40.0 + x*(-(5.0/8.0) + x*(-(7.0/4.0) + x*(-(5.0/4.0) + (-(3.0/8.0) - x/24.0)*x)));\r\n    }else if(0 <= x && x < 1){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 - x/12.0)*x*x);\r\n    }else if(2 <= x && x <= 3){\r\n        return 81.0/40.0 + x*(-(27.0/8.0) + x*(9.0/4.0 + x*(-(3.0/4.0) + (1.0/8.0 - x/120.0)*x)));\r\n    }else if(-3 <= x && x < -2){\r\n        return 81.0/40.0 + x*(27.0/8.0 + x*(9.0/4.0 + x*(3.0/4.0 + (1.0/8.0 + x/120.0)*x)));\r\n    }else if(1 <= x && x < 2){\r\n        return 17.0/40.0 + x*(5.0/8.0 + x*(-(7.0/4.0) + x*(5.0/4.0 + (-(3.0/8.0) + x/24.0)*x)));\r\n    }else if(-1 <= x && x < 0){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 + x/12.0)*x*x);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.getInterpol = function(seq,t){\r\n    var f = this.baseFunc;\r\n    var rangeInt = this.baseFuncRangeInt;\r\n    var tInt = Math.floor(t);\r\n    var result = 0;\r\n    for(var i = tInt - rangeInt;i <= tInt + rangeInt;i++){\r\n        result += seq(i)*f(t-i);\r\n    }\r\n    return result;\r\n};\r\n\r\nBSpline.prototype.calcAt = function(t){\r\n    t = t*((this.degree+1)*2+this.points.length);//t must be in [0,1]\r\n    if(this.dimension == 2){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t)];\r\n    }else if(this.dimension == 3){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t),this.getInterpol(this.seqAt(2),t)];\r\n    }else{\r\n        var res = [];\r\n        for(var i = 0;i<this.dimension;i++){\r\n            res.push(this.getInterpol(this.seqAt(i),t));\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nexport default BSpline\r\n","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Slider, InputNumber, Row, Col } from 'antd';\r\nimport 'antd/dist/antd.css'; // or 'antd/dist/antd.less'\r\nimport { Button } from 'antd';\r\n\r\nimport * as d3 from \"d3\"\r\nimport {calDistance, drawRect, normalizeVec, drawPolygon, drawLine,PointToSegDist,getVecNorm} from \"./util\"\r\nimport {isoBandOptions} from \"marchingsquares/src/options\";\r\nimport {main} from \"d3/dist/package\";\r\n\r\nimport BSpline from \"./BSpline\";\r\n\r\nvar MarchingSquaresJS = require('marchingsquares');\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar AreaCal = require('2d-polygon-area');\r\n//barrier map:\r\n//1: inside the gap of a node\r\n//2: inside the gap of an edge\r\n//3. inside a node\r\n//4. inside an edge\r\n//5. inside the initial field of a node\r\n//6. inside the initial field of an edge\r\n\r\n// Note: X and Y attribute are all center point for both circle and rectangle!\r\n\r\nvar pointDataName=\"BubbleSetExample1.txt\"\r\nvar edgeDataName=\"BubbleSetEdge1.txt\"\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar buffer=10\r\n// var nodeR0=10\r\n// var nodeR1=20\r\n// var edgeR0=15\r\n// var edgeR1=20\r\nvar nodeR1=15\r\nvar nodeR0=nodeR1-5\r\n\r\nvar edgeR1=20\r\nvar edgeR0=edgeR1-5\r\n\r\n\r\nvar defaultEdgeWidth=5\r\nvar edgeWidth=5 //5-10\r\nvar itemEnergyShape=\"circle\"\r\nvar nodeWeight=1\r\nvar edgeWeight=1\r\nvar nodeNegWeight=-0.8\r\nvar edgeNegWeight=0\r\nvar barrierGap=3\r\nvar intervals = [0.001]\r\nvar pixelGroup = 2\r\nvar gapBetween=1\r\nvar fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\nvar control_points={}\r\nvar initialControlPoints={}\r\nvar is_selected={}\r\nvar eps = 1e-10\r\nvar move_points = []\r\nvar mid_point = 0\r\nvar nearpts = []\r\nvar svg;\r\nvar g;\r\nvar hasChangeView = false;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\nvar prepoints = []\r\n\r\nvar svgwidth = 2000\r\nvar svgheight = 2000\r\nvar skipPoint = 10\r\nvar minItemArea = Number.MAX_VALUE\r\n\r\nvar editSeg = {}\r\nvar recalNum = 0\r\nvar recal = false\r\nvar remove_Polys = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveBasisClosed);\r\n\r\nvar lineFunction_reDraw = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveCardinal);\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//d3.select(\"svg\")\r\nclass AdaptiveIsovalue extends  Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n        edges: PropTypes.array\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[],\r\n        edges:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        }\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init(){\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.updateIdx = []\r\n        this.firstFlag = true\r\n    }\r\n\r\n    bubbleState(){\r\n        return this.hasBubbles\r\n    }\r\n\r\n    setViewBox(X, Y, Width, Height){\r\n        X = offsetX\r\n        Y = offsetY\r\n        Width = viewWidth\r\n        Height = viewHeight\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n        //let svg = d3.select(\"svg\");\r\n\r\n\r\n        //this.getData()\r\n    }\r\n\r\n    preProcessPoints(points, pdict){\r\n        for(let i = 0;i < points.length; i ++){\r\n            let tmp\r\n            if(points[i].flag == true){\r\n                tmp = this.pointData[points[i].id]\r\n                tmp.flag = true\r\n            }\r\n            else{\r\n                tmp = points[i]\r\n            }\r\n            for (let c = 0;c < tmp.catArray.length; c ++){\r\n                let nowcat = tmp.catArray[c]\r\n                if(!pdict.hasOwnProperty(nowcat)){\r\n                    pdict[nowcat] = []\r\n                }\r\n                pdict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    preProcessEdges(edges, edict, filledges){\r\n        //console.log(\"preProcessEdges\")\r\n        //console.log(edges)\r\n        //console.log(this.edges)\r\n        for(let i = 0;i < edges.length; i ++){\r\n            let tmp\r\n            let catarr\r\n            if(edges[i].flag == true){\r\n                tmp = this.edges[edges[i].id]\r\n                tmp.flag = true\r\n                catarr = this.pointData[tmp.start].catArray\r\n                filledges.push(tmp)\r\n            }\r\n            else{\r\n                tmp = edges[i]\r\n                catarr = tmp.startpoint.catArray\r\n            }\r\n            for (let c = 0;c < catarr.length; c ++){\r\n                let nowcat = catarr[c]\r\n                if(!edict.hasOwnProperty(nowcat)){\r\n                    edict[nowcat] = []\r\n                }\r\n                edict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    editReDraw(editPoints, editEdges, HpointData, Hedges){\r\n\r\n        //console.log(\"editReDraw:\")\r\n        //console.log(editEdges)\r\n\r\n        console.time(\"Total Time\")\r\n\r\n        let tmpedges = clone(this.edges)\r\n        //console.log(\"Before:\")\r\n        //console.log(tmpedges)\r\n\r\n        this.pointData = HpointData\r\n        this.edges = Hedges\r\n        this.catPointDict = {}\r\n        this.catEdgeDict = {}\r\n        this.updateIdx = []\r\n        this.itemShape = this.pointData[0].shape\r\n\r\n        for (let i = 0; i < this.pointData.length; i++) {\r\n            this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id = i\r\n            this.pointData[i].cat = this.pointData[i].cat.toString()\r\n            let cats = this.pointData[i].cat.split(\",\")\r\n            let catarray = []\r\n            if (cats.length > 1) {\r\n                this.pointData[i].multicat = true\r\n                for (let c = 0; c < cats.length; c++) {\r\n                    catarray.push(cats[c])\r\n                }\r\n            } else {\r\n                this.pointData[i].multicat = false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray = catarray\r\n        }\r\n\r\n        this.centralizeData(false)\r\n\r\n        this.calEdgeLength()\r\n\r\n        this.calActiveRegion(false)\r\n\r\n        let updatePoints = {}\r\n        let updateEdges = {}\r\n        let filledges = []\r\n\r\n        this.preProcessPoints(editPoints, updatePoints)\r\n        this.preProcessEdges(editEdges, updateEdges, filledges)\r\n\r\n        //console.log(\"After:\")\r\n        //console.log(this.edges)\r\n        //console.log(\"Update Edges:\")\r\n        //console.log(updateEdges)\r\n\r\n        //console.log(\"update info:\")\r\n        //console.log(updatePoints)\r\n        //console.log(updateEdges)\r\n\r\n        console.time(\"cal energy field\")\r\n        //this.calEnergyField()\r\n        this.calEnergyField_Part(updatePoints, updateEdges)\r\n        console.timeEnd(\"cal energy field\")\r\n\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n            //this.drawEnergyField(\"0\")\r\n        //}\r\n\r\n\r\n\r\n        console.time(\"cal final energy field\")\r\n        //this.calFinalEnergeField()\r\n        //d3.selectAll(\"#final\").remove()\r\n        this.calFinalEnergeField_Part()\r\n        console.timeEnd(\"cal final energy field\")\r\n\r\n        console.time(\"fill cross edge\")\r\n        this.fillCrossingEdge_Part(filledges)\r\n        console.timeEnd(\"fill cross edge\")\r\n\r\n        d3.selectAll(\"path\").remove()\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        //this.drawEdges()\r\n//\r\n        //this.drawPointData()\r\n\r\n\r\n\r\n        console.timeEnd(\"Total Time\")\r\n\r\n        let that=this\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    getData(){\r\n        //let that=this\r\n        //fetch('/data/'+pointDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n            //.then(res=>res.json())\r\n            //.then(data=>{\r\n        if(this.props.pointData && this.props.edges) {\r\n            if(this.props.edges.length > 0){\r\n                this.hasMST = true;\r\n            }\r\n            this.init();\r\n            if(this.hasMST == false){\r\n                let tmp = this.props.createMST()\r\n                this.pointData = tmp[0]\r\n                this.edges = tmp[1]\r\n                this.hasMST = true;\r\n            }\r\n            else{\r\n                this.pointData = this.props.pointData\r\n                this.edges = this.props.edges\r\n            }\r\n            //console.log(\"Draw Bubbles\")\r\n            //console.log(this.pointData)\r\n            //console.log(this.edges)\r\n            this.itemShape = this.pointData[0].shape\r\n            for (let i = 0; i < this.pointData.length; i++) {\r\n                this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n                this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n                this.pointData[i].id = i\r\n                this.pointData[i].cat = this.pointData[i].cat.toString()\r\n\r\n                if(this.pointData[i].hasOwnProperty(\"radius\")){\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].radius * this.pointData[i].radius * Math.PI)\r\n                }\r\n                else{\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].width * this.pointData[i].width)\r\n                }\r\n\r\n                let cats = this.pointData[i].cat.split(\",\")\r\n                let catarray = []\r\n                if (cats.length > 1) {\r\n                    this.pointData[i].multicat = true\r\n                    for (let c = 0; c < cats.length; c++) {\r\n                        catarray.push(cats[c])\r\n                    }\r\n                } else {\r\n                    this.pointData[i].multicat = false\r\n                    catarray.push(this.pointData[i].cat)\r\n                }\r\n                this.pointData[i].catArray = catarray\r\n            }\r\n\r\n            this.loadEdgeData()\r\n            if(this.props.handleCreated){\r\n                this.props.handleCreated()\r\n            }\r\n        }\r\n            //})\r\n\r\n    }\r\n\r\n\r\n\r\n    centralizeData(ViewFlag){\r\n        this.minX=Number.MAX_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.maxX=Number.MIN_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            //this.pointData[i].isGroup=true;\r\n            if(itemEnergyShape==\"circle\"){\r\n                if(this.itemShape==\"rectangle\"){\r\n                    let r=Math.sqrt(Math.pow(this.pointData[i].width,2)+Math.pow(this.pointData[i].height,2))/2\r\n                    this.pointData[i].radius=r\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].radius\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].radius\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].radius\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].radius\r\n\r\n            }\r\n            else if(itemEnergyShape==\"rectangle\"){\r\n                if(this.itemShape==\"circle\"){\r\n                    this.pointData[i].width=this.pointData[i].radius*2\r\n                    this.pointData[i].height=this.pointData[i].radius*2\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].width/2\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].width/2\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].height/2\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].height/2\r\n\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,this.pointData[i].maxX)\r\n            this.maxY=Math.max(this.maxY,this.pointData[i].maxY)\r\n            this.minX=Math.min(this.minX,this.pointData[i].minX)\r\n            this.minY=Math.min(this.minY,this.pointData[i].minY)\r\n\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                    this.catPointDict[nowcat].minX = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxX = Number.MIN_VALUE\r\n                    this.catPointDict[nowcat].minY = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxY = Number.MIN_VALUE\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,this.pointData[i].minX)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,this.pointData[i].maxX)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,this.pointData[i].minY)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,this.pointData[i].maxY)\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let catarr=this.pointData[start].catArray\r\n\r\n            let minx=Math.min(this.pointData[start].x,this.pointData[end].x)\r\n            let miny=Math.min(this.pointData[start].y,this.pointData[end].y)\r\n            let maxx=Math.max(this.pointData[start].x,this.pointData[end].x)\r\n            let maxy=Math.max(this.pointData[start].y,this.pointData[end].y)\r\n\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                for (let p=0;p<vpoints.length;p++){\r\n                    let x=vpoints[p][0]\r\n                    let y=vpoints[p][1]\r\n                    minx=Math.min(minx,x)\r\n                    miny=Math.min(miny,y)\r\n                    maxx=Math.max(maxx,x)\r\n                    maxy=Math.max(maxy,y)\r\n                }\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,maxx)\r\n            this.maxY=Math.max(this.maxY,maxy)\r\n            this.minX=Math.min(this.minX,minx)\r\n            this.minY=Math.min(this.minY,miny)\r\n\r\n            this.edges[i].x=minx\r\n            this.edges[i].y=miny\r\n            this.edges[i].width=maxx-minx\r\n            this.edges[i].height=maxy-miny\r\n\r\n            //this.edges[i].isGroup=true;\r\n\r\n            for (let c=0;c<catarr.length;c++){\r\n                // let catarr=this.pointData[this.edges[i].start].catArray\r\n                let nowcat=catarr[c]\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,minx)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,maxx)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,miny)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,maxy)\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat=this.edges[i].cat\r\n            if(!this.catEdgeDict.hasOwnProperty(cat)){\r\n                this.catEdgeDict[cat]=[]\r\n            }\r\n            this.catEdgeDict[cat].push(this.edges[i])\r\n\r\n        }\r\n        //console.log(this.catEdgeDict)\r\n\r\n        if(ViewFlag){\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n////\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n//\r\n            d3.selectAll('g').attr(\"transform\",\"\");\r\n        }\r\n\r\n\r\n        if(hasChangeView == false){\r\n            offsetX = this.minX-Math.max(nodeR1,edgeR1)-buffer-10\r\n            offsetY = this.minY-Math.max(nodeR1,edgeR1)-buffer-10\r\n            viewWidth = this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            viewHeight = this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            hasChangeView = true\r\n        }\r\n\r\n    }\r\n\r\n\r\n    drawPointData(){\r\n        // d3.select(\"svg\").selectAll(\"*\").remove();\r\n        svg = d3.select('svg');\r\n\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let items=[]\r\n\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"circle\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    \"id\":items[i].getAttribute(\"index\"),\r\n                    \"bbox\":items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"rect\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    isInEdgeRange(x,y,start,end){\r\n        let x1=start.x\r\n        let y1=start.y\r\n        let x2=end.x\r\n        let y2=end.y\r\n\r\n        let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n        // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n        if (cross <= 0) return false\r\n\r\n        let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n        if (cross >= d2) return false\r\n\r\n        return true\r\n    }\r\n\r\n    calEdgeControlPoints(){\r\n        function sortArr(a,b){\r\n            return a.avgdis-b.avgdis\r\n        }\r\n        this.edgeControlPoints=[]\r\n        let tempcontrolpoints=[]\r\n        for(let i=0;i<this.edges.length;i++){\r\n            this.edgeControlPoints.push([])\r\n            tempcontrolpoints.push([])\r\n        }\r\n        for (var k in control_points){\r\n            for (let n=0;n<control_points[k].length;n++){\r\n                let controlpoints=control_points[k][n]\r\n                for(let i=0;i<controlpoints.length;i++){\r\n                    let minDis=Number.MAX_VALUE\r\n                    let minindex=-1\r\n                    for(let e=0;e<this.edges.length;e++){\r\n                        let edge=this.edges[e]\r\n                        if(edge.cat!=k){\r\n                            continue\r\n                        }\r\n                        let start=this.pointData[edge.start]\r\n                        let end=this.pointData[edge.end]\r\n                        let dis=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n                        if(dis>0){\r\n                            if(dis<minDis){\r\n                                minDis=dis\r\n                                minindex=e\r\n                            }\r\n                        }\r\n                    }\r\n                    if(minindex>=0){\r\n                        tempcontrolpoints[minindex].push({\r\n                            order:n,\r\n                            index:i,\r\n                            dis:minDis\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        // console.log(tempcontrolpoints[153])\r\n\r\n        for(let i=0;i<tempcontrolpoints.length;i++){\r\n            let iscontinue=false\r\n            let temppoints=[]\r\n            for(let j=1;j<tempcontrolpoints[i].length;j++){\r\n                let lastindex=tempcontrolpoints[i][j-1].index\r\n                let index=tempcontrolpoints[i][j].index\r\n                if(index-lastindex==1){\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                    else{\r\n                        iscontinue=true\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                }\r\n                else{\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                        iscontinue=false\r\n\r\n                        this.edgeControlPoints[i].push(temppoints)\r\n\r\n                        temppoints=[]\r\n                    }\r\n                    else{\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(iscontinue){\r\n                temppoints.push(tempcontrolpoints[i][tempcontrolpoints[i].length-1])\r\n                this.edgeControlPoints[i].push(temppoints)\r\n            }\r\n        }\r\n        console.log(this.edgeControlPoints)\r\n\r\n        for (let i=0;i<this.edgeControlPoints.length;i++){\r\n            if(this.edgeControlPoints[i].length>2){\r\n                for (let j=0;j<this.edgeControlPoints[i].length;j++){\r\n                    let avgdis=0\r\n                    for (let p=0;p<this.edgeControlPoints[i][j].length;p++){\r\n                        avgdis+=this.edgeControlPoints[i][j][p].dis\r\n                    }\r\n                    avgdis=avgdis/this.edgeControlPoints[i][j].length\r\n                    this.edgeControlPoints[i][j].avgdis=avgdis\r\n                }\r\n                this.edgeControlPoints[i].sort(sortArr)\r\n                let tmp=[this.edgeControlPoints[i][0],this.edgeControlPoints[i][1]]\r\n                this.edgeControlPoints[i]=tmp\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    changeEdgeWidth(index,width){\r\n        let dw=width-defaultEdgeWidth\r\n        dw=dw*1.5\r\n        // console.log(width,dw)\r\n        //recalculate energy field\r\n/*        let i=index\r\n        let edges=this.edges\r\n        let k=edges[index].cat\r\n        let controlpoints=control_points[k]\r\n        let start=this.pointData[edges[index].start]\r\n        let end=this.pointData[edges[index].end]\r\n        let distances=[]\r\n        for (let i=0;i<controlpoints.length;i++){\r\n            let distoedge=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n            distances.push(distoedge)\r\n        }\r\n\r\n        let iscontinue=false\r\n        let temppoints={\r\n            points:[],\r\n            dis:0\r\n        }\r\n        let potentialPoints=[]\r\n        for(let i=0;i<distances.length;i++){\r\n            if(distances[i]>=0){\r\n                if(iscontinue){\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n                else{\r\n                    iscontinue=true\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n            }\r\n            else{\r\n                if(iscontinue){\r\n                    if(temppoints.points.length>1){\r\n                        temppoints.dis=temppoints.dis/temppoints.points.length\r\n                        potentialPoints.push(temppoints)\r\n                    }\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    iscontinue=false\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n        }\r\n        for(let i=0;i<potentialPoints.length;i++){\r\n            for(let p=0;p<potentialPoints[i].points.length;p++){\r\n                let point=controlpoints[potentialPoints[i].points[p]]\r\n                drawRect(point[0],point[1],1,1,\"red\")\r\n            }\r\n        }\r\n        console.log(potentialPoints)*/\r\n        let k=this.edges[index].cat\r\n        let start=this.pointData[this.edges[index].start]\r\n        let end=this.pointData[this.edges[index].end]\r\n        let dir=[end.x-start.x,end.y-start.y]\r\n\r\n        let norm=[-dir[1],dir[0]]\r\n        norm=normalizeVec(norm)\r\n\r\n        // drawLine([start.x,start.y],[start.x+50*norm[0],start.y+50*norm[1]],\"red\")\r\n\r\n        //console.log(\"changEdgeWidth:\")\r\n        //console.log(this.edgeControlPoints)\r\n\r\n        let controlpoints=this.edgeControlPoints[index]\r\n            let firstOutline=controlpoints[0]\r\n            let secondOutline=controlpoints[1]\r\n            let p1=control_points[k][firstOutline[0].order][firstOutline[0].index]\r\n            let vec1=[p1[0]-start.x,p1[1]-start.y]\r\n            let dot=vec1[0]*norm[0]+vec1[1]*norm[1]\r\n\r\n            let firstMidpoint=firstOutline.length/2\r\n            let secondMidpoint=secondOutline.length/2\r\n\r\n            if(dot>0){\r\n                //same direction with firstOutline\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n\r\n            }\r\n            else{\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n            }\r\n\r\n            //apply changes to energy field\r\n\r\n\r\n\r\n        let drawPathData=\"\";\r\n        for(let j = 0;j < control_points[k].length; j ++){\r\n            drawPathData += lineFunction(control_points[k][j]);\r\n        }\r\n        this.reDraw(k,this,drawPathData)\r\n\r\n\r\n    }\r\n\r\n    handleEdgeWidth(event, element){\r\n        event.stopPropagation()\r\n        let that = this\r\n        that.selectedEdge=parseInt(d3.select(element).attr(\"index\"))\r\n        that.setState({\r\n            hasSelectEdge:true\r\n        })\r\n        d3.select(\"svg\").selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(element).attr(\"index\"))==that.selectedEdge\r\n            })\r\n            .attr(\"stroke\",\"red\")\r\n            .attr(\"opacity\",1)\r\n    }\r\n\r\n    drawEdges(){\r\n        d3.select(\"#mainsvg\").selectAll(\"line\").remove()\r\n        let that=this\r\n\r\n        function handleClick(event){\r\n            event.stopPropagation()\r\n            that.selectedEdge=parseInt(d3.select(this).attr(\"index\"))\r\n            that.setState({\r\n                hasSelectEdge:true\r\n            })\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",1)\r\n        }\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                let vend\r\n                for (let v=0;v<vpoints.length;v++){\r\n                    vend=vpoints[v]\r\n                    g.append(\"line\")\r\n                        .attr(\"x1\",vstart[0])\r\n                        .attr(\"y1\",vstart[1])\r\n                        .attr(\"x2\",vend[0])\r\n                        .attr(\"y2\",vend[1])\r\n                        .attr(\"index\",index)\r\n                        .attr(\"stroke-width\",3)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"opacity\",0)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",1)\r\n                        })\r\n                        .on(\"mouseout\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",0)\r\n                        })\r\n                        .on(\"click\",handleClick)\r\n                    vstart=vend\r\n                }\r\n                vend=[this.pointData[end].x,this.pointData[end].y]\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n            else{\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",this.pointData[start].x)\r\n                    .attr(\"y1\",this.pointData[start].y)\r\n                    .attr(\"x2\",this.pointData[end].x)\r\n                    .attr(\"y2\",this.pointData[end].y)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    calEdgeLength(){\r\n        let minlength=Number.MAX_VALUE\r\n        let maxlength=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let startpoint=this.pointData[this.edges[i].start]\r\n            let endpoint=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vpoint=this.edges[i].virtrualNodes\r\n                let nowp\r\n                let nextp\r\n                let edgelength=0\r\n                nowp=[startpoint.x,startpoint.y]\r\n                for (let i=0;i<vpoint.length;i++){\r\n                    nextp=vpoint[i]\r\n                    edgelength+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                    nowp=nextp\r\n                }\r\n                edgelength+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let edgelength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        this.maxEdgeLength=maxlength\r\n        this.minEdgeLength=minlength\r\n\r\n    }\r\n\r\n    componentWillUpdate(nextProps, nextState, nextContext) {\r\n    }\r\n\r\n    findOutLine(){\r\n        for (var k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n        intervals=[0.01]\r\n        console.time(\"isoline\")\r\n\r\n        // total field to active region\r\n        let fieldData = {}\r\n        for(var k in this.catEnergyField){\r\n            fieldData[k] = []\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let i = 0\r\n            for(let y = startY; y < endY; y ++){\r\n                fieldData[k].push([])\r\n                for(let x = startX; x < endX; x ++){\r\n                    fieldData[k][i].push(this.catEnergyField[k].finalField[y][x])\r\n                }\r\n                i ++\r\n            }\r\n        }\r\n\r\n        let isoDict=this.calISOLine(intervals, fieldData)\r\n\r\n        //console.log(isoDict)\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {};\r\n\r\n\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].boundingX\r\n            let dy=this.catEnergyField[k].boundingY\r\n            let prelength = 0\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                let sk = skipPoint\r\n                if(isoDict[k][i].length < 30){\r\n                    //continue;\r\n                }\r\n                if(isoDict[k][i].length < 50){\r\n                    //sk = 1\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n\r\n                    if(prelength==0){\r\n                        tmp_polygon[k].selectidx = []\r\n                        control_points[k] = []\r\n                    }\r\n\r\n                    tmp_polygon[k].selectidx.push(tmp_polygon[k].length - 1)\r\n\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n\r\n                    let curlen = control_points[k].length\r\n                    control_points[k][curlen] = [];\r\n                    control_points[k][curlen] = polygon;\r\n\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                    prelength ++\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        console.timeEnd(\"isoline\")\r\n\r\n        console.time(\"remove isoline\")\r\n        //console.log(tmp_polygon)\r\n\r\n        for(let k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k] = []\r\n        }\r\n\r\n\r\n        //remove_Polys = {}\r\n\r\n        for(var k in isoDict){\r\n            //let dx=this.catEnergyField[k].boundingX\r\n            //let dy=this.catEnergyField[k].boundingY\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                let isthis = false\r\n                for(let j = 0;j < sidx.length; j ++){\r\n                    if(i == sidx[j]){\r\n                        isthis = true\r\n                        break\r\n                    }\r\n                }\r\n                if(isthis){\r\n                    continue\r\n                }\r\n                let flag = true;\r\n                for(let p = 0; p < sidx.length; p ++){\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx[p]]);\r\n                        if(flag == false){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n\r\n                    if(AreaCal(tmp_polygon[k][i]) < minItemArea){\r\n                        continue\r\n                    }\r\n\r\n                    let st_idx = 0\r\n                    let pt_len = tmp_polygon[k][i].length\r\n                    let j_pt = [-1,-1]\r\n                    while(st_idx < pt_len){\r\n                        let idx1 = (st_idx - 1 + pt_len) % pt_len\r\n                        let idx2 = (st_idx + 1) % pt_len\r\n                        let ve1 = [tmp_polygon[k][i][idx1][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx1][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve2 = [tmp_polygon[k][i][idx2][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx2][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve3 = [ve1[0] + ve2[0], ve1[1] + ve2[1]]\r\n                        let ve3_len = Math.sqrt(ve3[0] * ve3[0] + ve3[1] * ve3[1])\r\n                        if(ve3_len != 0){\r\n                            ve3 = [ve3[0] / ve3_len, ve3[1] / ve3_len]\r\n                        }\r\n                        let test_pt = [tmp_polygon[k][i][st_idx][0] + 2 * ve3[0], tmp_polygon[k][i][st_idx][1] + 2 * ve3[1]]\r\n                        if(IsoInsideTest(test_pt, tmp_polygon[k][i])){\r\n                            j_pt = [test_pt[0], test_pt[1]]\r\n                            break;\r\n                        }\r\n                        st_idx ++\r\n                    }\r\n\r\n                    let is_use_inner = true\r\n\r\n                    if(j_pt[0] != -1 && j_pt[1] != -1){\r\n                        //if(k==\"2\"){\r\n                        //  g.append(\"circle\")\r\n                        //      .attr(\"cx\",j_pt[0])\r\n                        //      .attr(\"cy\",j_pt[1])\r\n                        //      .attr(\"r\",3)\r\n                        //      .attr(\"fill\",\"black\")\r\n//\r\n                        //}\r\n\r\n                        let j_y = parseInt((j_pt[1] -this.catEnergyField[k].y) / pixelGroup)\r\n                        let j_x = parseInt((j_pt[0] -this.catEnergyField[k].x) / pixelGroup)\r\n                        //if(k==\"2\"){\r\n                        //    console.log(\"inner outline!\")\r\n                        //    console.log(\"(\" + j_pt[0] + \", \" + j_pt[1] + \")\")\r\n                        //    console.log(this.catEnergyField[\"2\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].edgeIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].edgeIndexMap[j_y][j_x])\r\n                        //}\r\n                        //console.log(\"inner outline!\")\r\n                        //console.log(this.catEnergyField[k].field[j_y][j_x])\r\n                        //console.log(this.catEnergyField[k].finalField[j_y][j_x])\r\n                        if(this.catEnergyField[k].finalField[j_y][j_x] > 0.01){\r\n                            is_use_inner = false\r\n                        }\r\n                    }\r\n\r\n                    if(!is_use_inner){\r\n                        continue\r\n                    }\r\n\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n                /*\r\n                else{\r\n                    recal = true\r\n                    if(!remove_Polys.hasOwnProperty(k)){\r\n                        remove_Polys[k] = []\r\n                    }\r\n                    let tmp_polygon = []\r\n                    let sub_polygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j ++){\r\n                        let realx = isoDict[k][i][j][0]*pixelGroup + dx\r\n                        let realy = isoDict[k][i][j][1]*pixelGroup + dy\r\n                        sub_polygon.push([realx, realy])\r\n                        let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                        let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n                        tmp_polygon.push([x, y])\r\n                    }\r\n                    remove_Polys[k].push(tmp_polygon)\r\n                    this.fillPolygon(sub_polygon, k, 0, true)\r\n                }\r\n\r\n                 */\r\n            }\r\n        }\r\n        console.timeEnd(\"remove isoline\")\r\n\r\n    }\r\n\r\n    calOutLine(){\r\n\r\n        //if(recal && recalNum == 0){\r\n        //    recalNum += 1\r\n        //    for(let k in remove_Polys){\r\n        //        this.recalFinalEnergeField(k)\r\n        //    }\r\n        //}\r\n//\r\n        //if(this.firstFlag){\r\n        //    this.firstFlag = false\r\n        //    this.createGapInBoundary()\r\n        //}\r\n\r\n\r\n        //this.findOutLine()\r\n\r\n        let path_Info = {}\r\n\r\n        for(var k in this.catEnergyField){\r\n            path_Info[k] = []\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                path_Info[k].push(lineFunction(control_points[k][i]))\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        console.log(\"path_info!!!\")\r\n        console.log(JSON.stringify(path_Info))\r\n\r\n        for (var k in control_points){\r\n            initialControlPoints[k]=[]\r\n            for (let i=0;i<control_points[k].length;i++){\r\n                initialControlPoints[k][i]=[]\r\n                for (let j=0;j<control_points[k][i].length;j++){\r\n                    initialControlPoints[k][i].push([])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][0])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][1])\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    loadEdgeData(){\r\n        //let that=this\r\n        //fetch('/data/'+edgeDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n                //this.edges=data\r\n                console.time(\"Total Time\")\r\n\r\n                this.centralizeData(true)\r\n\r\n\r\n                // this.drawEdges()\r\n                this.calEdgeLength()\r\n                this.calActiveRegion(true)\r\n\r\n                console.time(\"cal energe\")\r\n                this.calEnergyField()\r\n                console.timeEnd(\"cal energe\")\r\n\r\n                console.time(\"cal final energe\")\r\n                //this.calFinalEnergeFieldV2()\r\n                this.calFinalEnergeField()\r\n                console.timeEnd(\"cal final energe\")\r\n\r\n                console.time(\"fill cross edge\")\r\n                this.fillCrossingEdge()\r\n                console.timeEnd(\"fill cross edge\")\r\n\r\n\r\n                console.time(\"create gap\")\r\n                this.createGapInBoundary()\r\n                console.timeEnd(\"create gap\")\r\n\r\n                //console.time(\"smooth\")\r\n                // this.smoothEnergyField()\r\n                //console.timeEnd(\"smooth\")\r\n\r\n                // for(let k in this.catPointDict){\r\n                //    this.drawEnergyField(k);\r\n                // }\r\n\r\n\r\n\r\n                d3.select(\"svg\").selectAll(\"*\").remove()\r\n                g = d3.select('svg').append(\"g\")\r\n\r\n                //g.append(\"image\")\r\n                //    .attr(\"x\",-42)\r\n                //    .attr(\"y\",-42)\r\n                //    .attr(\"width\",995)\r\n                //    .attr(\"height\",1350)\r\n                //    .attr(\"xlink:href\",\"/data/background/Manhatton.jpg\")\r\n\r\n                recal = false\r\n                recalNum = 0\r\n\r\n                this.findOutLine()\r\n                this.calOutLine()\r\n\r\n                /*\r\n\r\n                // re-cal the energy field for inner outline\r\n                for (var k in this.catEnergyField){\r\n                    this.catEnergyField[k].tfinalField = []\r\n                    for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                        this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                        for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                            let val = this.catEnergyField[k].finalField[y][x];\r\n                            if(IsoInsideTest([x, y], polygontest[k])){\r\n                                //console.log(\"test!!\")\r\n                                if(val > 0){\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                                }\r\n                                else{\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                                }\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].finalField[y][x] = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                let isoLineDict={}\r\n                for (var k in this.catEnergyField){\r\n                    var isoLines = [];\r\n                    isoLines=MarchingSquaresJS\r\n                        .isoLines(this.catEnergyField[k].tfinalField,\r\n                            intervals,\r\n                            {\r\n                                polygons: false,\r\n                                linearRing: false,\r\n                                noFrame:true\r\n                            }\r\n                        )\r\n                    isoLineDict[k]=isoLines[0]\r\n                }\r\n\r\n                for (var k in isoLineDict){\r\n                    //console.log(isoLineDict[k])\r\n                    let dx=this.catEnergyField[k].x\r\n                    let dy=this.catEnergyField[k].y\r\n                    for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                        if(isoLineDict[k][i].length < 30){\r\n                            continue;\r\n                        }\r\n                        let curlen = control_points[k].length;\r\n                        control_points[k][curlen] = [];\r\n                        for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                            control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                        }\r\n                        let meandis = 0;\r\n                        let sz = control_points[k][curlen].length;\r\n                        for(let j = 0; j < sz; j ++){\r\n                            meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                                control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                        }\r\n                        meandis /= sz\r\n                        control_points[k][curlen].meandis = meandis;\r\n                    }\r\n                    //this.drawEnergyField(k);\r\n                }\r\n\r\n                 */\r\n\r\n                //this.drawEnergyField(\"2\")\r\n                //this.drawEnergyField(\"3\")\r\n\r\n                this.calEdgeControlPoints()\r\n\r\n\r\n\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n\r\n                //for(let k in this.catEnergyField){\r\n                //    this.drawEnergyField(k)\r\n                //}\r\n\r\n                console.timeEnd(\"Total Time\")\r\n\r\n                let that=this\r\n                function handleSvgClick(){\r\n                    console.log(\"click svg!\")\r\n                    d3.select(\"svg\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"opacity\",0)\r\n                    that.selectedEdge=-1\r\n                    that.setState({\r\n                        hasSelectEdge:false,\r\n                        edgeWidth:defaultEdgeWidth\r\n                    })\r\n                }\r\n                        d3.select(\"svg\")\r\n                            .on(\"click\",handleSvgClick)\r\n\r\n            //})\r\n    }\r\n\r\n    afterEditReDraw(){\r\n\r\n        this.pointData = this.props.pointData\r\n\r\n        this.edges = this.props.edges\r\n\r\n        this.drawEdges()\r\n\r\n        this.drawPointData()\r\n\r\n        let that=this\r\n\r\n        function handleSvgClick(){\r\n            console.log(\"click svg!\")\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    calActiveRegion(flag){\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(flag || !this.catEnergyField.hasOwnProperty(k)){\r\n                this.catEnergyField[k]={}\r\n                //console.log(\"calActiveRegion:\")\r\n                //console.log(k)\r\n            }\r\n\r\n            let maxx=this.catPointDict[k].maxX\r\n            let minx=this.catPointDict[k].minX\r\n            let maxy=this.catPointDict[k].maxY\r\n            let miny=this.catPointDict[k].minY\r\n\r\n            //console.log(\"active region: \")\r\n            //console.log([maxx, minx, maxy, miny])\r\n\r\n            this.catEnergyField[k].boundingX=minx-Math.max(nodeR1,edgeR1)-buffer\r\n            this.catEnergyField[k].boundingY=miny-Math.max(nodeR1,edgeR1)-buffer\r\n\r\n            this.catEnergyField[k].boundingWidth=Math.ceil((maxx-minx+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n            this.catEnergyField[k].boundingHeight=Math.ceil((maxy-miny+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n\r\n            if(flag || !this.catEnergyField[k].hasOwnProperty(\"field\")){\r\n\r\n                let centerX = this.catEnergyField[k].boundingX + 0.5 * this.catEnergyField[k].boundingWidth\r\n                let centerY = this.catEnergyField[k].boundingY + 0.5 * this.catEnergyField[k].boundingHeight\r\n\r\n                this.catEnergyField[k].x = parseInt((centerX - 0.5 * svgwidth))\r\n                this.catEnergyField[k].y = parseInt((centerY - 0.5 * svgheight))\r\n\r\n                this.catEnergyField[k].width = parseInt(svgwidth / pixelGroup)\r\n                this.catEnergyField[k].height = parseInt(svgheight / pixelGroup)\r\n\r\n                this.catEnergyField[k].field=[]\r\n                this.catEnergyField[k].barrierMap=[]\r\n                for (let i=0;i<svgheight;i++){\r\n                    this.catEnergyField[k].field.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].barrierMap.push(new Array(svgwidth).fill(0))\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.hasBubbles = true\r\n\r\n    }\r\n\r\n    calDistanceToItem(x,y,item){\r\n        //TODO: Rectangle items\r\n        //inside is 0\r\n        if(itemEnergyShape==\"circle\"){\r\n            let dis=calDistance(x,y,item.x,item.y)\r\n            if(dis<item.radius){\r\n                return 0\r\n            }\r\n            else{\r\n                return dis-item.radius\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    getPointEdgeDistance(lx1, ly1, lx2, ly2, x, y) {\r\n        var x1 = lx1;\r\n        var y1 = ly1;\r\n        var x2 = lx2 - x1;\r\n        var y2 = ly2 - y1;\r\n        var px = x - x1;\r\n        var py = y - y1;\r\n        var dotprod = px * x2 + py * y2;\r\n        var projlenSq;\r\n        if(dotprod <= 0) {\r\n            projlenSq = 0;\r\n        } else {\r\n            px = x2 - px;\r\n            py = y2 - py;\r\n            dotprod = px * x2 + py * y2;\r\n            if(dotprod <= 0) {\r\n                projlenSq = 0;\r\n            } else {\r\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\r\n            }\r\n        }\r\n        var lenSq = px * px + py * py - projlenSq;\r\n        if(lenSq < 0) {\r\n            lenSq = 0;\r\n        }\r\n        return Math.sqrt(lenSq);\r\n    }\r\n\r\n    calDistanceToEdgeV2(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint, endpoint\r\n        if(edge.flag == false){\r\n            startpoint = edge.startpoint\r\n            endpoint = edge.endpoint\r\n        }\r\n        else{\r\n            startpoint=this.pointData[edge.start]\r\n            endpoint=this.pointData[edge.end]\r\n        }\r\n        if(edge.virtrual && edge.virtrualNodes.length > 0){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1*ep[1]]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calDistanceToEdge(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint=this.pointData[edge.start]\r\n        let endpoint=this.pointData[edge.end]\r\n        if(edge.virtrual){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1*ep[1]]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    isRectIntersects (rect1,rect2) {\r\n        if(rect1.width <= 0 || rect1.height <= 0 || rect2.width <= 0 || rect2.height <= 0) return false;\r\n        return (rect2.maxX > rect1.minX &&\r\n            rect2.maxY > rect1.minY &&\r\n            rect2.minX < rect1.maxX &&\r\n            rect2.minY < rect1.maxY);\r\n    };\r\n\r\n    isThisCat(point,cat){\r\n        let catarr=point.catArray\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    LabelGroupElement(){\r\n        let maxpdis = nodeR1 * 2\r\n        for(let k1 in this.catPointDict){\r\n\r\n            // cal for points\r\n            for(let i = 0;i < this.catPointDict[k1].length; i ++){\r\n                if(this.catPointDict[k1][i].isGroup==false){\r\n                    continue;\r\n                }\r\n                let isgroup = true;\r\n                let x1 = this.catPointDict[k1][i].x;\r\n                let y1 = this.catPointDict[k1][i].y;\r\n                for(let k2 in this.catPointDict){\r\n//\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n//\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(calDistance(x1,y1,x2,y2) < maxpdis + this.catPointDict[k2][j].radius + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n//\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    // cal edge\r\n                    if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                        continue;\r\n                    }\r\n                    for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                        if(this.calDistanceToEdge(x1,y1,this.catEdgeDict[k2][j])[0] < maxpdis + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catEdgeDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n                }\r\n                this.catPointDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n            // cal for edges\r\n            if(!this.catEdgeDict.hasOwnProperty(k1)){\r\n                continue;\r\n            }\r\n            for(let i = 0;i < this.catEdgeDict[k1].length;i ++){\r\n                let s1 = this.pointData[this.catEdgeDict[k1][i].start];\r\n                let e1 = this.pointData[this.catEdgeDict[k1][i].end];\r\n                if(this.catEdgeDict[k1][i].isGroup == false){\r\n                    continue;\r\n                }\r\n                let isgroup = true\r\n                for(let k2 in this.catPointDict){\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(this.calDistanceToEdge(x2,y2,this.catEdgeDict[k1][i])[0] < maxpdis + this.catPointDict[k2][j].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    //// cal edge\r\n                    //if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                    //    continue;\r\n                    //}\r\n                    //for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                    //    let s2 = this.pointData[this.catEdgeDict[k2][j].start];\r\n                    //    let e2 = this.pointData[this.catEdgeDict[k2][j].end];\r\n                    //    if(this.checkEdgeCrossing(s1,e1,s2,e2)[0]){\r\n                    //        isgroup = false;\r\n                    //        this.catEdgeDict[k2][j].isGroup = false;\r\n                    //        break;\r\n                    //    }\r\n                    //}\r\n                    //if(isgroup==false){\r\n                    //    break;\r\n                    //}\r\n//\r\n                }\r\n                this.catEdgeDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField_Part(updatePoints, updateEdges){\r\n\r\n        //console.log(\"calEnergyField_Part:\")\r\n        //console.log(updateEdges)\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(!this.catEnergyField[k].hasOwnProperty(\"finalField\")){\r\n                // group attrs\r\n                this.catPointDict[k].pointMap=[]\r\n                this.catEnergyField[k].pointBarrierMap=[]\r\n                this.catEnergyField[k].edgeBarrierMap=[]\r\n                this.catEnergyField[k].pointIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap2=[]\r\n                this.catEnergyField[k].finalField = []\r\n                this.catEnergyField[k].subUpdate = []\r\n\r\n                for (let y=0;y<svgheight;y++){\r\n                    this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                    this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n\r\n                    this.catEnergyField[k].edgeIndexMap2.push([])\r\n                    for(let x=0;x<svgwidth;x++){\r\n                        this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n\r\n            if(!updatePoints.hasOwnProperty(k)){\r\n                updatePoints[k] = []\r\n            }\r\n\r\n            if(!updateEdges.hasOwnProperty(k)){\r\n                updateEdges[k] = []\r\n            }\r\n\r\n            let members = updatePoints[k]\r\n\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                //this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n\r\n                            if(members[i].flag == false){\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.01 || this.catEnergyField[k].edgeIndexMap[y][x] == -1){\r\n                                    this.catEnergyField[k].field[y][x] = 0\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=-1\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                            }\r\n                            else{\r\n\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                        if(members[i].flag == true){\r\n\r\n                            if(distance<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=1\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                                }\r\n                            }\r\n\r\n                            if(distance<=fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=3\r\n                                //this.catPointDict[k].pointMap[i].push([x,y])\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n            console.log(this.maxEdgeLength)\r\n            // cal positive value of edges\r\n            let edges=updateEdges[k]\r\n            edges.sort(function(a,b){\r\n                return a.flag - b.flag\r\n            })\r\n            //console.log(\"Sort Edegs:\")\r\n            //console.log(edges)\r\n            for (let i=0;i<edges.length;i++){\r\n                // cal positive value for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                let startid=edges[i].start\r\n                let endid=edges[i].end\r\n                startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToEdgeV2(realx,realy,edges[i])\r\n                        let distancetoEdge=distance[0]\r\n                        let distancetoNode=distance[1]\r\n                        let totalDistance=distance[2]\r\n\r\n                        if(distancetoNode<0){\r\n                            continue\r\n                        }\r\n\r\n                        if(distancetoEdge<edgeR1+fixdis){\r\n                            let newR1=edgeR1\r\n                            let reducefactor=edgeR1/10\r\n                            let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                            if(totalDistance>EDGELENGTH_THRESH){\r\n                                newR1=2*edgeR1/(1+factor*distancetoNode)\r\n                            }\r\n                            if(newR1>edgeR1){\r\n                                newR1=edgeR1\r\n                            }\r\n\r\n                            if(newR1>2*nodeR1){\r\n                                newR1=2*nodeR1\r\n                            }\r\n                            let energy\r\n                            if(distancetoEdge>newR1){\r\n                                energy=0\r\n                            }\r\n                            else{\r\n                                energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                            }\r\n\r\n\r\n                            if(edges[i].flag == true){\r\n                                let preenergy = this.catEnergyField[k].finalField[y][x]\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                let delflag = false\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x] == -1 && this.catEnergyField[k].edgeIndexMap2[y][x].length == 1){\r\n                                    if(this.catEnergyField[k].edgeIndexMap2[y][x][0].start == startid && this.catEnergyField[k].edgeIndexMap2[y][x][0].end == endid){\r\n                                        delflag = true\r\n                                    }\r\n                                }\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.01 || delflag){\r\n                                    this.catEnergyField[k].field[y][x]=0\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                    for(let it = this.catEnergyField[k].edgeIndexMap2[y][x].length - 1; it >= 0 ; it --){\r\n                                        let s = this.catEnergyField[k].edgeIndexMap2[y][x][it].start\r\n                                        let e = this.catEnergyField[k].edgeIndexMap2[y][x][it].end\r\n                                        if(s==startid&&e==endid){\r\n                                            this.catEnergyField[k].edgeIndexMap2[y][x].splice(it,1)\r\n                                        }\r\n                                    }\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                                //if(this.catEnergyField[k].pointIndexMap[y][x] != -1){\r\n                                //    this.catEnergyField[k].barrierMap[y][x]=this.catEnergyField[k].pointBarrierMap[y][x]\r\n                                //    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                //    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                //}\r\n                            }\r\n\r\n                        }\r\n\r\n                        /*\r\n                        let startpoint=this.pointData[startid]\r\n                        let endpoint=this.pointData[endid]\r\n\r\n                        if(startpoint.multicat&&endpoint.multicat){\r\n                            let hasSameCat=false\r\n                            let samecat=-1\r\n                            for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                let cat1=startpoint.catArray[c1]\r\n                                if(cat1!=k){\r\n                                    for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                        let cat2=endpoint.catArray[c2]\r\n                                        if(cat2!=k){\r\n                                            if(cat2==cat1){\r\n                                                hasSameCat=true\r\n                                                samecat=cat1\r\n                                                break\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                            if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                if(distancetoEdge<edgeR1+20+fixdis){\r\n                                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                    let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                    let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                    let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                    // let energyscale=100\r\n\r\n                                    if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                        this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                        this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        */\r\n\r\n                        if(edges[i].flag == true){\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField(){\r\n\r\n        //TODO: edge and node use different barrier map\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            // group attrs\r\n            this.catPointDict[k].pointMap=[]\r\n            this.catEnergyField[k].pointBarrierMap=[]\r\n            this.catEnergyField[k].edgeBarrierMap=[]\r\n            this.catEnergyField[k].pointIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap2=[]\r\n            this.catEnergyField[k].finalField = []\r\n            this.catEnergyField[k].subUpdate = []\r\n\r\n            for (let y=0;y<svgheight;y++){\r\n                this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap2.push([])\r\n                for(let x=0;x<svgwidth;x++){\r\n                    this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                }\r\n            }\r\n\r\n            //// not group attrs\r\n            //this.catPointDict[k].gpointMap=[]\r\n            //this.catEnergyField[k].gpointBarrierMap=[]\r\n            //this.catEnergyField[k].gedgeBarrierMap=[]\r\n            //this.catEnergyField[k].gpointIndexMap=[]\r\n            //this.catEnergyField[k].gedgeIndexMap=[]\r\n//\r\n            //for(let y=0;y<this.catEnergyField[k].gheight;y++){\r\n            //    this.catEnergyField[k].gpointBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gedgeBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gpointIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //    this.catEnergyField[k].gedgeIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //}\r\n\r\n\r\n        }\r\n\r\n        // cal bbox of edges\r\n        // fix to cal at this.centralizeData()\r\n\r\n        // cal the real active region\r\n        //this.LabelGroupElement()\r\n\r\n        for(var k in this.catPointDict){\r\n            let members=this.catPointDict[k]\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                            this.catEnergyField[k].field[y][x]+=energy\r\n                            if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                this.catEnergyField[k].barrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n                        }\r\n                        if(point.multicat){\r\n                            let catarr=point.catArray\r\n                            for (let c=0;c<catarr.length;c++){\r\n                                if(catarr[c]!=k&&parseInt(catarr[c])<parseInt(k)){\r\n                                    if(distance<nodeR1+10){\r\n                                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[catarr[c]].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[catarr[c]].y)/pixelGroup)\r\n                                        let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[catarr[c]].width&&relativey<this.catEnergyField[catarr[c]].height){\r\n                                            // this.catEnergyField[catarr[c]].field[relativey][relativex]+=energy\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if(distance<=barrierGap+fixdis){\r\n                            if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].barrierMap[y][x]=1\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                            }\r\n                        }\r\n\r\n                        if(distance<=fixdis){\r\n                            //inside\r\n                            this.catEnergyField[k].barrierMap[y][x]=3\r\n                            this.catPointDict[k].pointMap[i].push([x,y])\r\n                            this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                            this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            // let EDGELENGTH_THRESH=(this.maxEdgeLength+this.minEdgeLength)/3\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/2\r\n            // let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n\r\n            // cal positive value of edges\r\n            if(this.catEdgeDict.hasOwnProperty(k)){\r\n                let edges=this.catEdgeDict[k]\r\n                for (let i=0;i<edges.length;i++){\r\n                    // cal positive value for pixel group\r\n                    let startx\r\n                    let endx\r\n                    let starty\r\n                    let endy\r\n                    let startid=edges[i].start\r\n                    let endid=edges[i].end\r\n                    startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                    endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                    starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                    endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                    for (let y=starty;y<endy;y++){\r\n                        for (let x=startx;x<endx;x++){\r\n                            let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                            let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                            let distance=this.calDistanceToEdge(realx,realy,edges[i])\r\n                            let distancetoEdge=distance[0]\r\n                            let distancetoNode=distance[1]\r\n                            let totalDistance=distance[2]\r\n\r\n                            if(distancetoNode<0){\r\n                                continue\r\n                            }\r\n\r\n                            if(distancetoEdge<edgeR1+fixdis){\r\n                                let newR1=edgeR1\r\n                                // let factor=(edgeR1-2)/this.maxEdgeLength\r\n                                let reducefactor=edgeR1/10\r\n                                let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                                if(totalDistance>EDGELENGTH_THRESH){\r\n                                    newR1=2*edgeR1/(1+factor*distancetoNode)\r\n\r\n\r\n                                    // newR1=2*edgeR1/(1+factor*distancetoNode/4)\r\n\r\n                                    // weight=1-Math.pow(factor,2)\r\n                                    // let factor=2*(Math.exp(2)-1)/this.maxEdgeLength\r\n                                    // weight=1/(Math.log(1+factor*distancetoNode)+2)\r\n\r\n                                    // weight=weight*2\r\n                                }\r\n                                if(newR1>edgeR1){\r\n                                    newR1=edgeR1\r\n                                }\r\n\r\n                                if(newR1>2*nodeR1){\r\n                                    newR1=2*nodeR1\r\n                                }\r\n                                let energy\r\n                                if(distancetoEdge>newR1){\r\n                                    energy=0\r\n                                }\r\n                                else{\r\n                                    energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                }\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n\r\n                            }\r\n\r\n                            let startpoint=this.pointData[startid]\r\n                            let endpoint=this.pointData[endid]\r\n\r\n                            if(startpoint.multicat&&endpoint.multicat){\r\n                                let hasSameCat=false\r\n                                let samecat=-1\r\n                                for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                    let cat1=startpoint.catArray[c1]\r\n                                    if(cat1!=k){\r\n                                        for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                            let cat2=endpoint.catArray[c2]\r\n                                            if(cat2!=k){\r\n                                                if(cat2==cat1){\r\n                                                    hasSameCat=true\r\n                                                    samecat=cat1\r\n                                                    break\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                                if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                    if(distancetoEdge<edgeR1+20+fixdis){\r\n                                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                        let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                        // let energyscale=100\r\n\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                            this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                            this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                            this.catEnergyField[samecat].edgeIndexMap2[relativey][relativex].push({start:startpoint.id, end:endpoint.id})\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    checkEdgeCrossing(a, b, c, d){\r\n\r\n        // abc 2\r\n        var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\r\n\r\n        // abd 2\r\n        var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);\r\n\r\n        // , (,);\r\n        if ( area_abc*area_abd>=0 ) {\r\n            return [false];\r\n        }\r\n\r\n        // cda 2\r\n        var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);\r\n        // cdb 2\r\n        // : .,.\r\n        var area_cdb = area_cda + area_abc - area_abd ;\r\n        if (  area_cda * area_cdb >= 0 ) {\r\n            return [false];\r\n        }\r\n\r\n        //\r\n        var t = area_cda / ( area_abd- area_abc );\r\n        var dx= t*(b.x - a.x),\r\n            dy= t*(b.y - a.y);\r\n        return[true, { x: a.x + dx , y: a.y + dy }];\r\n\r\n    }\r\n\r\n    createGapInBoundary(){\r\n        let gap=this.state.gapBetween\r\n        if(gap==0)\r\n            return\r\n        for (var k in this.catEnergyField){\r\n            let field=this.catEnergyField[k].finalField\r\n            let deletePoints=[]\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    if(field[y][x]==0){\r\n                        continue\r\n                    }\r\n\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4)\r\n                        continue\r\n\r\n                    //check if it is the boundary\r\n                    let isboundary=false\r\n                    for (let i=0;i<gap;i++){\r\n                        let delta=i+1\r\n                        //right\r\n                        if(x+delta<this.catEnergyField[k].width){\r\n                            if(field[y][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left\r\n                        if(x-delta>0){\r\n                            if(field[y][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //up\r\n                        if(y-delta>0){\r\n                            if(field[y-delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //down\r\n                        if(y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-top\r\n                        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n                            if(field[y-delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-bottom\r\n                        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-top\r\n                        if(x-delta>0&&y-delta>0){\r\n                            if(field[y-delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-bottom\r\n                        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(isboundary){\r\n                        // this.catEnergyField[k].finalField[y][x]=0\r\n                        deletePoints.push([x,y])\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for (let i=0;i<deletePoints.length;i++){\r\n                let x=deletePoints[i][0]\r\n                let y=deletePoints[i][1]\r\n                this.catEnergyField[k].finalField[y][x]=0\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    removeEmptyZone(isoDict){\r\n\r\n        // for (var k in this.catEnergyField){\r\n        //     for (let y=0;y<this.catEnergyField[k].height;y++){\r\n        //         for (let x=0;x<this.catEnergyField[k].width;x++){\r\n        //             if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==4){\r\n        //                 this.catEnergyField[k].finalField[y][x]=0\r\n        //             }\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        for (var k in isoDict){\r\n            let isolines=isoDict[k]\r\n            let isolinepoints=[]\r\n            let finalField=this.catEnergyField[k].finalField\r\n            this.catEnergyField[k].isoLineMap=[]\r\n\r\n            for (let i=0;i<isolines.length;i++){\r\n                let relativepoints=[]\r\n                for (let p=0;p<isolines[i].length;p++){\r\n                    relativepoints.push({x:isolines[i][p][0], y:isolines[i][p][1]})\r\n                }\r\n                isolinepoints.push(relativepoints)\r\n            }\r\n\r\n            let isoInsidePoints=[]\r\n            for (let i=0;i<isolinepoints.length;i++){\r\n                isoInsidePoints.push([])\r\n            }\r\n\r\n            for (let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].isoLineMap.push([])\r\n                for (let x=0;x<this.catEnergyField[k].width;x++){\r\n                    this.catEnergyField[k].isoLineMap[y].push(-1)\r\n\r\n                    if(finalField[y][x]>0){\r\n                        for (let i=0;i<isolinepoints.length;i++){\r\n                            //check if it is inside the isoline\r\n                            let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},isolinepoints[i])\r\n                            if(intersect){\r\n                                isoInsidePoints[i].push([x,y])\r\n                                this.catEnergyField[k].isoLineMap[y][x]=i\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            let notDeleteIndex=[]\r\n            for (let i=0;i<this.catPointDict[k].pointMap.length;i++){\r\n                let nodePoints=this.catPointDict[k].pointMap[i]\r\n                let totalInside=true\r\n                let isolineIndex=-1\r\n\r\n                // if(k==\"5\"&&i==0){\r\n                //     console.log()\r\n                // }\r\n\r\n                for (let n=0;n<nodePoints.length;n++){\r\n                    let x=nodePoints[n][0]\r\n                    let y=nodePoints[n][1]\r\n                    if(n==0){\r\n                        if(this.catEnergyField[k].isoLineMap[y][x]>-1){\r\n                            isolineIndex=this.catEnergyField[k].isoLineMap[y][x]\r\n                        }\r\n                    }\r\n                    if(this.catEnergyField[k].isoLineMap[y][x]==-1||this.catEnergyField[k].isoLineMap[y][x]!=isolineIndex){\r\n                        totalInside=false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(totalInside){\r\n                    notDeleteIndex.push(isolineIndex)\r\n                }\r\n\r\n            }\r\n\r\n            let deleteindex=[]\r\n\r\n            for(let i=0;i<isoInsidePoints.length;i++){\r\n                let isdelete=true\r\n                for (let j=0;j<notDeleteIndex.length;j++){\r\n                    if(i==notDeleteIndex[j]){\r\n                        isdelete=false\r\n                        break\r\n                    }\r\n                }\r\n                if(isdelete){\r\n                    deleteindex.push(i)\r\n                }\r\n            }\r\n\r\n\r\n            for (let i=0;i<deleteindex.length;i++){\r\n                let index=deleteindex[i]\r\n                let deletePoints=isoInsidePoints[index]\r\n\r\n                for(let p=0;p<deletePoints.length;p++){\r\n                    let x=deletePoints[p][0]\r\n                    let y=deletePoints[p][1]\r\n                    this.catEnergyField[k].finalField[y][x]=0\r\n                }\r\n            }\r\n\r\n            let newisolines=[]\r\n            for (let i=0;i<isolines.length;i++){\r\n                let isdelete=false\r\n                for (let j=0;j<deleteindex.length;j++){\r\n                    if(i==deleteindex[j]){\r\n                        isdelete=true\r\n                        break\r\n                    }\r\n\r\n                }\r\n                if(!isdelete){\r\n                    newisolines.push(isolines[i])\r\n                }\r\n\r\n            }\r\n\r\n            isoDict[k]=newisolines\r\n        }\r\n        console.log(isoDict)\r\n        return isoDict\r\n    }\r\n\r\n    isSameCat(catarr1,catarr2){\r\n        for(let i=0;i<catarr1.length;i++){\r\n            let cat1=catarr1[i]\r\n            for (let j=0;j<catarr2.length;j++){\r\n                let cat2=catarr2[j]\r\n                if(cat1==cat2){\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isContained(catarr,cat){\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calFinalEnergeFieldForOverlap(){\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = this.catEnergyField[k].field\r\n            for(let y in this.catNotGroup[k]){\r\n                //this.catEnergyField[k].finalField.push(new Array(this.catEnergyField[k].width).fill(0))\r\n                for(let x in this.catNotGroup[k][y]){\r\n                    y = parseInt(y);\r\n                    x = parseInt(x);\r\n                    let px = Math.ceil(x/pixelGroup)\r\n                    let py = Math.ceil(y/pixelGroup)\r\n                    let realx=x+this.catEnergyField[k].x\r\n                    let realy=y+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].gfield[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].gpointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].gedgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].gbarrierMap[y][x]==3||this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].gfield[y][x]==0){\r\n                        // drawRect(realx,realy,1,1,\"red\")\r\n                        value=1\r\n                        this.catEnergyField[k].gfield[y][x]=1\r\n                        this.catEnergyField[k].field[py][px]=1\r\n                    }\r\n\r\n\r\n                    /*                    if (!isInside&&value==0){\r\n                                            continue\r\n                                        }*/\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].x+this.catEnergyField[k2].gwidth&&realx>this.catEnergyField[k2].x&&realy<this.catEnergyField[k2].y+this.catEnergyField[k2].gheight&&realy>this.catEnergyField[k2].y){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x))\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y))\r\n\r\n                                let othervalue=this.catEnergyField[k2].gfield[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].gpointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].gedgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].gpointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].gbarrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].gbarrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[py][px]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[py][px]==4){\r\n                        this.catEnergyField[k].finalField[py][px]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateEnergyPoints(){\r\n        //update final energyfield according to this.updatedEnergyPoints\r\n        for (var k in this.updatedEnergyPoints){\r\n            for (let p=0;p<this.updatedEnergyPoints[k].length;p++){\r\n                let x=this.updatedEnergyPoints[k][p][0]\r\n                let y=this.updatedEnergyPoints[k][p][1]\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=this.catEnergyField[k].field[y][x]\r\n                // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                let finalvalue=value\r\n                let isInside=false\r\n\r\n                if(value == 0){\r\n                    continue;\r\n                }\r\n\r\n               if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    isInside=true\r\n                }\r\n\r\n                if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                    value=1\r\n                    this.catEnergyField[k].field[y][x]=1\r\n                }\r\n\r\n                if (value==0){\r\n                    // drawRect(realx,realy,1,1,\"black\")\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField){\r\n                    if(k2==k)\r\n                        continue\r\n\r\n                    if(k2!=k){\r\n                        if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                            let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                            let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                            let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                            let otherinside=false\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ){\r\n\r\n                                if(this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==1|| this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==3){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                otherinside=true\r\n                            }\r\n\r\n\r\n                            if (othervalue==0){\r\n                                // drawRect(realx,realy,1,1,\"black\")\r\n                                continue\r\n                            }\r\n\r\n                            // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                            // drawRect(realx,realy,1,1,\"blue\")\r\n                            if(!isInside&&!otherinside){\r\n\r\n                                if(othervalue>value){\r\n                                    finalvalue=0\r\n                                    // drawRect(realx,realy,2,2,\"red\")\r\n                                    // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                    break\r\n                                }\r\n                                else{\r\n                                    finalvalue=value\r\n                                }\r\n                                // finalvalue=0\r\n                                // finalvalue=value\r\n\r\n                            }\r\n                            else if(isInside&&!otherinside){\r\n                                // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                //pass\r\n\r\n                                finalvalue=value\r\n                            }\r\n                            else if(!isInside&&otherinside){\r\n                                // drawRect(realx,realy,2,2,\"black\")\r\n                                // drawRect(realx,realy,1,1,\"orange\")\r\n                                finalvalue=0\r\n                                break\r\n                            }\r\n                            else if(isInside&&otherinside){\r\n\r\n                                // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else{\r\n                                    finalvalue=0\r\n                                }\r\n                                // finalvalue=0\r\n\r\n\r\n                            }\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                            //     finalvalue=0\r\n                            // }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                //if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                //    this.catEnergyField[k].finalField[y][x]=10000\r\n                //}\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calFinalEnergeField_Part(){\r\n\r\n        this.updateIdx = new Set(this.updateIdx)\r\n        //console.log(\"calFinalEnergeField_Part:\")\r\n        //console.log(this.updateIdx)\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = clone(this.catEnergyField[k].field)\r\n            for(let updateidx of this.updateIdx){\r\n\r\n\r\n                    let realx=parseInt(updateidx[1])\r\n                    let realy=parseInt(updateidx[0])\r\n\r\n\r\n                    //console.log(\"(\" + realx + \", \" + realy + \")\")\r\n\r\n                    let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                    let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n\r\n                    x = Math.min(x, this.catEnergyField[k].width - 1)\r\n                    y = Math.min(y, this.catEnergyField[k].height - 1)\r\n                    x = Math.max(x, 0)\r\n                    y = Math.max(y, 0)\r\n\r\n                    //d3.select('g').append('circle')\r\n                    //    .attr('id','final')\r\n                    //    .attr('cx',realx)\r\n                    //    .attr('cy',realy)\r\n                    //    .attr('r',1)\r\n                    //    .attr('fill','red')\r\n\r\n                    //console.log(\"(\" + this.catEnergyField[k].width + \", \" + this.catEnergyField[k].height + \")\")\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    //if(value == 0){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside && this.catEnergyField[k].field[y][x] <= 0.01 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        value=1\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n    calFinalEnergeField(){\r\n\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n        for (var k in this.catEnergyField){\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        value=1\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<=this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>=this.catEnergyField[k2].boundingX&&realy<=this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>=this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n                                }\r\n\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    recalFinalEnergeField(preK){\r\n\r\n        let bounding = {}\r\n        for(let k in this.catEnergyField){\r\n            bounding[k] = {\r\n                minX : Number.MAX_VALUE,\r\n                minY : Number.MAX_VALUE,\r\n                maxX : Number.MIN_VALUE,\r\n                maxY : Number.MIN_VALUE\r\n            }\r\n        }\r\n\r\n        for (var k in this.catEnergyField){\r\n            if(k == preK){\r\n                continue\r\n            }\r\n            for(let p=0;p<this.updatedEnergyPoints[preK].length;p++) {\r\n\r\n                let realx = this.updatedEnergyPoints[preK][p][0] * pixelGroup + this.catEnergyField[preK].x\r\n                let realy = this.updatedEnergyPoints[preK][p][1] * pixelGroup + this.catEnergyField[preK].y\r\n\r\n                let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup);\r\n                let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup);\r\n\r\n\r\n                bounding[k].minX = Math.min(bounding[k].minX, x)\r\n                bounding[k].minY = Math.min(bounding[k].minY, y)\r\n                bounding[k].maxX = Math.max(bounding[k].maxX, x)\r\n                bounding[k].maxY = Math.max(bounding[k].maxY, y)\r\n\r\n                let value = this.catEnergyField[k].field[y][x]\r\n                let finalvalue = value\r\n                let isInside = false\r\n\r\n                let thisPointID = this.catEnergyField[k].pointIndexMap[y][x]\r\n                let thisEdgeID = this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                let thiscat\r\n\r\n                if (thisEdgeID == -1 && thisPointID == -1) {\r\n                    continue\r\n                }\r\n\r\n                if (thisEdgeID > -1) {\r\n                    if (this.pointData[thisEdgeID].multicat) {\r\n                        thiscat = this.pointData[thisEdgeID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisEdgeID].cat]\r\n                    }\r\n                }\r\n\r\n                if (thisPointID > -1) {\r\n                    if (this.pointData[thisPointID].multicat) {\r\n                        thiscat = this.pointData[thisPointID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisPointID].cat]\r\n                    }\r\n                }\r\n\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 3 || this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    isInside = true\r\n                }\r\n\r\n                if (isInside && this.catEnergyField[k].field[y][x] == 0) {\r\n                    this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                    this.catEnergyField[k].edgeIndexMap2[y][x].push({\r\n                        start: this.edges[thisEdgeID].start,\r\n                        end: this.edges[thisEdgeID].end\r\n                    })\r\n                    value = 1\r\n                    this.catEnergyField[k].field[y][x] = 1\r\n                }\r\n\r\n                if (value == 0) {\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField) {\r\n\r\n                    if (k2 == k)\r\n                        continue\r\n\r\n                    if(k2 == preK){\r\n                        // TODO : compare final value\r\n\r\n\r\n                        continue\r\n                    }\r\n\r\n                    if (realx <= this.catEnergyField[k2].boundingX + this.catEnergyField[k2].boundingWidth * pixelGroup && realx >= this.catEnergyField[k2].boundingX && realy <= this.catEnergyField[k2].boundingY + this.catEnergyField[k2].boundingHeight * pixelGroup && realy >= this.catEnergyField[k2].boundingY) {\r\n                        let relativex = Math.floor((realx - this.catEnergyField[k2].x) / pixelGroup)\r\n                        let relativey = Math.floor((realy - this.catEnergyField[k2].y) / pixelGroup)\r\n\r\n                        let othervalue = this.catEnergyField[k2].field[relativey][relativex]\r\n                        let otherinside = false\r\n                        let otherPointID = this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                        let otherEdgeID = this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                        let othercat\r\n\r\n                        if (otherPointID == -1 && otherEdgeID == -1) {\r\n                            continue\r\n                        }\r\n\r\n                        if (otherEdgeID > -1) {\r\n                            if (this.pointData[otherEdgeID].multicat) {\r\n                                othercat = this.pointData[otherEdgeID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherEdgeID].cat]\r\n                            }\r\n                        }\r\n\r\n                        if (otherPointID > -1) {\r\n                            if (this.pointData[otherPointID].multicat) {\r\n                                othercat = this.pointData[otherPointID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherPointID].cat]\r\n                            }\r\n                        }\r\n\r\n\r\n                        // if(aim){\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        // if(k==\"11\"&&k2==\"0\"){\r\n                        //         drawRect(realx,realy,1,1,\"red\")\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        if (this.isContained(othercat, k)) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // if(k==\"11\"&&k2==\"0\"){\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // }\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n                        }\r\n\r\n\r\n                        if (this.isContained(thiscat, k2) && this.catEnergyField[k2].pointBarrierMap[relativey][relativex] != 3) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n\r\n                        }\r\n\r\n                        if (this.catEnergyField[k2].barrierMap[relativey][relativex] == 3 || this.catEnergyField[k2].barrierMap[relativey][relativex] == 4) {\r\n                            otherinside = true\r\n                        }\r\n\r\n                        if (othervalue == 0) {\r\n                            continue\r\n                        }\r\n\r\n                        if (!isInside && !otherinside) {\r\n                            if (othervalue > value) {\r\n                                finalvalue = 0\r\n                                break\r\n                            } else {\r\n                                finalvalue = value\r\n                            }\r\n                        } else if (isInside && !otherinside) {\r\n                            finalvalue = value\r\n                        } else if (!isInside && otherinside) {\r\n                            finalvalue = 0\r\n                            break\r\n                        } else if (isInside && otherinside) {\r\n                           if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                                finalvalue = value\r\n                            } else {\r\n                                finalvalue = 0\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x] = finalvalue\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    this.catEnergyField[k].finalField[y][x] = 10000\r\n                }\r\n            }\r\n        }\r\n\r\n        this.smoothEnergyField(bounding)\r\n\r\n    }\r\n\r\n    updateFinalField(idx,k,val){\r\n\r\n        let id = parseInt(idx);\r\n        let sz = control_points[k].length;\r\n        //console.log([id,sz]);\r\n        let points = []\r\n        let miny = Number.MAX_VALUE\r\n        let maxy = Number.MIN_VALUE\r\n        for(let j = -1;j <= 1;j ++ ){\r\n            points.push({\r\n                x:control_points[k][(id + j) % sz][0],\r\n                y:control_points[k][(id + j) % sz][1]\r\n            })\r\n            miny = Math.min(miny,control_points[k][(id + j) % sz][1]);\r\n            maxy = Math.max(maxy,control_points[k][(id + j) % sz][1]);\r\n        }\r\n//\r\n        let lines = []\r\n//\r\n        for(let j = 0;j < 3;j ++){\r\n            let p1 = points[j]\r\n            let p2 = points[(j+1)%3]\r\n            let tmp = {}\r\n            tmp.y1 = Math.min(p1.y,p2.y);\r\n            tmp.y2 = Math.max(p1.y,p2.y);\r\n            if(p1.y == p2.y){\r\n                tmp.flag = true;\r\n                tmp.val1 = Math.min(p1.x,p2.x);\r\n                tmp.val2 = Math.max(p1.x,p2.x);\r\n            }\r\n            else{\r\n                tmp.flag = false;\r\n                tmp.val1 = (p2.x - p1.x) / (p2.y - p1.y);\r\n                tmp.val2 = (p1.x * p2.y - p2.x * p1.y) / (p2.y - p1.y);\r\n            }\r\n            lines.push(tmp);\r\n        }\r\n//\r\n        for(let y = miny;y < maxy;y ++){\r\n//\r\n            let x1 = Number.MAX_VALUE;\r\n            let x2 = Number.MIN_VALUE;\r\n            let flag = false;\r\n//\r\n            for(let j = 0; j < 3;j ++){\r\n                if(y >= lines[j].y1 && y <= lines[j].y2){\r\n                    if(lines[j].flag == true){\r\n                        x1 = lines[j].val1;\r\n                        x2 = lines[j].val2;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                    else{\r\n                        let tmpx = lines[j].val1 * y + lines[j].val2;\r\n                        x1 = Math.min(x1, tmpx);\r\n                        x2 = Math.max(x2,tmpx);\r\n                    }\r\n                }\r\n            }\r\n//\r\n            if(flag==true && val == 0){\r\n                continue;\r\n            }\r\n            else{\r\n                x1 = parseInt(x1)\r\n                x2 = parseInt(x2)\r\n                for(let x = x1;x <= x2;x ++){\r\n                    //console.log(\"(\" + this.catEnergyField[k].x + \", \" + this.catEnergyField[k].y + \", \"+ pixelGroup + \")\");\r\n                    //console.log(\"(\" + this.catEnergyField[k].height + \", \" + this.catEnergyField[k].width + \")\")\r\n                    let uy = Math.min(parseInt((y - this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                    let ux = Math.min(parseInt((x - this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                    uy = Math.max(uy,0)\r\n                    ux = Math.max(ux,0)\r\n                    //alert(\"(\" + x + \", \" + y + \")\");\r\n                    // this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].field[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.updatedEnergyPoints[k].push([parseInt(ux),parseInt(uy)])\r\n                }\r\n            }\r\n//\r\n        }\r\n        //console.log(this.catEnergyField[k].finalField)\r\n    }\r\n\r\n    drawEnergyField(k){\r\n\r\n\r\n        let field=this.catEnergyField[k].finalField\r\n        //let field = this.catEnergyField[k].field\r\n        for(let y=0;y<field.length;y++){\r\n            for (let x=0;x<field[y].length;x++){\r\n                if(field[y][x]<0.0001)\r\n                    continue\r\n                let that=this\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=field[y][x]\r\n\r\n                g.append(\"rect\")\r\n                    .attr(\"x\",realx-0.5)\r\n                    .attr(\"y\",realy-0.5)\r\n                    .attr(\"width\",1)\r\n                    .attr(\"height\",1)\r\n                    .attr(\"class\",\"energyfieldrect\")\r\n                    .attr(\"fill\", function(){\r\n                        // if(value==-1){\r\n                        //     return \"red\"\r\n                        // }\r\n                        // if(value==-2){\r\n                        //     return \"green\"\r\n                        // }\r\n                        return colors[parseInt(k)]\r\n                    })\r\n                    .attr(\"opacity\",1)\r\n                    .attr(\"fieldvalue\",value)\r\n                    .on(\"mouseover\",function(d){\r\n                        console.log(d3.select(d.target).attr(\"fieldvalue\"))\r\n                        // console.log(\"2: \"+that.catEnergyField[\"2\"].finalField[y][x])\r\n                        // console.log(x,y)\r\n                        // console.log(\"1: \"+that.catEnergyField[\"1\"].barrierMap[y][x])\r\n\r\n                    })\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawBarrierMap(){\r\n        for(var k in this.catEnergyField){\r\n\r\n\r\n            let map=this.catEnergyField[k].barrierMap\r\n            for(let i=0;i<this.catEnergyField[k].height;i++){\r\n                for(let j=0;j<this.catEnergyField[k].width;j++){\r\n                    let realy=i+this.catEnergyField[k].y\r\n                    let realx=j+this.catEnergyField[k].x\r\n                    if(map[i][j]==3){\r\n                        drawRect(realx,realy,1,1,\"red\")\r\n                    }\r\n                    if(map[i][j]==4){\r\n                        drawRect(realx,realy,1,1,\"green\")\r\n                    }\r\n                    if(map[i][j]==1){\r\n                        drawRect(realx,realy,1,1,\"yellow\")\r\n                    }\r\n                    if(map[i][j]==2){\r\n                        drawRect(realx,realy,1,1,\"orange\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    drawBSpline(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            if(i==0){\r\n                console.log(lines[i]);\r\n            }\r\n            g.append(\"path\")\r\n                .style(\"fill\", color)\r\n                .style(\"stroke\",\"none\")\r\n                // .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 0.5)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0];\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1];\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', color)\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n    }\r\n\r\n    drawBSplineV2(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        g.append(\"path\")\r\n            .style(\"fill\", color)\r\n            .style(\"stroke\",\"none\")\r\n            // .style(\"stroke-width\", 0.5)\r\n            .style('opacity', 0.5)\r\n            .attr(\"d\", function () {\r\n                var p = \"\";\r\n                p += (d3.line()\r\n                        .x(function (dat) {\r\n                            return dat[0];\r\n                        })\r\n                        .y(function (dat) {\r\n                            return dat[1];\r\n                        })\r\n                )(lines)+ \"\";\r\n                return p;\r\n            })\r\n            .on('mouseover', function () {\r\n                d3.select(this)\r\n                    .style('stroke', \"red\")\r\n                    .style(\"stroke-width\", 3);\r\n            })\r\n            .on('mouseout', function () {\r\n                d3.select(this)\r\n                    .style('stroke', color)\r\n                    .style(\"stroke-width\", 0.5);\r\n            });\r\n\r\n    }\r\n\r\n    fillPolygonForEdge(Polygon, k, field, othercat){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n\r\n                //......\r\n                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                //d3.select('g').append('circle')\r\n                //    .attr('cx',realx)\r\n                //    .attr('cy',realy)\r\n                //    .attr('r',1)\r\n                //    .attr('fill','green')\r\n\r\n                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n\r\n                                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                //d3.select('g').append('circle')\r\n                                //    .attr('cx',realx)\r\n                                //    .attr('cy',realy)\r\n                                //    .attr('r',1)\r\n                                //    .attr('fill','green')\r\n\r\n                                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                                        //d3.select('g').append('circle')\r\n                                        //    .attr('cx',realx)\r\n                                        //    .attr('cy',realy)\r\n                                        //    .attr('r',1)\r\n                                        //    .attr('fill','blue')\r\n                                    }\r\n                                }\r\n\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    fillPolygon(Polygon,k,val,cut = false){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                if(!cut){\r\n                    this.catEnergyField[k].field[fy][fx] = val;\r\n                }\r\n                this.updatedEnergyPoints[k].push([fx,fy])\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n                                //console.log((x_begin,i));\r\n                                //canvas[parseInt(x_begin)][parseInt(i)] = val;\r\n                                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                                if(!cut){\r\n                                    this.catEnergyField[k].field[fy][fx] = val;\r\n                                }\r\n                                this.updatedEnergyPoints[k].push([fx,fy])\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    drawISOLinesV2(k,that,curdata){\r\n\r\n        editSeg[k] = []\r\n\r\n        let len;\r\n\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                            //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                       // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][0], control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 3) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                let p1 = [ control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1] ]\r\n                                let p2 = [ control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1] ]\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                let r1_idx = 0\r\n                                let dis1 = Number.MAX_VALUE\r\n                                let r2_idx = totLen / 5\r\n                                let dis2 = Number.MAX_VALUE\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n\r\n                                    let tmpdis1 = calDistance(p1[0], p1[1], tmp_p.x, tmp_p.y)\r\n                                    let tmpdis2 = calDistance(p2[0], p2[1], tmp_p.x, tmp_p.y)\r\n\r\n                                    if(tmpdis1 < dis1){\r\n                                        r1_idx = p\r\n                                        dis1 = tmpdis1\r\n                                    }\r\n\r\n                                    if(tmpdis2 < dis2){\r\n                                        r2_idx = p\r\n                                        dis2 = tmpdis2\r\n                                    }\r\n\r\n                                    //tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                for(let p = r1_idx; p <= r2_idx; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                    //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n                //    .remove()\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        g.append(\"path\")\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                }\r\n                // .style(\"stroke-width\", 0.5);\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    reDraw(k,that,curdata){\r\n\r\n        let len = control_points[k].length;\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                console.log(\"dragged control point\")\r\n                console.log(\"(\" + iidx + \", \" + jidx + \")\")\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                        //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                        //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        d3.select(\"#path\"+k)\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                    // .style(\"stroke-width\", 0.5);\r\n                }\r\n\r\n\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    console.log(\"click!\")\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    drawOutline(points,color){\r\n\r\n        let SetAreas = new Array();\r\n\r\n        var lineFunction = d3.line()\r\n            .x(function(d) { return d[0]; })\r\n            .y(function(d) { return d[1]; })\r\n            .curve(d3.curveCardinalClosed);\r\n\r\n        let pointpath=lineFunction(points);\r\n\r\n        g.append('path')\r\n            .attr('d', pointpath)\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill',color)\r\n            .attr('fill-rule',\"evenodd\");\r\n    }\r\n\r\n    drawISOLines(lines, intervals,dx,dy,color) {\r\n\r\n        var marginBottomLabel = 0;\r\n\r\n\r\n\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            g.append(\"path\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\",color)\r\n                .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 1.0)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0]+dx;\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1]+dy;\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                    console.log(i)\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"black\")\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calOneISOLine(intervals,k){\r\n\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n            let data=this.catEnergyField[k].finalField\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n        return isoLines[0]\r\n    }\r\n\r\n    calISOLine(intervals, fieldData){\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n\r\n\r\n            let data=fieldData[k]\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n        return isoLineDict\r\n    }\r\n\r\n    BSplineInterpolate(points){\r\n        let tpoints=[]\r\n        let splinePoints=[]\r\n        let gap=5\r\n        for (let i=0;i<points.length;i++){\r\n            let remainLength=points.length-i\r\n\r\n            if(remainLength>gap){\r\n                if(i%gap==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n                if(i>0&&i%(3*gap)==0){\r\n                    var spline = new BSpline(tpoints,3)\r\n                    for(var t = 0.01;t<=1;t+=0.01){\r\n                        var p = spline.calcAt(t);\r\n                        splinePoints.push(p)\r\n                    }\r\n                    tpoints=[]\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n            else{\r\n                if(i%3==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        var spline = new BSpline(tpoints,3)\r\n        for(var t = 0.01;t<=1;t+=0.01){\r\n            var p = spline.calcAt(t);\r\n            splinePoints.push(p)\r\n        }\r\n\r\n\r\n        return splinePoints\r\n    }\r\n\r\n    normalizeKernel(kernel){\r\n        let sum=0\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                sum+=kernel[i][j]\r\n            }\r\n        }\r\n\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                kernel[i][j]=kernel[i][j]/sum\r\n            }\r\n        }\r\n        return kernel\r\n    }\r\n\r\n    getGaussianKernel(theta,kernelsize){\r\n        let scale=1\r\n        let kernel=[]\r\n        for (let i=0;i<kernelsize;i++){\r\n            kernel.push([])\r\n            for (let j=0;j<kernelsize;j++){\r\n                kernel[i].push(0)\r\n            }\r\n        }\r\n        let anchor=parseInt(kernelsize/2)/scale\r\n        let C=1/(Math.PI*2*theta*theta)\r\n\r\n        for (let i=0;i<kernelsize;i++){\r\n            for (let j=0;j<kernelsize;j++){\r\n                let ny=i/scale\r\n                let nx=j/scale\r\n                let y=Math.pow(ny-anchor,2)\r\n                let x=Math.pow(nx-anchor,2)\r\n                kernel[i][j]=C*Math.exp(-(x*x+y*y)/(2*theta*theta))\r\n            }\r\n        }\r\n\r\n        kernel=this.normalizeKernel(kernel)\r\n        return kernel\r\n    }\r\n\r\n    checkSingularPoint(k,x,y){\r\n        let delta=1\r\n        let field=this.catEnergyField[k].finalField\r\n        let isSingular=true\r\n        //right\r\n        if(x+delta<this.catEnergyField[k].width){\r\n            if(field[y][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left\r\n        if(x-delta>0){\r\n            if(field[y][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //up\r\n        if(y-delta>0){\r\n            if(field[y-delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //down\r\n        if(y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-top\r\n        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n            if(field[y-delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-bottom\r\n        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-top\r\n        if(x-delta>0&&y-delta>0){\r\n            if(field[y-delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-bottom\r\n        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n\r\n        return isSingular\r\n    }\r\n\r\n    fillCrossingEdge_Part(edges){\r\n\r\n\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<edges.length;i++){\r\n            let cat1=edges[i].cat\r\n            let start1=this.pointData[edges[i].start]\r\n            let end1=this.pointData[edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual && edges[i].virtrualNodes.length > 0){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:edges[i].virtrualNodes[0][0],y:edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:edges[i].virtrualNodes[v][0],y:edges[i].virtrualNodes[v][1]},{x:edges[i].virtrualNodes[v+1][0],y:edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:edges[i].virtrualNodes[vlength-1][0],y:edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=0;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual && this.edges[j].virtrualNodes.length > 0){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    fillCrossingEdge(){\r\n\r\n        //return\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat1=this.edges[i].cat\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:this.edges[i].virtrualNodes[0][0],y:this.edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<this.edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<this.edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:this.edges[i].virtrualNodes[v][0],y:this.edges[i].virtrualNodes[v][1]},{x:this.edges[i].virtrualNodes[v+1][0],y:this.edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=this.edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:this.edges[i].virtrualNodes[vlength-1][0],y:this.edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=i+1;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                // let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                    // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                    // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            for (var k2 in this.catEdgeDict) {\r\n                                let othercat = k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for(var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    smoothEnergyField(bounding){\r\n        let kernelsize = 3\r\n        let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n        let anchor = parseInt(kernelsize/2)\r\n        // console.log(kernel)\r\n        for (var k in this.catEnergyField){\r\n\r\n            let sx = bounding[k].minX;\r\n            let ex = bounding[k].maxX;\r\n            let sy = bounding[k].minY;\r\n            let ey = bounding[k].maxY;\r\n\r\n            let cur_width = ex - sx + 1;\r\n            let cur_height = ey - sy + 1;\r\n\r\n            let newField=[]\r\n            for (let y = 0;y < cur_height + 10;y ++){\r\n                newField.push(new Array(cur_width + 10).fill(0))\r\n            }\r\n\r\n            for (let y = sy; y <= ey; y ++){\r\n                for (let x = sx; x <= ex; x ++){\r\n\r\n                    let newvalue = 0\r\n                    for (let i = 0;i < kernelsize;i ++){\r\n                        for (let j = 0;j < kernelsize;j ++){\r\n                            let dy = i - anchor\r\n                            let dx = j - anchor\r\n                            let ny = y + dy\r\n                            let nx = x + dx\r\n                            if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                                newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                            }\r\n                        }\r\n                    }\r\n                    if(newvalue > 0){\r\n                        newField[y - sy][x - sx] = newvalue\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let y = sy; y <= ey; y ++){\r\n                for(let x = sx; x <= ex; x ++){\r\n                    //console.log(\"(\" + y + \", \" + x + \")\")\r\n                    //console.log(this.catEnergyField[k].finalField)\r\n                    this.catEnergyField[k].finalField[y][x] = newField[y - sy][x - sx]\r\n                }\r\n            }\r\n\r\n            //this.catEnergyField[k].finalField=newField\r\n        }\r\n    }\r\n\r\n    saveOutline(isoLineDict){\r\n        let res=[]\r\n        for (var k in isoLineDict){\r\n            for (let i=0;i<isoLineDict[k].length;i++){\r\n                let formatpoints=[]\r\n                for(let p=0;p<isoLineDict[k][i].length;p++){\r\n                    formatpoints.push({x:isoLineDict[k][i][p][0],y:isoLineDict[k][i][p][1]})\r\n                }\r\n                res.push({\r\n                    cat:k,\r\n                    id:i,\r\n                    isInterior:false,\r\n                    parentID:-1,\r\n                    points:formatpoints\r\n                })\r\n            }\r\n        }\r\n        console.log(JSON.stringify(res))\r\n    }\r\n\r\n    removeOverlaps(){\r\n\r\n        this.updateEnergyPoints()\r\n\r\n        //for(var k in this.catEnergyField){\r\n        //    this.drawEnergyField(k);\r\n        //}\r\n\r\n\r\n        //this.smoothEnergyField()\r\n\r\n        d3.select(\"svg\")\r\n            .selectAll(\"path\")\r\n            .remove()\r\n\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        /*\r\n        intervals=[0.01]\r\n        let isoDict=this.calISOLine(intervals)\r\n\r\n        //for (var k in isoDict){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {}\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    tmp_polygon[k].selectidx = tmp_polygon[k].length - 1;\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        //console.log(tmp_polygon)\r\n        for(var k in isoDict){\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                if(i == sidx){\r\n                    continue;\r\n                }\r\n                let flag = true;\r\n                for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                    flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx]);\r\n                    if(flag == false){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n                    if(tmp_polygon[k][i].length < 30){\r\n                        continue;\r\n                    }\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j += 10){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"hhhh\")\r\n        //console.log(isoDict)\r\n        /*\r\n        for (var k in isoDict){\r\n\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    //console.log(isoDict[k][i])\r\n                    if(!polygontest.hasOwnProperty(k)){\r\n                        polygontest[k] = [];\r\n                    }\r\n                    let tmppolygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        tmppolygon.push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    polygontest[k].push(tmppolygon)\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n\r\n        // re-cal the energy field for inner outline\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].tfinalField = []\r\n            for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                    let val = this.catEnergyField[k].finalField[y][x];\r\n                    let flag = false;\r\n                    for(let idx = 0; idx < polygontest[k].length; idx ++){\r\n                        flag = IsoInsideTest([x, y], polygontest[k][idx])\r\n                        if(flag){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        //console.log(\"test!!\")\r\n                        if(val > 0){\r\n                            this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                        }\r\n                        else{\r\n                            this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.catEnergyField[k].finalField[y][x] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(this.catEnergyField[k].tfinalField,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n\r\n        for (var k in isoLineDict){\r\n            //console.log(isoLineDict[k])\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                if(isoLineDict[k][i].length < 30){\r\n                    continue;\r\n                }\r\n                let curlen = control_points[k].length;\r\n                control_points[k][curlen] = [];\r\n                for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                    control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let meandis = 0;\r\n                let sz = control_points[k][curlen].length;\r\n                for(let j = 0; j < sz; j ++){\r\n                    meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                        control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                }\r\n                meandis /= sz\r\n                control_points[k][curlen].meandis = meandis;\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        */\r\n\r\n        /*\r\n        for(var k in this.catEnergyField){\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            //this.drawEnergyField(k);\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n        */\r\n\r\n        //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n        //    .remove()\r\n\r\n        for(var k in this.catEnergyField){\r\n            // this.drawEnergyField(k);\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    onChangeEdgeWidth = value => {\r\n        edgeWidth = value\r\n        this.setState({\r\n            edgeWidth:value\r\n        })\r\n        this.changeEdgeWidth(this.selectedEdge,value)\r\n    };\r\n\r\n\r\n    onChangeNodeR0 = value => {\r\n        nodeR0 = value\r\n        this.setState({\r\n            nodeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeNodeR1 = value => {\r\n        nodeR1 = value\r\n        nodeR0=nodeR1-5\r\n        this.setState({\r\n            nodeR1: value,\r\n            nodeR0:nodeR1-5\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR0 = value => {\r\n        edgeR0 = value\r\n        this.setState({\r\n            edgeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR1 = value => {\r\n        edgeR1 = value\r\n        edgeR0=edgeR1-5\r\n        this.setState({\r\n            edgeR1: value,\r\n            edgeR0:edgeR0\r\n        });\r\n    };\r\n\r\n    onChangePixelGroup = value => {\r\n        pixelGroup = value\r\n        this.setState({\r\n            pixelGroup: value,\r\n        });\r\n    };\r\n\r\n    onChangeGap = value => {\r\n        gapBetween = value\r\n        this.setState({\r\n            gapBetween: value,\r\n        });\r\n    };\r\n\r\n    render(){\r\n        return(\r\n\r\n            <div id={\"Sliders\"}>\r\n                <br/>\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>nodeR0</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR0}\r\n                        value={typeof nodeR0 === 'number' ? nodeR0 : 10}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR0}\r\n                        onChange={this.onChangeNodeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Node Radius</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR1}\r\n                        value={typeof nodeR1 === 'number' ? nodeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR1}\r\n                        onChange={this.onChangeNodeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>edgeR0</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR0}\r\n                        value={typeof edgeR0 === 'number' ? edgeR0 : 15}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR0}\r\n                        onChange={this.onChangeEdgeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Global Edge Width</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR1}\r\n                        value={typeof edgeR1 === 'number' ? edgeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR1}\r\n                        onChange={this.onChangeEdgeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Pixel Group</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangePixelGroup}\r\n                            value={typeof pixelGroup === 'number' ? pixelGroup : 2}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={pixelGroup}\r\n                            onChange={this.onChangePixelGroup}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Gap Between Different Groups</h4>\r\n                        <Slider\r\n                            min={0}\r\n                            max={5}\r\n                            onChange={this.onChangeGap}\r\n                            value={typeof gapBetween === 'number' ? gapBetween : 1}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={0}\r\n                            max={5}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={gapBetween}\r\n                            onChange={this.onChangeGap}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Edge Width</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            value={this.state.edgeWidth}\r\n                        disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={this.state.edgeWidth}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                </Row>\r\n\r\n                <br/>\r\n                <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Draw Bubbles\r\n                </Button>\r\n\r\n                <Button onClick = {this.removeOverlaps.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Remove Overlaps\r\n                </Button>\r\n\r\n        </div>)\r\n\r\n    }\r\n}\r\n\r\nexport default AdaptiveIsovalue","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {PointToSegDist} from \"./util\"\r\n\r\nvar FileSaver = require('file-saver');\r\n//import Quadtree from '@timohausmann/quadtree-js'\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\n// var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\n// var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=10\r\nvar DBSCAN_EPS=40\r\nvar VirtrualNodeBuffer=50\r\n\r\n\r\nvar clustering = require('density-clustering');\r\nvar weightCross=1\r\nvar weightDistance=1\r\nvar weightMess=1\r\n\r\nvar maxCross=Number.MIN_VALUE\r\nvar DISTANCE_THRESHHOLD=Number.MAX_VALUE\r\n\r\nvar priority_queue = require('./priority_queue.js');\r\nvar svgid = \"#mainsvg\"\r\nvar opsvgid = \"#leftsvg\"\r\nvar svg;\r\nvar g;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\n\r\nvar subOldPoints = []\r\nvar addNewPoints = []\r\nvar subOldEdges = []\r\nvar addNewEdges = []\r\nvar editPoints = []\r\nvar editEdges = []\r\nvar preEdges = []\r\nvar tmpEditEdges = []\r\nvar prePoint\r\nvar preEdgeDict\r\nvar curEdgeDict\r\nvar editView = false\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//var Quadtree = require('./quadtree.js');\r\n\r\nclass HierarchicalCluster extends Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false\r\n        }\r\n        this.issplit=false\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedIndex=-1\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n    }\r\n\r\n    init(){\r\n        this.setState({\r\n            pointData: []\r\n        })\r\n        this.setState({\r\n            edges: []\r\n        })\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n\r\n    }\r\n\r\n    searchFather(x){\r\n        while(x!=this.f[x]){\r\n            this.f[x] = this.f[this.f[x]];\r\n            x = this.f[x];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    unionFather(x,y){\r\n        this.f[this.searchFather(y)] = this.searchFather(x);\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        // this.setState({\r\n        //     hasLoadData:this.props.hasLoadData\r\n        // })\r\n        //V1\r\n        //this.QTree = new Quadtree({\r\n        //    x: 0,\r\n        //    y: 0,\r\n        //    width: this.canvasWidth,\r\n        //    height: this.canvasHeight\r\n        //});\r\n        //this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n\r\n        d3.select(\"#leftsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        offsetX = minx-20;\r\n        offsetY = miny-20;\r\n        viewWidth = maxx-minx+40;\r\n        viewHeight = maxy-miny+40\r\n\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let dissum=0\r\n        let disnum=0\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                dissum+=dis\r\n                disnum+=1\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n        // DBSCAN_EPS=POINT_EDGE_EPS\r\n        this.maxDis=maxDis\r\n        /*                d3.select(svgid)\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",POINT_EDGE_EPS)\r\n                    .attr(\"cy\",POINT_EDGE_EPS)\r\n                    .attr(\"r\",POINT_EDGE_EPS)\r\n                    .attr(\"fill\",\"black\")*/\r\n\r\n        DISTANCE_THRESHHOLD=dissum/disnum-10\r\n        //console.log(POINT_EDGE_EPS)\r\n        //console.log(\"avreage distance: \"+dissum/disnum)\r\n        //console.log(\"max distance: \"+this.maxDis)\r\n\r\n\r\n    }\r\n\r\n    addNewPoints(point){\r\n\r\n        console.log(\"addNewPoints\")\r\n        point.x=parseFloat(point.x)\r\n        point.y=parseFloat(point.y)\r\n        point.id=this.pointData.length\r\n        point.cat=point.cat.toString()\r\n        let cats=point.cat.split(\",\")\r\n        let catarray=[]\r\n        if (cats.length>1){\r\n            point.multicat=true\r\n            for (let c=0;c<cats.length;c++){\r\n                catarray.push(cats[c])\r\n            }\r\n        }\r\n        else{\r\n            point.multicat=false\r\n            catarray.push(point.cat)\r\n        }\r\n        point.catArray=catarray\r\n\r\n        for (let c=0;c<point.catArray.length;c++){\r\n            let nowcat=point.catArray[c]\r\n            if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                this.catPointDict[nowcat]=[]\r\n            }\r\n            this.catPointDict[nowcat].push(point)\r\n        }\r\n\r\n        this.pointData.push(point)\r\n\r\n        let tmpp1 = clone(this.pointData[this.pointData.length - 1])\r\n        tmpp1.flag = true\r\n        tmpp1.id = this.pointData.length - 1\r\n        editPoints.push(tmpp1)\r\n\r\n        //this.centralizeData()\r\n\r\n        this.calEPS()\r\n\r\n        this.drawPointData()\r\n\r\n        this.optimizeMST(true)\r\n\r\n        this.setState({\r\n            pointData: this.pointData\r\n        })\r\n        this.setState({\r\n            edges: this.edges\r\n        })\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n        //let that=this\r\n        //fetch('/data/BubbleSetExample1.txt',{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n        //console.log(data)\r\n\r\n        // if(!this.props.hasLoadData){\r\n        //     return\r\n        // }\r\n\r\n        if(this.state.hasinit){\r\n            this.applyEdit()\r\n        }\r\n        else{\r\n            if(this.props.pointData){\r\n                this.init();\r\n\r\n                if(this.props.edges){\r\n                    this.edges=this.props.edges\r\n                }\r\n                console.log(this.edges.length)\r\n\r\n                // alert(\"Finish input and start creating spanning tree!\");\r\n                this.pointData=this.props.pointData\r\n                //this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                //console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n                    this.pointData[i].id=i\r\n                    this.pointData[i].cat=this.pointData[i].cat.toString()\r\n                    let cats=this.pointData[i].cat.split(\",\")\r\n                    let catarray=[]\r\n                    if (cats.length>1){\r\n                        this.pointData[i].multicat=true\r\n                        for (let c=0;c<cats.length;c++){\r\n                            catarray.push(cats[c])\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.pointData[i].multicat=false\r\n                        catarray.push(this.pointData[i].cat)\r\n                    }\r\n                    this.pointData[i].catArray=catarray\r\n                    for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                        let nowcat=this.pointData[i].catArray[c]\r\n                        if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                            this.catPointDict[nowcat]=[]\r\n                        }\r\n                        this.catPointDict[nowcat].push(this.pointData[i])\r\n                    }\r\n                }\r\n                console.log(this.catPointDict)\r\n                //console.log(this.pointData)\r\n                //console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                d3.select(svgid).selectAll(\"*\").remove();\r\n                this.drawPointData()\r\n                var beginTime = +new Date();\r\n                this.generateTreeWithHierarchical()\r\n                var endTime = +new Date();\r\n\r\n                console.log(\"Spanning tree: \"+(endTime-beginTime)+\"ms\");\r\n\r\n                // console.log(this.edges)\r\n                this.drawEdges()\r\n                this.countEdgeCrossingWithRouting()\r\n                this.props.hasCreate();\r\n\r\n                console.log(this.edges);\r\n                this.setState({\r\n                    pointData: this.pointData\r\n                })\r\n                this.setState({\r\n                    edges: this.edges\r\n                })\r\n                this.setState({\r\n                    hasinit:true\r\n                })\r\n                //})\r\n            }\r\n\r\n        }\r\n        //console.log(this.pointData)\r\n\r\n        return [this.pointData, this.edges]\r\n\r\n    }\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n    }\r\n\r\n    checkConnectBetweenAllClusterV2(){\r\n        for(let k in this.clusterDict){\r\n            let m = this.clustergraphInfo[k].edgesnum;\r\n            let n = this.clustergraphInfo[k].nodesnum;\r\n            if (m != n - 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnectBetweenAllCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n\r\n    checkConnectBetweenTwoClusterV2(id1,id2){\r\n        return (this.searchFather(id1)==this.searchFather(id2));\r\n    }\r\n\r\n    checkConnectBetweenTwoCluster(id1,id2){\r\n        var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, id1);\r\n        if (!dfs.hasPathTo(id2)){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n    }\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(svgid).append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for(let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n            that.edges[i].SVGElement=[]\r\n        }\r\n\r\n        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        if(d3.select(opsvgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(opsvgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        /*        function dragstartControlpoint(){\r\n                }\r\n                function draggedControlPoint(event){\r\n                    let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n                    that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n                    d3.select(this)\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                        })\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                        })\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n                }\r\n\r\n                var dragControlPoint = d3.drag()\r\n                    .on(\"start\",dragstartControlpoint)\r\n                    .on(\"drag\",draggedControlPoint)\r\n\r\n                function dragstartEdge(event){\r\n                    // console.log(\"start!\")\r\n                    let index=parseInt(d3.select(this).attr(\"index\"))\r\n                    let start=that.pointData[that.edges[index].start]\r\n                    let end=that.pointData[that.edges[index].end]\r\n\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n\r\n                    if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                        let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                        that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=segindex\r\n                    }\r\n                    else{\r\n                        that.edges[index].virtrual=true\r\n                        that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=0\r\n                    }\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .remove()\r\n\r\n                    let vpoints=that.edges[index].virtrualNodes\r\n                    let nowp=[start.x,start.y]\r\n                    let nextp=[]\r\n                    for(let i=0;i<vpoints.length;i++){\r\n                        nextp=vpoints[i]\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .append(\"line\")\r\n                            .attr(\"x1\",nowp[0])\r\n                            .attr(\"y1\",nowp[1])\r\n                            .attr(\"x2\",nextp[0])\r\n                            .attr(\"y2\",nextp[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"index\",index)\r\n                            .attr(\"isvirtrual\",true)\r\n                            .attr(\"segindex\",i)\r\n                            .on(\"mouseover\",function(d,i){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"red\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"black\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mousedown\",handleMouseDown)\r\n                            .call(dragEdge)\r\n\r\n                        nowp=nextp\r\n                    }\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .append(\"line\")\r\n                        .attr(\"x1\",nowp[0])\r\n                        .attr(\"y1\",nowp[1])\r\n                        .attr(\"x2\",end.x)\r\n                        .attr(\"y2\",end.y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",index)\r\n                        .attr(\"isvirtrual\",true)\r\n                        .attr(\"segindex\",vpoints.length)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"red\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mouseout\",function(){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"black\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mousedown\",handleMouseDown)\r\n\r\n                        .call(dragEdge)\r\n\r\n                    for (let v=0;v<vpoints.length;v++){\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .append(\"circle\")\r\n                            .attr(\"class\",\"controlPoints\")\r\n                            .attr(\"cx\",vpoints[v][0])\r\n                            .attr(\"cy\",vpoints[v][1])\r\n                            .attr(\"r\",5)\r\n                            .attr(\"fill\",\"red\")\r\n                            .attr(\"opacity\",0)\r\n                            .attr(\"edgeindex\",index)\r\n                            .attr(\"segindex\",v)\r\n                            // .attr(\"display\",\"none\")\r\n                            .on(\"mouseover\",function(){\r\n                                d3.select(this).attr(\"opacity\",1)\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                d3.select(this).attr(\"opacity\",0)\r\n                            })\r\n                            .call(dragControlPoint)\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n                function draggedEdge(event){\r\n                    // console.log(\"drag!\")\r\n                    if(that.draggedEdgeIndex==-1)\r\n                        return\r\n                    event.sourceEvent.stopPropagation();\r\n                    let edgeIndex=that.draggedEdgeIndex\r\n                    let segIndex=that.draggedEdgeSeg\r\n\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n\r\n                }\r\n\r\n                function dragendEdge(event){\r\n                    // console.log(\"end!\")\r\n                    that.draggedEdgeSeg=-1\r\n                    that.draggedEdgeIndex=-1\r\n                }\r\n\r\n                var dragEdge = d3.drag()\r\n                    .on(\"start\",dragstartEdge)\r\n                    .on(\"drag\",draggedEdge)\r\n                    .on(\"end\",dragendEdge)\r\n\r\n                function handleMouseDown(event){\r\n                    if(event.button==2){\r\n                        let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                            })\r\n                            .attr(\"edgeindex\",function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                            })\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                            })\r\n                            .attr(\"index\",function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))-1\r\n                            })\r\n                        that.edges.splice(deleteindex,1)\r\n\r\n                        for (let i=0;i<that.edges.length;i++){\r\n                            that.edges[i].id=i\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n        d3.selectAll(\"line\").remove()\r\n\r\n        d3.selectAll(\".controlPoints\").remove()\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            /*            let start=this.edges[i].start\r\n                        let end=this.edges[i].end\r\n\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        let index=i\r\n                        if(this.edges[i].virtrual){\r\n                            let vpoints=this.edges[i].virtrualNodes\r\n                            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                            let vend\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                vend=vpoints[v]\r\n                                let newline=d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"line\")\r\n                                    .attr(\"x1\",vstart[0])\r\n                                    .attr(\"y1\",vstart[1])\r\n                                    .attr(\"x2\",vend[0])\r\n                                    .attr(\"y2\",vend[1])\r\n                                    .attr(\"stroke-width\",2)\r\n                                    .attr(\"stroke\",\"black\")\r\n                                    .attr(\"index\",i)\r\n                                    .attr(\"isvirtrual\",true)\r\n                                    .attr(\"segindex\",v)\r\n                                    .on(\"mouseover\",function(d,i){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"red\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"black\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                                    .call(dragEdge)\r\n                                vstart=vend\r\n                                if(v==0){\r\n                                    this.nodeStartDict[start].push(newline)\r\n                                }\r\n                            }\r\n                            vend=[this.pointData[end].x,this.pointData[end].y]\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",vstart[0])\r\n                                .attr(\"y1\",vstart[1])\r\n                                .attr(\"x2\",vend[0])\r\n                                .attr(\"y2\",vend[1])\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",true)\r\n                                .attr(\"segindex\",vpoints.length)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeEndDict[end].push(newline)\r\n                            // console.log()\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"circle\")\r\n                                    .attr(\"class\",\"controlPoints\")\r\n                                    .attr(\"cx\",vpoints[v][0])\r\n                                    .attr(\"cy\",vpoints[v][1])\r\n                                    .attr(\"r\",5)\r\n                                    .attr(\"edgeindex\",i)\r\n                                    .attr(\"segindex\",v)\r\n                                    .attr(\"fill\",\"red\")\r\n                                    .attr(\"opacity\",0)\r\n                                    // .attr(\"display\",\"none\")\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"opacity\",1)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"opacity\",0)\r\n                                    })\r\n                                    .call(dragControlPoint)\r\n\r\n                            }\r\n                        }\r\n                        else{\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",this.pointData[start].x)\r\n                                .attr(\"y1\",this.pointData[start].y)\r\n                                .attr(\"x2\",this.pointData[end].x)\r\n                                .attr(\"y2\",this.pointData[end].y)\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",false)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeStartDict[start].push(newline)\r\n                            this.nodeEndDict[end].push(newline)\r\n                        }*/\r\n\r\n            this.drawOneEdge(i)\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n        console.log(that.pointData)\r\n        console.log(JSON.stringify(that.pointData))\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        // console.log(this.edges)\r\n        // d3.selectAll(\"line\").remove()\r\n        // let that=this\r\n        // for(let i=0;i<this.edges.length;i++){\r\n        //     let node1=this.edges[i].start\r\n        //     let node2=this.edges[i].end\r\n        //\r\n        //     d3.select(svgid).append(\"line\")\r\n        //         .attr(\"x1\",this.pointData[node1].x)\r\n        //         .attr(\"y1\",this.pointData[node1].y)\r\n        //         .attr(\"x2\",this.pointData[node2].x)\r\n        //         .attr(\"y2\",this.pointData[node2].y)\r\n        //         .attr(\"stroke-width\",2)\r\n        //         .attr(\"stroke\",\"black\")\r\n        //         .attr(\"index\",i)\r\n        //         .on(\"click\",function(){\r\n        //             let removeindex=d3.select(this).attr(\"index\")\r\n        //             that.edges[removeindex].isdelete=true\r\n        //             d3.select(this).remove()\r\n        //             console.log(that.edges)\r\n        //         })\r\n        // }\r\n\r\n        console.log(JSON.stringify(this.edges))\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/manuallyDataEdge.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n                this.countEdgeCrossing()\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n            console.log(this.selectItem)\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                            console.log(that.edges)\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    optimizeMST(isedit){\r\n\r\n        this.clustergraphInfo={}\r\n        let newGraph=new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<newGraph.V;i++){\r\n            newGraph.node(i).label=this.pointData[i].cat\r\n        }\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let cat=this.edges[i].cat\r\n            newGraph.addEdge(start,end)\r\n            // this.clustergraphInfo[cat].edgesnum+=1\r\n        }\r\n\r\n        this.graph=newGraph\r\n        //find Connected Components\r\n        var cc = new jsgraphs.ConnectedComponents(newGraph);\r\n        console.log(cc.componentCount());\r\n\r\n\r\n\r\n        //create new clusterDict with connected components\r\n        let newClusterDict={}\r\n        for (let k in this.catPointDict){\r\n            newClusterDict[k]=[]\r\n        }\r\n        let clusterArr=[]\r\n        for (let i=0;i<cc.componentCount();i++){\r\n            clusterArr.push([])\r\n        }\r\n        for (var v = 0; v < newGraph.V; v++) {\r\n            let point=this.pointData[v]\r\n            let comid=cc.componentId(v)\r\n            clusterArr[comid].push(point)\r\n        }\r\n        for(let i=0;i<clusterArr.length;i++){\r\n            let cat=clusterArr[i][0].cat\r\n            newClusterDict[cat].push(clusterArr[i])\r\n        }\r\n        this.clusterDict=newClusterDict\r\n        // console.log(newClusterDict)\r\n\r\n        for (let k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n        }\r\n\r\n        clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n\r\n        this.clusterArr=clusterArr\r\n        // console.log(this.clusterArr)\r\n        let g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n\r\n        //update boundingbox of points\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n        if(!isedit){\r\n            let newEdges=this.recalculateSpanningTree()\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n\r\n            // this.drawEdges()\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdge(newEdges[i])\r\n                this.edges[newEdges[i]].new = true\r\n                //let tmpe = clone(this.edges[newEdges[i]])\r\n                //tmpe.id = newEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                //addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            this.countEdgeCrossing()\r\n            this.draggedIndex=-1\r\n            this.deletedEdge=[]\r\n            this.addedEdge=[]\r\n            this.setState({\r\n                pointData:this.pointData,\r\n                edges:this.edges\r\n            })\r\n        }\r\n        else{\r\n            let tempedges=[]\r\n            for (let i=0;i<this.edges.length;i++){\r\n                /*                tempedges.push(\r\n                                    {\r\n                                        start:this.edges[i].start,\r\n                                        end:this.edges[i].end,\r\n                                        weight:this.edges[i].weight,\r\n                                        cat:this.edges[i].cat,\r\n                                        dis:this.edges[i].dis,\r\n                                        virtrual:this.edges[i].virtrual,\r\n                                        virtrualNodes:this.edges[i].virtrualNodes,\r\n                                        isLocalTree:this.edges[i].isLocalTree\r\n                                    }\r\n                                )*/\r\n                tempedges.push(this.edges[i])\r\n            }\r\n\r\n            let newEdges=this.recalculateSpanningTreeAfterEdit(tempedges)\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n            // this.drawEdges()\r\n            d3.selectAll(\".deleteOpEdge\")\r\n                .remove()\r\n\r\n            tmpEditEdges = []\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdgeAfterEdit(tempedges,newEdges[i])\r\n                //console.log(\"newEdges:\")\r\n                //console.log(this.edges)\r\n                //console.log(tempedges)\r\n                //console.log(newEdges[i])\r\n                let tmpe = clone(tempedges[newEdges[i]])\r\n                tmpe.id = newEdges[i]\r\n                tmpe.flag = true\r\n                tmpEditEdges.push(tmpe)\r\n            }\r\n            this.tempEdges=tempedges\r\n            // console.log(this.edges.length,this.tempEdges.length)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    sufaceRoutingAll(){\r\n        for (let ei=0;ei<this.edges.length;ei++){\r\n            let thisedge=this.edges[ei]\r\n            let startp=this.pointData[thisedge.start.id]\r\n            let endp=this.pointData[thisedge.end.id]\r\n            let pcat=this.pointData[thisedge.start.id].cat\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[ei].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[ei].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[ei].virtrualNodes=virtrualNodes\r\n        }\r\n\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        if(virtrualNodes.length==0){\r\n            edge.virtrual=false\r\n        }\r\n        return edge\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n\r\n        let crossnum=0\r\n        let start = this.pointData[index1]\r\n        let end = this.pointData[index2]\r\n        for(let e=0;e<this.edges.length;e++){\r\n            let e1=this.pointData[this.edges[e].start]\r\n            let e2=this.pointData[this.edges[e].end]\r\n            if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                crossnum+=1\r\n            }\r\n        }\r\n        //cal distance\r\n        let distance=this.calDistance(start, end)\r\n        //cal num of other points\r\n        let mess=this.calEdgeMess(start, end)\r\n        let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n        newedge.score = score\r\n\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function dragstartControlpoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag start control point!\")\r\n            //console.log(index)\r\n            editEdges = []\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(that.pointData[that.edges[index].start])\r\n            tmpe.endpoint = clone(that.pointData[that.edges[index].end])\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n        }\r\n        function draggedControlPoint(event){\r\n            let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n            that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n            that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n            let idx = \"#\" + d3.select(this).attr(\"id\")\r\n            //console.log(\"dragged control point\")\r\n            //console.log(idx)\r\n            d3.selectAll(idx)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                })\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                })\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n        }\r\n        function dragendControlPoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag end control point!\")\r\n            //console.log(index)\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.id = index\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var dragControlPoint = d3.drag()\r\n            .on(\"start\",dragstartControlpoint)\r\n            .on(\"drag\",draggedControlPoint)\r\n            .on(\"end\",dragendControlPoint)\r\n\r\n        function dragstartEdge(event){\r\n            console.log(\"drag start edge!\")\r\n            // console.log(\"start!\")\r\n            let index=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            let start=that.pointData[that.edges[index].start]\r\n            let end=that.pointData[that.edges[index].end]\r\n\r\n            editEdges = []\r\n//\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(start)\r\n            tmpe.endpoint = clone(end)\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n\r\n            if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=segindex\r\n            }\r\n            else{\r\n                that.edges[index].virtrual=true\r\n                that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=0\r\n            }\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .remove()\r\n\r\n            /*            for (let j=0;j<that.edges[index].SVGElement.length;j++){\r\n                            that.edges[index].SVGElement[j].remove()\r\n                        }*/\r\n\r\n            that.edges[index].SVGElement=[]\r\n\r\n            let vpoints=that.edges[index].virtrualNodes\r\n            let nowp=[start.x,start.y]\r\n            let nextp=[]\r\n            for(let i=0;i<vpoints.length;i++){\r\n                nextp=vpoints[i]\r\n                let newedge=d3.select(svgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n\r\n                d3.select(opsvgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n                that.edges[index].SVGElement.push(newedge)\r\n                nowp=nextp\r\n            }\r\n            let newline=d3.select(svgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n\r\n            that.edges[index].SVGElement.push(newline)\r\n\r\n\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function draggedEdge(event){\r\n            // console.log(\"drag!\")\r\n            if(that.draggedEdgeIndex==-1)\r\n                return\r\n            event.sourceEvent.stopPropagation();\r\n            let edgeIndex=that.draggedEdgeIndex\r\n            let segIndex=that.draggedEdgeSeg\r\n\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n\r\n            d3.selectAll(\".controlPoints\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n\r\n        }\r\n\r\n        function dragendEdge(event){\r\n            // console.log(\"end!\")\r\n            let i = that.draggedEdgeIndex\r\n            let tmpe = clone(that.edges[i])\r\n            tmpe.id = i\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n//\r\n//\r\n            editPoints = []\r\n            editEdges = []\r\n\r\n\r\n            that.draggedEdgeSeg=-1\r\n            that.draggedEdgeIndex=-1\r\n            //that.child.getData()\r\n        }\r\n\r\n        var dragEdge = d3.drag()\r\n            .on(\"start\",dragstartEdge)\r\n            .on(\"drag\",draggedEdge)\r\n            .on(\"end\",dragendEdge)\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                that.setState({\r\n                    hasEdit:true\r\n                })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n\r\n                let tmpe = clone(that.edges[deleteindex])\r\n                tmpe.startpoint = clone(that.pointData[start])\r\n                tmpe.endpoint = clone(that.pointData[end])\r\n                tmpe.flag = false\r\n                editEdges.push(tmpe)\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n                if(that.child.bubbleState()){\r\n                    //console.log(\"delete one edge\")\r\n                    //console.log(editEdges)\r\n                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                }\r\n\r\n\r\n                editPoints = []\r\n                editEdges = []\r\n\r\n                that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n\r\n                that.optimizeMST(true)\r\n\r\n                for (var k in that.catPointDict){\r\n                    that.findCircle(k)\r\n                }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n            //else if(event.button == 1){\r\n            //    that.child.handleEdgeWidth(event, this)\r\n            //}\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    applyEdit(){\r\n        this.edges=this.tempEdges\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n\r\n        this.drawEdges()\r\n        this.setState({\r\n            hasEdit:false,\r\n            edges:this.edges,\r\n            pointData:this.pointData\r\n        })\r\n\r\n        //console.log(\"applyEdit\")\r\n        //console.log(tmpEditEdges)\r\n        //console.log(this.edges)\r\n\r\n        //let tmprealEditEdges = []\r\n//\r\n        //for(let i = 0; i < this.edges.length;i ++){\r\n        //    for(let j = 0; j < tmpEditEdges.length; j ++){\r\n        //        if(this.edges[i].start == tmpEditEdges[j].start && this.edges[i].end == tmpEditEdges[j].end){\r\n        //            let tmpe = clone(this.edges[i])\r\n        //            tmpe.flag = true\r\n        //            tmpe.id = i\r\n        //            tmprealEditEdges.push(tmpe)\r\n        //            break;\r\n        //        }\r\n        //    }\r\n        //}\r\n\r\n        if(this.child.bubbleState()){\r\n            this.child.editReDraw([], tmpEditEdges, this.pointData, this.edges)\r\n        }\r\n\r\n        tmpEditEdges = []\r\n    }\r\n\r\n    drawOneEdgeAfterEdit(edges,index){\r\n\r\n        edges[index].SVGElement=[]\r\n        let oneEdge=edges[index]\r\n        let that=this\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                d3.selectAll(\".deleteOpEdge\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                    })\r\n                    .remove()\r\n                let start=edges[deleteindex].start\r\n                let end=edges[deleteindex].end\r\n                that.deletedEdge.push([start,end])\r\n\r\n                // that.deleteEdge(deleteindex)\r\n                that.optimizeMST(true)\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            // console.log()\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    checkCircle(k){\r\n        let catEdges=[]\r\n        let nodeDegree={}\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(this.edges[i].cat==k){\r\n                catEdges.push(this.edges[i])\r\n                let start=this.edges[i].start\r\n                let end=this.edges[i].end\r\n                if(!nodeDegree.hasOwnProperty(start)){\r\n                    nodeDegree[start]=[]\r\n                }\r\n                nodeDegree[start].push(i)\r\n                if(!nodeDegree.hasOwnProperty(end)){\r\n                    nodeDegree[end]=[]\r\n                }\r\n                nodeDegree[end].push(i)\r\n            }\r\n        }\r\n        let finish=false\r\n        while(!finish){\r\n            finish=true\r\n            for(var p in nodeDegree){\r\n                if(nodeDegree[p].length==1){\r\n                    finish=false\r\n                    let index=nodeDegree[p][0]\r\n                    let start=this.edges[index].start\r\n                    let end=this.edges[index].end\r\n                    for (let i=0;i<nodeDegree[start].length;i++){\r\n                        if(nodeDegree[start][i]==index){\r\n                            nodeDegree[start].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                    for (let i=0;i<nodeDegree[end].length;i++){\r\n                        if(nodeDegree[end][i]==index){\r\n                            nodeDegree[end].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let circleEdges=[]\r\n        for (var p in nodeDegree){\r\n            if(nodeDegree[p].length>0){\r\n                for (let i=0;i<nodeDegree[p].length;i++){\r\n                    let edgeindex=nodeDegree[p][i]\r\n                    let has=false\r\n                    for (let j=0;j<circleEdges.length;j++){\r\n                        if(circleEdges[j]==edgeindex){\r\n                            has=true\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!has){\r\n                        circleEdges.push(edgeindex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        // console.log(nodeDegree,circleEdges)\r\n        return circleEdges\r\n    }\r\n\r\n    findCircle(lastcat){\r\n        let that=this\r\n        let circleEdges=that.checkCircle(lastcat)\r\n        if(circleEdges.length>0){\r\n            let scores=[]\r\n            for (let i=0;i<circleEdges.length;i++){\r\n                let index=circleEdges[i]\r\n\r\n                let start=that.pointData[that.edges[index].start]\r\n                let end=that.pointData[that.edges[index].end]\r\n                let crossnum=0\r\n                if(that.isAdded(that.edges[index].start,that.edges[index].end)){\r\n                    scores.push(-1)\r\n                }\r\n                else{\r\n                    for (let e=0;e<that.edges.length;e++){\r\n                        let e1=that.pointData[that.edges[e].start]\r\n                        let e2=that.pointData[that.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&that.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //cal distance\r\n                    let distance=that.calDistance(start,end)\r\n                    //cal num of other points\r\n                    let mess=that.calEdgeMess(start,end)\r\n                    let score=weightCross*crossnum+weightDistance*distance/that.maxDis+weightMess*mess\r\n                    scores.push(score)\r\n                }\r\n\r\n                /*                                    d3.select(svgid)\r\n                                                        .select(\"#edgeGroup\")\r\n                                                        .selectAll(\"line\")\r\n                                                        .filter(function(){\r\n                                                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                                                        })\r\n                                                        .attr(\"stroke\",\"blue\")\r\n                                                        .on(\"mouseover\",function(){\r\n                                                            console.log(scores[i])\r\n                                                        })*/\r\n            }\r\n\r\n            let worstindex=-1\r\n            let worstscore=-100\r\n            for (let i=0;i<scores.length;i++){\r\n                if(scores[i]>worstscore){\r\n                    worstscore=scores[i]\r\n                    worstindex=i\r\n                }\r\n            }\r\n            let worstEdge=that.edges[circleEdges[worstindex]]\r\n\r\n            //let tmpe = clone(worstEdge)\r\n            //tmpe.startpoint = clone(worstEdge.start)\r\n            //tmpe.endpoint = clone(worstEdge.end)\r\n            //tmpe.flag = false\r\n            //tmpEditEdges.push(tmpe)\r\n\r\n\r\n            //console.log(\"WorstEdge: \")\r\n            //console.log(circleEdges)\r\n            //console.log(worstEdge)\r\n            //console.log(that.edges)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==worstEdge.id\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-width\",5)\r\n            // console.log(weightMess)\r\n\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        d3.selectAll(\"circle\").remove();\r\n        d3.selectAll(\"rect\").remove();\r\n        svg = d3.select(svgid);\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        var reroutingEPS=80\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            console.log(\"dragging points......\")\r\n            let svg=d3.select(svgid)\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            // console.log(POINT_EDGE_EPS,DBSCAN_EPS)\r\n            if(that.itemShape==\"circle\"){\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n            //let tmpp1 = clone(that.pointData[nodeindex])\r\n            //tmpp1.flag = false;\r\n            //editPoints.push(tmpp1)\r\n            //subOldPoints.push(tmpp1)\r\n\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n\r\n            //let tmpp = clone(that.pointData[nodeindex])\r\n            //tmpp.id = nodeindex\r\n            //tmpp.flag = true\r\n            //editPoints.push(tmpp)\r\n            //addNewPoints.push(tmpp)\r\n\r\n            let deleteEdges=[]\r\n            let reroutingEdges=[]\r\n            let thiscat=that.pointData[nodeindex].cat\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let startpoint=that.pointData[that.edges[i].start]\r\n                let endpoint=that.pointData[that.edges[i].end]\r\n                let pointedgedis=PointToSegDist(event.x,event.y,startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(that.edges[i].start==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(tmpp1)\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(that.edges[i].end==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(tmpp1)\r\n                    //tmpe.flag = false;\r\n                    ////subOldEdges.push(tmpe)\r\n                    //editEdges.push(tmpe)\r\n                }\r\n                else if((thiscat==that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2)){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n                else if(thiscat!=that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2){\r\n                    reroutingEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // console.log(deleteEdges)\r\n\r\n            for(let i=0;i<deleteEdges.length;i++){\r\n                that.deleteEdge(deleteEdges[i])\r\n                for(let j=i+1;j<deleteEdges.length;j++){\r\n                    if(deleteEdges[i]<deleteEdges[j]){\r\n                        deleteEdges[j]=deleteEdges[j]-1\r\n                    }\r\n                }\r\n                for(let j=i+1;j<reroutingEdges.length;j++){\r\n                    if(deleteEdges[i]<reroutingEdges[j]){\r\n                        reroutingEdges[j]=reroutingEdges[j]-1\r\n                    }\r\n                }\r\n            }\r\n\r\n            that.optimizeMST(false)\r\n\r\n            for (let i=0;i<reroutingEdges.length;i++){\r\n\r\n\r\n                let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                tmpe.startpoint = clone(that.pointData[tmpe.start])\r\n                tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                tmpe.flag = false\r\n                that.edges[reroutingEdges[i]].preEdge = clone(tmpe)\r\n                that.edges[reroutingEdges[i]].new = true\r\n                that.edges[reroutingEdges[i]].rerouting = true\r\n\r\n\r\n                that.surfaceRoutingEdge(that.edges[reroutingEdges[i]])\r\n                d3.selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n                d3.selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n\r\n                that.drawOneEdge(reroutingEdges[i])\r\n\r\n\r\n\r\n                //let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                //tmpe.id = reroutingEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                // addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            //that.child.getData()\r\n            //for(let idx1 = 0; idx1 < addNewPoints.length; idx1 ++){\r\n            //    for(let idx2 = 0; idx2 < that.edges.length; idx2 ++){\r\n            //        if(that.edges[idx2].start == addNewPoints[idx1].id || that.edges[idx2].end == addNewPoints[idx1].id){\r\n            //            let tmpe = clone(that.edges[idx2])\r\n            //            tmpe.id = idx2\r\n            //            addNewEdges.push(tmpe)\r\n            //            //console.log(\"flagflagflag\")\r\n            //        }\r\n            //    }\r\n            //}\r\n\r\n\r\n\r\n\r\n\r\n            // d3.select(this).attr(\"stroke\",\"none\")\r\n\r\n        }\r\n\r\n        function dragstart() {\r\n            console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            // that.draggedIndex=parseInt(d3.select(this).attr(\"index\"))\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n            that.draggedIndex=nodeindex\r\n\r\n            preEdgeDict = {}\r\n            preEdges = []\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                that.edges[i].new = false;\r\n                that.edges[i].rerouting = false;\r\n                that.edges[i].startpoint = clone(that.pointData[st])\r\n                that.edges[i].endpoint = clone(that.pointData[en])\r\n\r\n                if(!preEdgeDict.hasOwnProperty(st)){\r\n                    preEdgeDict[st] = {}\r\n                }\r\n                preEdgeDict[st][en] = i\r\n\r\n                preEdges.push(that.edges[i])\r\n            }\r\n\r\n            // add old point\r\n            let tmpp1 = clone(that.pointData[nodeindex])\r\n            prePoint = tmpp1\r\n            tmpp1.flag = false\r\n            editPoints.push(tmpp1)\r\n\r\n            //preEdges = clone(that.edges)\r\n\r\n            //delete linked edges\r\n            /*            let newedges=[]\r\n            let deleteindex=[]\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let start=that.edges[i].start\r\n                let end=that.edges[i].end\r\n                if(start==nodeindex||end==nodeindex){\r\n                    console.log(i)\r\n                    d3.select(svgid)\r\n                        .select(\"#edgeGroup\")\r\n                        .selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==i\r\n                        })\r\n                        // .attr(\"stroke\",\"red\")\r\n                        .remove()\r\n                    deleteindex.push(i)\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))==i\r\n                        })\r\n                        // .attr(\"opacity\",1)\r\n                        .remove()\r\n                }\r\n                else{\r\n                    newedges.push(that.edges[i])\r\n                }\r\n            }\r\n            let influencedEdges=[]\r\n            let influencedControlPoints=[]\r\n            for (let i=0;i<deleteindex.length;i++) {\r\n                let idx=deleteindex[i]\r\n                let inflines=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))>idx\r\n                    })\r\n                influencedEdges.push(inflines)\r\n\r\n                let infpoints=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))>idx\r\n                    })\r\n                influencedControlPoints.push(infpoints)\r\n            }\r\n                for (let i=0;i<influencedEdges.length;i++){\r\n                    let infedges=influencedEdges[i]\r\n                    infedges.attr(\"index\",function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                    })\r\n            }\r\n                for(let i=0;i<influencedControlPoints.length;i++){\r\n                    let infcpoints=influencedControlPoints[i]\r\n                    infcpoints.attr(\"edgeindex\",function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                        })\r\n                }\r\n\r\n            that.edges=newedges\r\n            for(let i=0;i<that.edges.length;i++){\r\n                that.edges[i].id=i\r\n            }*/\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        function dragend(){\r\n            console.log(\"end!\")\r\n            let nodeindex = parseInt(d3.select(this).attr(\"index\"))\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"none\")\r\n\r\n            // add new point\r\n            let tmpp = clone(that.pointData[nodeindex])\r\n            tmpp.id = nodeindex\r\n            tmpp.flag = true\r\n            editPoints.push(tmpp)\r\n\r\n            /*\r\n            // delete old edges\r\n            let thiscat = that.pointData[nodeindex].cat\r\n            let ex = that.pointData[nodeindex].x\r\n            let ey = that.pointData[nodeindex].y\r\n            //let updateidx = {}\r\n            for(let i = 0;i < preEdges.length; i ++){\r\n                let startpoint=that.pointData[preEdges[i].start]\r\n                let endpoint=that.pointData[preEdges[i].end]\r\n                let pointedgedis=PointToSegDist(ex, ey, startpoint.x, startpoint.y, endpoint.x, endpoint.y)\r\n                if(preEdges[i].start==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = clone(prePoint)\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(preEdges[i].end==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = clone(prePoint)\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if((thiscat == preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2)){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false;\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                    //    updateidx[preEdges[i].start] = {}\r\n                    //}\r\n//\r\n                    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n\r\n                }\r\n\r\n                //else if(thiscat != preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2){\r\n//\r\n                //    let tmpe = clone(preEdges[i])\r\n                //    tmpe.startpoint = that.pointData[tmpe.start]\r\n                //    tmpe.endpoint = that.pointData[tmpe.end]\r\n                //    tmpe.flag = false;\r\n                //    editEdges.push(tmpe)\r\n                //    //subOldEdges.push(tmpe)\r\n//\r\n                //    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                //    //    updateidx[preEdges[i].start] = {}\r\n                //    //}\r\n////\r\n                //    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n//\r\n                //}\r\n\r\n\r\n            }\r\n\r\n            // add new edges and rerouting edges\r\n            for(let i = 0;i < that.edges.length; i ++){\r\n\r\n                //if(that.edges[i].hasOwnProperty(\"new\")){\r\n                if(that.edges[i].new == true){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    if(that.edges[i].rerouting == true){\r\n                        let tmpe = clone(that.edges[i].preEdge)\r\n                        tmpe.flag = false\r\n                        editEdges.push(tmpe)\r\n                    }\r\n                }\r\n                //}\r\n\r\n\r\n                //let s = that.edges[i].start\r\n                //let e = that.edges[i].end\r\n                //let flag = false;\r\n                //if(s == nodeindex || e == nodeindex){\r\n                //    flag = true\r\n                //}\r\n//\r\n                //for(let st in updateidx){\r\n                //    for(let en in updateidx[st]){\r\n                //        if(s == st && e == en){\r\n                //            flag = true\r\n                //            break\r\n                //        }\r\n                //    }\r\n                //}\r\n//\r\n                //if(flag){\r\n                //    let tmpe = clone(that.edges[i])\r\n                //    tmpe.id = i\r\n                //    tmpe.flag = true\r\n                //    editEdges.push(tmpe)\r\n                //}\r\n\r\n\r\n            }\r\n\r\n             */\r\n\r\n            editEdges = []\r\n            curEdgeDict = {}\r\n\r\n            // Add New Edges\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                if(!curEdgeDict.hasOwnProperty(st)){\r\n                    curEdgeDict[st] = {}\r\n                }\r\n                curEdgeDict[st][en] = i\r\n                let vnodes1 = clone(that.edges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                // same flag\r\n                let flag = true\r\n                // exist flag\r\n                let flag1 = true\r\n                // judge st --> en\r\n                if(preEdgeDict.hasOwnProperty(st)){\r\n                    if(preEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag point?\r\n                        // startpoint\\endpoint\\control points\r\n                        let idx = preEdgeDict[st][en]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].startpoint\r\n                        let en2_p = preEdges[idx].endpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                //judge en --> st\r\n                if(preEdgeDict.hasOwnProperty(en)){\r\n                    if(preEdgeDict[en].hasOwnProperty(st)){\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag poing?\r\n                        flag1 = false\r\n                        let idx = preEdgeDict[en][st]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].endpoint\r\n                        let en2_p = preEdges[idx].startpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // Delete Old Edges\r\n            for(let i = 0; i < preEdges.length; i ++){\r\n                let st = preEdges[i].start\r\n                let en = preEdges[i].end\r\n                let vnodes1 = clone(preEdges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                let flag = true\r\n                let flag1 = true\r\n                if(curEdgeDict.hasOwnProperty(st)){\r\n                    if(curEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[st][en]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                if(curEdgeDict.hasOwnProperty(en)){\r\n                    if(curEdgeDict[en].hasOwnProperty(st)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[en][st]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",dragend)\r\n\r\n\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2 && !that.props.isedit){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                    let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                    d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                        let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n\r\n                                let tmpe = clone(that.edges[that.edges.length - 1])\r\n                                tmpe.id = that.edges.length - 1\r\n                                tmpe.flag = true\r\n                                editEdges.push(tmpe)\r\n                                that.setState({\r\n                                    pointData: that.pointData\r\n                                })\r\n\r\n                                that.setState({\r\n                                    edges: that.edges\r\n                                })\r\n\r\n                                //console.log(that.edges)\r\n\r\n                                if(that.child.bubbleState()){\r\n                                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                                }\r\n\r\n                                editPoints = []\r\n                                editEdges = []\r\n\r\n\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n\r\n                            idx = \"#\" + d3.select(this).attr(\"id\")\r\n\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n                                .attr(\"id\",d3.select(this).attr(\"id\"))\r\n\r\n\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(event.button==2 && that.props.isedit){\r\n\r\n                let idx = parseInt(d3.select(event.path[0]).attr(\"index\"))\r\n\r\n                // delete node and edges\r\n                let catarray = that.pointData[idx].catArray\r\n                for(let c = 0; c < catarray.length; c ++){\r\n                    let nowcat = catarray[c]\r\n                    for(let j = 0; j < that.catPointDict[nowcat].length; j ++){\r\n                        if(that.catPointDict[nowcat][j].id == idx){\r\n                            that.catPointDict[nowcat].splice(j, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for(let i = that.edges.length - 1; i >= 0; i --){\r\n                    let st = that.edges[i].start\r\n                    let en = that.edges[i].end\r\n                    if(st == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                    else if(en == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                }\r\n\r\n                that.pointData.splice(idx, 1);\r\n\r\n                // modify svg index and data index\r\n                d3.selectAll(\"#edgeGroup\").remove()\r\n                d3.selectAll(\"#pointGroup\").remove()\r\n\r\n                for(let i = 0; i < that.pointData.length; i ++){\r\n                    if(that.pointData[i].id > idx){\r\n                        that.pointData[i].id -= 1\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < that.edges.length; i ++){\r\n                    if(that.edges[i].start > idx){\r\n                        that.edges[i].start -= 1\r\n                    }\r\n                    if(that.edges[i].end > idx){\r\n                        that.edges[i].end -= 1\r\n                    }\r\n                }\r\n\r\n                that.drawPointData()\r\n                that.drawEdges()\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n\r\n                console.log(\"delete pointdata!\")\r\n\r\n            }\r\n        }\r\n\r\n        let items=[]\r\n        d3.select(svgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        d3.select(opsvgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        // this.itemShape=\"circle\"\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                        console.log(that.pointData[index])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    countEdgeCrossingWithRouting(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let lines1=[]\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vnodes=this.edges[i].virtrualNodes\r\n                lines1.push([start1.x,start1.y])\r\n                for (let p=0;p<vnodes.length;p++){\r\n                    lines1.push(vnodes[p])\r\n                }\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            else{\r\n                lines1.push([start1.x,start1.y])\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let lines2=[]\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat==start2.cat){\r\n                    continue\r\n                }\r\n                if(this.edges[j].virtrual){\r\n                    let vnodes=this.edges[j].virtrualNodes\r\n                    lines2.push([start2.x,start2.y])\r\n                    for (let p=0;p<vnodes.length;p++){\r\n                        lines2.push(vnodes[p])\r\n                    }\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                else{\r\n                    lines2.push([start2.x,start2.y])\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                for (let l1=0;l1<lines1.length-1;l1++){\r\n                    let p1={x:lines1[l1][0],y:lines1[l1][1]}\r\n                    let p2={x:lines1[l1+1][0],y:lines1[l1+1][1]}\r\n                    for (let l2=0;l2<lines2.length-1;l2++){\r\n                        let p3={x:lines2[l2][0],y:lines2[l2][1]}\r\n                        let p4={x:lines2[l2+1][0],y:lines2[l2+1][1]}\r\n                        if(this.checkEdgeCrossing(p1,p2,p3,p4)){\r\n                            count+=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n        console.log(\"num of edge crossing:\" +count)\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"num of edge crossing: \"+count)\r\n    }\r\n\r\n    createLocalTree(points){\r\n\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                    virtrual:false,\r\n                    virtrualNodes:[],\r\n                    cat:points[i].cat,\r\n                    isLocalTree:true\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // console.log(this.edges)\r\n        /*        var g = new jsgraphs.Graph(this.pointData.length);\r\n                for (let i=0;i<g.V;i++){\r\n                    g.node(i).label=this.pointData[i].cat\r\n                }*/\r\n\r\n    }\r\n\r\n    initWithNoCluster(){\r\n        for(var k in this.catPointDict){\r\n            this.clusterDict[k]=[]\r\n            for (let i=0;i<this.catPointDict[k].length;i++){\r\n                this.clusterDict[k].push([this.catPointDict[k][i]])\r\n            }\r\n        }\r\n        console.log(this.clusterDict)\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        // this.findCluster()\r\n        this.initWithNoCluster()\r\n        //merging clusters according to this.edges\r\n\r\n        let preAddedClusters=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            let cat=start.cat\r\n            let catclusters=this.clusterDict[cat]\r\n            let startclusterid=-1\r\n            let endclusterid=-1\r\n            for(let c=0;c<catclusters.length;c++){\r\n                for (let p=0;p<catclusters[c].length;p++){\r\n                    if(catclusters[c][p].id==start.id){\r\n                        startclusterid=c\r\n                    }\r\n                    if(catclusters[c][p].id==end.id){\r\n                        endclusterid=c\r\n                    }\r\n                    if(startclusterid!=-1&&endclusterid!=-1){\r\n                        break\r\n                    }\r\n                }\r\n                if(startclusterid!=-1&&endclusterid!=-1){\r\n                    break\r\n                }\r\n\r\n            }\r\n            if(startclusterid!=-1&&endclusterid!=-1&&startclusterid!=endclusterid){\r\n                // console.log(this.clusterDict[cat].length)\r\n\r\n                //merge two cluster\r\n                let merged=catclusters[startclusterid]\r\n                for(let p=0;p<catclusters[endclusterid].length;p++){\r\n                    merged.push(catclusters[endclusterid][p])\r\n                }\r\n                let newclusterdict=[]\r\n                for (let c=0;c<catclusters.length;c++){\r\n                    if(c!=startclusterid&&c!=endclusterid){\r\n                        newclusterdict.push(catclusters[c])\r\n                    }\r\n                }\r\n                newclusterdict.push(merged)\r\n                this.clusterDict[cat]=newclusterdict\r\n                preAddedClusters.push([cat,newclusterdict.length-1])\r\n                console.log(cat)\r\n            }\r\n\r\n        }\r\n\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let iscontinue=false\r\n                for (let c=0;c<preAddedClusters.length;c++){\r\n                    let cat=preAddedClusters[c][0]\r\n                    let id=preAddedClusters[c][1]\r\n                    if(k==cat&&id==i){\r\n                        iscontinue=true\r\n                    }\r\n                }\r\n                if(iscontinue){\r\n                    continue\r\n                }\r\n                else{\r\n                    this.createLocalTree(this.clusterDict[k][i])\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.clusterDict)\r\n        // console.log(this.edges.length)\r\n\r\n        this.drawEdges()\r\n        this.hierarchicalMergeV2()\r\n        // console.log(this.edges.length)\r\n    }\r\n\r\n    findCluster(){\r\n\r\n        for (var k in this.catPointDict){\r\n            // console.log(k)\r\n\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                // if(this.pointData[this.catPointDict[k][i].id].multicat){\r\n                //     let catarr=this.pointData[this.catPointDict[k][i].id].catArray\r\n                //     catarr=catarr.map((val)=> parseInt(val) )\r\n                //     let minCatIndex=Math.min.apply(null,catarr)\r\n                //     if(parseInt(k)==minCatIndex){\r\n                //         dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                //         pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                //     }\r\n                // }\r\n                // else{\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                // }\r\n\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n\r\n            if(dataset.length>0){\r\n                this.clusterDict[k]=[]\r\n                this.noiseDict[k]=[]\r\n                var clusters = dbscan.run(dataset, DBSCAN_EPS, 2);\r\n                // console.log(clusters, dbscan.noise);\r\n                let point\r\n                for(let i=0;i<clusters.length;i++){\r\n                    let clusterPoints=[]\r\n                    for (let j=0;j<clusters[i].length;j++){\r\n                        clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                        // console.log(point)\r\n                        /*                    let point=dataset[clusters[i][j]]\r\n                                            d3.select(svgid)\r\n                                                .append(\"circle\")\r\n                                                .attr(\"cx\",point[0])\r\n                                                .attr(\"cy\",point[1])\r\n                                                .attr(\"r\",10)\r\n                                                .attr(\"fill\",\"none\")\r\n                                                .attr(\"stroke\",\"red\")\r\n                                                .attr(\"stroke-width\",2)*/\r\n                    }\r\n                    // this.createLocalTree(clusterPoints)\r\n                    this.clusterDict[k].push(clusterPoints)\r\n                }\r\n                for (let i=0;i<dbscan.noise.length;i++){\r\n                    this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n                }\r\n            }\r\n\r\n        }\r\n        //console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraph(){\r\n\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n\r\n\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        //console.log(this.clusterDict)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n        console.log(g.V)\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n        //console.log(g,g2)\r\n        for (let i=0;i<this.edges.length;i++){\r\n            this.graph.addEdge(this.edges[i].start,this.edges[i].end)\r\n        }\r\n\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    /*    findOptimalLink(cluster1,cluster2){\r\n            //let crossedge = []\r\n            let minScore=Number.MAX_VALUE\r\n            let bestStart=null\r\n            let bestEnd=null\r\n\r\n            let minScoreWithDis=Number.MAX_VALUE\r\n            let bestStartWithDis=null\r\n            let bestEndWithDis=null\r\n\r\n            let hasBest=false\r\n            for (let i=0;i<cluster1.length;i++){\r\n                let start=cluster1[i]\r\n                for(let j=0;j<cluster2.length;j++){\r\n                    let end=cluster2[j]\r\n                    //cal cross num\r\n                    let crossnum=0\r\n                    for (let e=0;e<this.edges.length;e++){\r\n                        let e1=this.pointData[this.edges[e].start]\r\n                        let e2=this.pointData[this.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //let tmpcross = [];\r\n\r\n                    //let elements = this.QTree.retrieve({\r\n                    //    x: Math.min(start.x,end.x),\r\n                    //    y: Math.min(start.y,end.y),\r\n                    //    width: Math.abs(start.x-end.x),\r\n                    //    height: Math.abs(start.y-end.y)\r\n                    //});\r\n\r\n                    //for (let e = 0;e < elements.length;e ++){\r\n                    //    let e1 = this.pointData[elements[e].start];\r\n                    //    let e2 = this.pointData[elements[e].end];\r\n                    //    if(e1.cat != start.cat && e1.cat != end.cat && this.checkEdgeCrossing(start,end,e1,e2)){\r\n                    //        crossnum += 1\r\n                    //        //tmpcross.push({start:this.edges[e].start,end:this.edges[e].end})\r\n                    //        //tmpcross.push({start:this.edges[e].end,end:this.edges[e].start})\r\n                    //    }\r\n                    //}\r\n                    //crossnum = 5;\r\n\r\n                    //cal distance\r\n                    let distance=this.calDistance(start,end)\r\n\r\n\r\n                    //cal num of other points\r\n                    let mess=this.calEdgeMess(start,end)\r\n\r\n                    if(crossnum>maxCross){\r\n                        maxCross=crossnum\r\n                    }\r\n\r\n                    let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                    if(score<minScore){\r\n                        bestStart=start\r\n                        bestEnd=end\r\n                        minScore=score\r\n                        //crossedge = tmpcross\r\n                    }\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        if(score<minScoreWithDis){\r\n                            bestStartWithDis=start\r\n                            bestEndWithDis=end\r\n                            minScoreWithDis=score\r\n                            hasBest=true\r\n                            //crossedge = tmpcross\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            /!*      if(hasBest){\r\n                        // console.log(\"edge under threshhold\")\r\n                        return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                    }\r\n                    else{\r\n                        // console.log(\"no edge under threshhold\")\r\n                        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                    }*!/\r\n            return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n        }*/\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let minScore=Number.MAX_VALUE\r\n        let bestStart=null\r\n        let bestEnd=null\r\n\r\n        let minScoreWithDis=Number.MAX_VALUE\r\n        let bestStartWithDis=null\r\n        let bestEndWithDis=null\r\n\r\n        let hasBest=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n\r\n\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n\r\n                if(crossnum>maxCross){\r\n                    maxCross=crossnum\r\n                }\r\n\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                if(score<minScore){\r\n                    bestStart=start\r\n                    bestEnd=end\r\n                    minScore=score\r\n                }\r\n                if(distance<DISTANCE_THRESHHOLD){\r\n                    if(score<minScoreWithDis){\r\n                        bestStartWithDis=start\r\n                        bestEndWithDis=end\r\n                        minScoreWithDis=score\r\n                        hasBest=true\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*        if(hasBest){\r\n                    // console.log(\"edge under threshhold\")\r\n                    return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                }\r\n                else{\r\n                    // console.log(\"no edge under threshhold\")\r\n                    return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                }*/\r\n        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n    }\r\n\r\n    /*    findMinScore(links){\r\n            let minScore=Number.MAX_VALUE\r\n            let minIndex=-1\r\n\r\n            let minScoreWithDistance=Number.MAX_VALUE\r\n            let minIndexWithDistance=-1\r\n            let hasBest=false\r\n            for(let i=0;i<links.length;i++){\r\n                if(links[i].score<minScore){\r\n                    minScore=links[i].score\r\n                    minIndex=i\r\n                }\r\n                if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                    minScoreWithDistance=links[i].score\r\n                    minIndexWithDistance=i\r\n                    hasBest=true\r\n                }\r\n            }\r\n            if(hasBest){\r\n                // console.log(\"yes\")\r\n                return links[minIndexWithDistance]\r\n            }\r\n            else{\r\n                // console.log(\"no\")\r\n                return links[minIndex]\r\n\r\n            }\r\n\r\n            // return links[minIndex]\r\n\r\n        }*/\r\n\r\n    findMinScoreTest(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=links.length-1;i>=0;i--) {\r\n            let id1 = links[i].clusterid1\r\n            let id2 = links[i].clusterid2\r\n            if(this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                continue;\r\n            }\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findMinScore(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=0;i<links.length;i++){\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isAdded(start,end){\r\n        for (let i=0;i<this.addedEdge.length;i++){\r\n            if(this.addedEdge[i][0]==start&&this.addedEdge[i][1]==end||this.addedEdge[i][0]==end&&this.addedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isDeleted(start,end){\r\n        for (let i=0;i<this.deletedEdge.length;i++){\r\n            if(this.deletedEdge[i][0]==start&&this.deletedEdge[i][1]==end||this.deletedEdge[i][0]==end&&this.deletedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    addLinksTest(id1,id2,k,cluster1,cluster2,e){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n                let distance=this.calDistance(start,end)\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n                e.push(tmp)\r\n                this.idx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    addLinks(id1,id2,k,cluster1,cluster2,e1,e2){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n\r\n                if(this.isDeleted(start.id,end.id)){\r\n                    tmp.score=Number.MAX_VALUE\r\n                    e2._d[this.idx] = tmp;\r\n                    e2.enq(this.idx);\r\n                    this.idx++;\r\n\r\n                }\r\n                else if(this.isAdded(start.id,end.id)){\r\n                    tmp.score=-1\r\n                    e1._d[this.idx] = tmp;\r\n                    e1.enq(this.idx);\r\n                    this.idx++;\r\n                }\r\n                else{\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        //V1\r\n                        //tmp.pid = e1._elements.length;\r\n\r\n                        e1._d[this.idx] = tmp;\r\n                        e1.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                    else{\r\n                        //V1\r\n                        //tmp.pid = e2._elements.length;\r\n\r\n                        e2._d[this.idx] = tmp;\r\n                        e2.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                }\r\n                //let nodetmp = {\r\n                //    x:Math.min(start.x,end.x),\r\n                //    y:Math.min(start.y,end.y),\r\n                //    width:Math.abs(start.x - end.x),\r\n                //    height:Math.abs(start.y - end.y),\r\n                //    idx:this.idx\r\n                //}\r\n                //this.edgesdict.push(nodetmp);\r\n                //this.QTree.insert(this.edgesdict[this.idx]);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    findBestLink(e){\r\n        let minScore = Number.MAX_VALUE;\r\n        let tmp;\r\n        for(let i = e.length - 1;i >= 0;i --){\r\n            let id1 = e[i].clusterid1;\r\n            let id2 = e[i].clusterid2;\r\n            if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                if(minScore > e[i].score){\r\n                    tmp = e[i];\r\n                    minScore = e[i].score;\r\n                }\r\n            }\r\n            else{\r\n                e.splice(i, 1);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    recalculateSpanningTreeAfterEdit(edges){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                edges[edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        edges[edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<edges.length;i++){\r\n                                let start1=this.pointData[edges[i].start]\r\n                                let end1=this.pointData[edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            edges[edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    recalculateSpanningTree(){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(this.edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    hierarchicalMergeV2(){\r\n\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllClusterV2()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            this.drawEdges()\r\n            console.log()\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n/*                        d3.selectAll(\"line\")\r\n                            .remove()\r\n                        // .attr(\"stroke\",\"black\")\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",startp[0])\r\n                            .attr(\"y1\",startp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",endp[0])\r\n                            .attr(\"y1\",endp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")*/\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",endp[0])\r\n                    .attr(\"y1\",endp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n            this.drawOneEdge(this.edges.length-1)\r\n            console.log()\r\n        }\r\n        //console.log(maxCross)\r\n    }\r\n\r\n    hierarchicalMerge(){\r\n        // console.log(this.calDistance(this.pointData[120],this.pointData[171]))\r\n        // console.log(this.calDistance(this.pointData[47],this.pointData[188]))\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            let optimalLinks=[]\r\n            for (var k in this.clusterDict){\r\n                for (let i=0;i<this.clusterDict[k].length;i++){\r\n                    let id1=this.clusterDict[k][i].id\r\n                    for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                        let id2=this.clusterDict[k][j].id\r\n                        if(!this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                            let link=this.findOptimalLink(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                            optimalLinks.push({\r\n                                clusterid1:id1,\r\n                                clusterid2:id2,\r\n                                start:link[0],\r\n                                end:link[1],\r\n                                score:link[2],\r\n                                distance:link[3],\r\n                                cat:k\r\n                            })\r\n                        }\r\n                        else{\r\n                            continue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let bestLink=this.findMinScore(optimalLinks)\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2)\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n\r\n            // this.drawEdges()\r\n\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        //     // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n        }\r\n        console.log(maxCross)\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n        console.log(this.graph)\r\n        console.log(this.edges)\r\n        console.log(removeEdggeList)\r\n\r\n    }\r\n\r\n    editBackbone(){\r\n\r\n        editView = !editView\r\n\r\n        if(editView){\r\n            d3.select(\"svg\")\r\n                .selectAll(\".dataPoint\")\r\n                .remove()\r\n//\r\n            d3.select(\"svg\")\r\n                .selectAll(\"line\")\r\n                .remove()\r\n\r\n            //offsetX = 20;\r\n            //offsetY = 20;\r\n            //viewWidth = 40;\r\n            //viewHeight = 40\r\n//\r\n            //this.child.setViewBox(offsetX, offsetY, viewWidth, viewHeight)\r\n            //d3.select(\"#mainsvg\")\r\n            //    .attr(\"viewBox\",offsetX+\" \"+offsetY+\" \"+viewWidth+\" \"+viewHeight)\r\n\r\n            /*\r\n            let tx,ty,s\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                for(let i = 0; i < infostr.length; i ++){\r\n                    if(infostr[i] == '('){\r\n                        i ++\r\n                        while(infostr[i] != ','){\r\n                            tx += infostr[i ++]\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            ty += infostr[i ++]\r\n                        }\r\n                        while(infostr[i] != '('){\r\n                            i ++\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            s += infostr[i ++]\r\n                        }\r\n                        break\r\n                    }\r\n                }\r\n                tx = parseFloat(tx)\r\n                ty = parseFloat(ty)\r\n                s = parseFloat(s)\r\n            }\r\n\r\n             */\r\n\r\n\r\n            // d3.select(svgid).selectAll(\"*\").remove();\r\n            this.drawPointData()\r\n            this.drawEdges()\r\n\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                d3.selectAll('g').attr(\"transform\", infostr);\r\n            }\r\n\r\n            this.props.handleManually(false)\r\n            //this.child.getData()\r\n        }\r\n        else{\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n            //d3.selectAll(\"\")\r\n        }\r\n    }\r\n\r\n    editMST(){\r\n\r\n        this.issplit = !this.issplit;\r\n\r\n        if(this.issplit == true){\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n                .attr(\"style\",\"border:1px solid #000000\")\r\n\r\n            svgid = \"#leftsvg\"\r\n            opsvgid = '#mainsvg'\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n\r\n            this.drawPointData()\r\n\r\n            this.drawEdges()\r\n\r\n            this.props.handleManually(false)\r\n\r\n            //this.setState({\r\n            //    pointData: this.pointData\r\n            //})\r\n            //this.setState({\r\n            //    edges: this.edges\r\n            //})\r\n            //this.setState({\r\n            //    hasinit:true\r\n            //})\r\n//\r\n            //this.child.getData()\r\n\r\n        }\r\n        else{\r\n\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",1200 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",0)\r\n                .attr(\"height\",0)\r\n                .attr(\"style\",\"border:0px solid #000000\")\r\n\r\n            svgid = \"#mainsvg\"\r\n            opsvgid = '#leftsvg'\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleCreated(){\r\n        this.setState({\r\n            hascreated:true\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    saveSVG(){\r\n\r\n    }\r\n\r\n    saveData(){\r\n        let data\r\n        if(!this.state.hasinit){\r\n            data=this.props.pointData\r\n        }\r\n        else{\r\n            data=this.pointData\r\n        }\r\n        let content = JSON.stringify(data);\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"data.json\");\r\n\r\n    }\r\n\r\n    render(){\r\n        //return (\r\n        //    <div id={\"svgcontainer\"}>\r\n        //        <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n        //        </svg>\r\n        //        <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n        //        <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n        //    </div>)\r\n        return (\r\n            <div>\r\n                <div>\r\n                    {/*<Button onClick={this.saveData.bind(this)}>Save Data</Button>*/}\r\n                    {/*<Button onClick={this.saveSVG}>Save SVG</Button>*/}\r\n\r\n                </div>\r\n                <div style={{marginTop: 20 * ScreenHeight / BeforeHeight}}>\r\n                        <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData&&!this.state.hasinit||this.state.hasEdit? false:true}>\r\n                        {\r\n                            this.state.hasinit? \"Apply Changes\":\"Create Backbone\"\r\n                        }\r\n                    </Button>\r\n                    &nbsp;&nbsp;<Switch checkedChildren=\"Edit Backbone\" unCheckedChildren=\"Edit Backbone\"  onClick={this.editBackbone.bind(this)}  disabled={this.state.hascreated? false:true}/>\r\n                    &nbsp;&nbsp;<Switch checkedChildren=\"Backbone View\" unCheckedChildren=\"Backbone View\" disabled={this.state.hascreated? false:true} onClick={this.editMST.bind(this)} />\r\n                    </div>\r\n\r\n                <AdaptiveIsovalue pointData={this.state.pointData} hasLoadData={this.props.hasLoadData} edges={this.state.edges} handleCreated={this.handleCreated.bind(this)} createMST={this.getData.bind(this)} onRef={this.onRef}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default HierarchicalCluster","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport * as d3 from \"d3\"\r\nimport \"./scale-canvas\"\r\nimport scaleCanvas from \"./scale-canvas\";\r\n\r\nvar colors=['#f700ff','#fbb132','#0885c2','#001aff','#7b28b7','#1c8b3c','#ed334e']\r\n\r\nclass BMOAlgo extends Component{\r\n    constructor() {\r\n        super();\r\n        this.pointData=[]\r\n        this.itemShape=\"rectangle\"\r\n        this.catPointDict={}\r\n        this.context=null\r\n        this.canvasWidth=1500\r\n        this.canvasHeight=1200\r\n        this.canvasRatio=1\r\n    }\r\n\r\n    componentDidMount() {\r\n        fetch('/data/BubbleSetExample1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n\r\n                    this.pointData[i].id=i\r\n\r\n\r\n                    if(!this.catPointDict.hasOwnProperty(this.pointData[i].cat)){\r\n                        this.catPointDict[this.pointData[i].cat]=[]\r\n                    }\r\n                    this.catPointDict[this.pointData[i].cat].push(this.pointData[i])\r\n                }\r\n                console.log(this.catPointDict)\r\n\r\n\r\n                this.init()\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                this.loadEdgeData()\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        console.log(data)\r\n                        this.edges=data\r\n                        for (let i=0;i<this.edges.length;i++){\r\n                            this.edges[i].start=parseInt(this.edges[i].start)\r\n                            this.edges[i].end=parseInt(this.edges[i].end)\r\n\r\n                        }\r\n                        this.drawEdges()\r\n                        this.getPixelImage()\r\n\r\n                    })\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPixelImage(){\r\n        console.log(this.canvasRatio)\r\n\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(imageX,imageY,imageWidth,imageHeight)\r\n        // this.context.stroke()\r\n\r\n        // console.log(imageWidth,imageHeight)\r\n        let imageData=this.context.getImageData(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n        // let data=imageData.data\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n\r\n\r\n        for (let i=0;i<imageData.data.length;i+=4){\r\n            // if(imageData.data[i]>0||imageData.data[i+1]>0||imageData.data[i+2]>0){\r\n                if(imageData.data[i+3]>0){\r\n\r\n                    // console.log(imageData.data[i],imageData.data[i+1],imageData.data[i+2])\r\n                // console.log(i)\r\n                // imageData.data[i]=255\r\n                // imageData.data[i+1]=0\r\n                // imageData.data[i+2]=0\r\n                let index=i/4\r\n                let x=index%imageData.width\r\n                let y=parseInt(index/imageData.width)\r\n                // imageData.data[i+3]=0\r\n                if(y<miny){\r\n                    miny=y\r\n                }\r\n            if(y>maxy){\r\n                maxy=y\r\n            }\r\n            if(x<minx){\r\n                minx=x\r\n            }\r\n            if(x>maxx){\r\n                maxx=x\r\n            }\r\n            }\r\n        }\r\n        // this.context.strokeStyle=\"red\"\r\n        // this.context.lineWidth=2\r\n        // this.context.rect(minx,miny,maxx-minx,maxy-miny)\r\n        // this.context.stroke()\r\n\r\n        this.context.putImageData(imageData,0,0)\r\n\r\n        console.log(imageData)\r\n\r\n        let width=maxx-minx\r\n        let height=maxy-miny\r\n        let newImageData=[]\r\n        for(let i=miny;i<maxy+1;i++){\r\n            let oneline=[]\r\n\r\n            for (let j=minx;j<maxx+1;j++){\r\n                let index=i*imageData.width+j\r\n                if(imageData.data[index*4+3]>0){\r\n                    oneline.push(1)\r\n                }\r\n                else{\r\n                    oneline.push(0)\r\n                }\r\n            }\r\n            newImageData.push(oneline)\r\n        }\r\n        console.log(newImageData)\r\n\r\n        fetch('http://localhost:3001/processImage',{\r\n            method:'post',//post\r\n            mode: 'cors',//\r\n            headers: {//\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body:'image='+JSON.stringify(newImageData)//\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                console.log(data)\r\n\r\n            })\r\n        \r\n        // this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight)\r\n        // this.context.clearRect(0,0,this.canvasWidth*this.canvasRatio,this.canvasHeight*this.canvasRatio)\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,width,color){\r\n        this.context.lineWidth = width;          //\r\n        this.context.strokeStyle = color ;  //\r\n        this.context.moveTo (x1,y1);       //\r\n        this.context.lineTo (x2,y2);       //\r\n\r\n        this.context.stroke();\r\n    }\r\n\r\n    drawEdges(){\r\n        // d3.selectAll(\"line\").remove()\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            this.drawLine(this.pointData[start].x,this.pointData[start].y,this.pointData[end].x,this.pointData[end].y,2,\"black\")\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    loadEdgeData(){\r\n        let that=this\r\n        return fetch('/data/BubbleSetEdge1.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n\r\n    }\r\n\r\n    init(){\r\n        this.context=document.getElementById(\"maincanvas\").getContext(\"2d\")\r\n        this.canvasRatio=scaleCanvas(document.getElementById(\"maincanvas\"),this.context,this.canvasWidth,this.canvasHeight)\r\n        // console.log(this.context)\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n                let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }\r\n        this.maxX=maxx+move[0]\r\n        this.minX=minx+move[0]\r\n        this.maxY=maxy+move[1]\r\n        this.minY=miny+move[1]\r\n        // this.drawRect(this.minX,this.minY,this.maxX-this.minX,this.maxY-this.minY,\"red\")\r\n        console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n    }\r\n\r\n    drawPointData(){\r\n        for(let i=0;i<this.pointData.length;i++){\r\n            this.drawPoint(this.pointData[i].x,this.pointData[i].y,this.pointData[i].radius,colors[this.pointData[i].cat])\r\n        }\r\n    }\r\n\r\n\r\n    drawPoint(x,y,r,color){\r\n\r\n        this.context.beginPath()\r\n        this.context.fillStyle=color\r\n        this.context.arc(x, y, r, 0, Math.PI * 2, false);\r\n        this.context.fill()\r\n        this.context.closePath()\r\n    }\r\n\r\n    drawRect(x,y,w,h,color){\r\n        this.context.lineWidth=2\r\n        this.context.strokeStyle=color\r\n        this.context.rect(x-w/2,y-h/2,w,h)\r\n        this.context.stroke()\r\n    }\r\n\r\n    deletePoint(e){\r\n        e.stopPropagation()\r\n        let el=e.target\r\n        let index=d3.select(el).attr(\"index\")\r\n        this.points[index]=-1\r\n        d3.select(el).remove()\r\n        console.log(index)\r\n        d3.selectAll(\"text\")\r\n            .filter(function(d,i){\r\n                return d3.select(this).attr(\"index\")==index\r\n            })\r\n            .remove()\r\n        // console.log(this.points)\r\n    }\r\n\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <canvas id={\"maincanvas\"} width={\"1500\"} height={\"1200\"} >\r\n                </canvas>\r\n                {/*<button onClick={this.addCategory.bind(this)}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"800px\"}}>Add Category</button>*/}\r\n                {/*<input ref={(input)=>this.input=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"750px\"}}></input>*/}\r\n                {/*<button onClick={this.switchCategory.bind(this)}  style={{width:200,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"750px\",marginLeft:10}}>Change Category</button>*/}\r\n                {/*<button onClick={this.savePoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"700px\",marginLeft:10}}>Save</button>*/}\r\n                {/*<button onClick={this.loadPoints.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"700px\",marginLeft:10}}>Load</button>*/}\r\n                {/*<input ref={(input)=>this.input2=input}  style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1550px\",bottom:\"650px\"}}></input>*/}\r\n                {/*<button onClick={this.changeWidthHeight.bind(this)} style={{width:150,height:40,fontSize:\"20px\",position:\"absolute\",left:\"1710px\",bottom:\"650px\",marginLeft:10}}>Change Width and Height</button>*/}\r\n                {/*<label ref={(jsonoutput)=>this.jsonoutput=jsonoutput} style={{width:300,height:200,fontSize:\"10px\",position:\"absolute\",left:\"1550px\",bottom:\"300px\",marginLeft:10,overflow:\"scroll\"}}>*/}\r\n\r\n                {/*</label>*/}\r\n            </div>)\r\n    }\r\n}\r\n\r\nexport default BMOAlgo","import React, {Component} from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nclass AlgorithmEntry extends Component{\r\n\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    // eslint-disable-next-line\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    finishInput(){\r\n        if(this.props.pointData){\r\n            alert(\"Finish input and start creating spanning tree!\");\r\n            console.log(this.props.pointData);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <button onClick = {this.finishInput.bind(this)}>\r\n                Create MST\r\n            </button>\r\n        );\r\n    }\r\n}\r\n\r\nexport default AlgorithmEntry;","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport {drag} from \"d3\";\r\nimport AlgorithmEntry from \"./AlgorithmEntry\";\r\nimport './index.css';\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport { Layout } from 'antd';\r\nimport { Button } from 'antd';\r\nimport { Select } from 'antd';\r\nimport { Menu } from 'antd';\r\nimport { Dropdown} from 'antd';\r\nimport { DownOutlined } from '@ant-design/icons';\r\nimport { Table, Radio, Divider } from 'antd';\r\nimport { Switch } from 'antd';\r\nimport { CloseOutlined, CheckOutlined } from '@ant-design/icons';\r\nimport { Pagination } from 'antd';\r\nimport {calDistance} from \"./util\";\r\nconst svgsaver=require(\"save-svg-as-png\")\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\nconst { Option } = Select;\r\nconst { Header, Footer, Sider, Content } = Layout;\r\n\r\n\r\n\r\nconst columns = [\r\n    {\r\n        title: 'Group',\r\n        dataIndex: 'name',\r\n        render: (text) => <a>{text}</a>,\r\n    }\r\n];\r\nvar keynum = 1\r\nvar GroupDict = {}\r\nGroupDict['Group 0'] = 1\r\nvar cur_set = 0;\r\nvar FileSaver = require('file-saver');\r\n\r\n\r\nvar svgid=\"#mainsvg\"\r\nconst rowSelection = {\r\n    onChange: (selectedRowKeys, selectedRows) => {\r\n        cur_set = selectedRowKeys;\r\n        //console.log(`selectedRowKeys: ${selectedRowKeys}`, 'selectedRows: ', selectedRows);\r\n    },\r\n    getCheckboxProps: (record) => ({\r\n        disabled: record.name === 'Disabled User',\r\n        // Column configuration not to be checked\r\n        name: record.name,\r\n    }),\r\n};\r\n// var colorArray=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nconst colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colorArray=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colorArray=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar is_input = false;\r\nvar g;\r\nvar svg;\r\n\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nclass IndexUI extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0'}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[]\r\n        }\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        var box=document.getElementById('mainsvg');\r\n        this.width = box.getBoundingClientRect().width;\r\n        this.height = box.getBoundingClientRect().height;\r\n        //console.log([this.width,this.height])\r\n\r\n        svg = d3.select('svg');\r\n\r\n        g = d3.select('svg').append(\"g\")\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        //svg.on('mousedown',this.handleMousedown.bind(this));\r\n        svg.call(d3.zoom()\r\n            .extent([[0, 0], [this.width, this.height]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        fetch('/data/datalist.json',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    dataFile:data\r\n                })\r\n            })\r\n\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        this.offsetX = minx - 20;\r\n        this.offsetY = miny - 20;\r\n        this.scaleX = (maxx-minx+40)/this.width;\r\n        this.scaleY = (maxy-miny+40)/this.height;\r\n\r\n        svg = d3.select('svg');\r\n        svg.call(d3.zoom()\r\n            .extent([[this.offsetX, this.offsetY], [this.scaleX, this.scaleY]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //console.log([this.offsetX,this.offsetY,this.scaleX,this.scaleY])\r\n\r\n    }\r\n\r\n    handleMousedown(event){\r\n        //left click\r\n        if(event.button === 0 && is_input){\r\n\r\n            //console.log(\"IndexUI Click!\")\r\n            //console.log(g)\r\n\r\n            //let x = event.offsetX;\r\n            //let y = event.offsetY;\r\n            //console.log([x,y])\r\n            let cx = d3.pointer(event)[0]\r\n            let cy = d3.pointer(event)[1]\r\n            let attributes = g._groups[0][0].attributes\r\n            if(attributes.transform != undefined){\r\n                let val = attributes.transform.value\r\n                let offsetX = \"\";\r\n                let offsetY = \"\";\r\n                let Scale = \"\";\r\n                for(let j = 9; j < val.length; j ++){\r\n                    if(val[j]=='('){\r\n                        j++;\r\n                        if(offsetX==\"\"){\r\n                            while(val[j]!=','){\r\n                                offsetX+=val[j++];\r\n                            }\r\n                            j++;\r\n                            while(val[j]!=')'){\r\n                                offsetY+=val[j++];\r\n                            }\r\n                        }\r\n                        else{\r\n                            while(val[j]!=')'){\r\n                                Scale+=val[j++];\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                offsetX = parseFloat(offsetX)\r\n                offsetY = parseFloat(offsetY)\r\n                Scale = parseFloat(Scale)\r\n                //console.log(\"(\" + offsetX + \", \" + offsetY + \", \" + Scale +\")\")\r\n                cx = (cx - offsetX) / Scale\r\n                cy = (cy - offsetY) / Scale\r\n            }\r\n\r\n\r\n            if(this.shape === 'circle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('circle')\r\n                    .attr('r', 10)\r\n                    .attr('cx', cx)\r\n                    .attr('cy', cy)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('rect')\r\n                    .attr('x', cx - 5)\r\n                    .attr('y', cy - 5)\r\n                    .attr('width', 10)\r\n                    .attr('height', 10)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            let tmp = {};\r\n            tmp.radius = 10;\r\n            tmp.width = 10;\r\n            tmp.height = 10;\r\n            tmp.x = cx;\r\n            tmp.y = cy;\r\n            tmp.cat = cur_set;\r\n            tmp.id = this.cur_idx++;\r\n            tmp.shape = this.shape\r\n\r\n            if(this.hasCreateMST == true){\r\n                this.child.addNewPoints(tmp)\r\n            }\r\n            else{\r\n                this.pointData.push(tmp);\r\n            }\r\n\r\n            this.setState({pointData:this.pointData})\r\n            console.log(this.pointData)\r\n        }\r\n    }\r\n\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        return edge\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                // that.setState({\r\n                //     hasEdit:true\r\n                // })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n                // that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n                // that.optimizeMST(true)\r\n\r\n                // for (var k in that.catPointDict){\r\n                //     that.findCircle(k)\r\n                // }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=g\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                    g\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this).attr(\"opacity\",0)\r\n                    })\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    handleDeleteNode(e){\r\n        if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                this.pointData.splice(this.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n\r\n    }\r\n\r\n    drawInit(){\r\n\r\n        this.centralizeData();\r\n        let data = this.pointData;\r\n        console.log(data)\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            let svg=d3.select(\"svg\")\r\n            let nodeindex=parseInt(d3.select(this).attr(\"idx\"))\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n            if(that.shape==\"circle\"){\r\n                d3.select(this)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                d3.select(this)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            d3.select(this).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",function(){\r\n                d3.select(this).attr(\"stroke\",\"none\")\r\n            })\r\n\r\n        function handleMouseDown(event){\r\n\r\n        }\r\n\r\n        function handleDeleteNode(e){\r\n            if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                that.pointData.splice(that.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n            else if(e.button==2 && !is_input){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                // that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                // that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            // that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        for(let i = 0;i < data.length;i ++){\r\n\r\n            let curcat = -1;\r\n            let tmpcat = data[i].cat.toString()\r\n            let cats = tmpcat.split(\",\")\r\n            if (cats.length > 1){\r\n                for (let c = 0;c < cats.length;c ++){\r\n                    GroupDict['Group '+ cats[c].toString()] = 1\r\n                    curcat = Math.max(parseInt(cats[c]), curcat);\r\n                }\r\n            }\r\n            else{\r\n                GroupDict['Group '+ tmpcat.toString()] = 1\r\n                curcat = Math.max(parseInt(tmpcat), curcat);\r\n            }\r\n\r\n            cur_set = Math.max(curcat,cur_set);\r\n\r\n            if(this.shape === 'circle'){\r\n                g.append('circle')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('r', data[i].radius)\r\n                    .attr('cx', data[i].x)\r\n                    .attr('cy', data[i].y)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx',i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                g.append('rect')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('x', data[i].x - 0.5 * data[i].width)\r\n                    .attr('y', data[i].y - 0.5 * data[i].height)\r\n                    .attr('width', data[i].width)\r\n                    .attr('height', data[i].height)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx', i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n        }\r\n\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n/*        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }*/\r\n\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        keynum = 0\r\n        for(var k in GroupDict){\r\n            if(keynum!=0){\r\n                tmpGroupData.push({\r\n                    key:keynum.toString(),\r\n                    name:k\r\n                })\r\n            }\r\n            keynum++;\r\n        }\r\n        console.log(tmpGroupData)\r\n\r\n        this.setState({GroupData:tmpGroupData})\r\n\r\n        this.cur_idx = data.length\r\n        cur_set = keynum;\r\n\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 40)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 814)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n\r\n    }\r\n\r\n    addNewSet(){\r\n        keynum = 0\r\n        for(var k in GroupDict){\r\n            keynum ++;\r\n        }\r\n        //cur_set = keynum;\r\n        GroupDict['Group '+ keynum.toString()] = 1\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        tmpGroupData.push({\r\n            key:keynum.toString(),\r\n            name:'Group '+ keynum.toString()\r\n        })\r\n        keynum ++;\r\n        this.setState({GroupData:tmpGroupData})\r\n        alert(\"Succellfully add new set \" + (keynum-1)  + \" !\");\r\n    }\r\n\r\n    scaleData(){\r\n\r\n        let minX = Number.MAX_VALUE\r\n        let minY = Number.MAX_VALUE\r\n        let maxX = Number.MIN_VALUE\r\n        let maxY = Number.MIN_VALUE\r\n        let scale_ratio_x = 1\r\n        let scale_ratio_y = 1\r\n        let transform_dx = 0\r\n        let transform_dy = 0\r\n\r\n        if(this.pointData.length <= 0){\r\n            return\r\n        }\r\n\r\n        if(this.pointData[0].shape == \"rectangle\"){\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].width / 2\r\n                let x2 = this.pointData[i].x + this.pointData[i].width / 2\r\n                let y1 = this.pointData[i].y - this.pointData[i].height / 2\r\n                let y2 = this.pointData[i].y + this.pointData[i].height / 2\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n        else{\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].radius\r\n                let x2 = this.pointData[i].x + this.pointData[i].radius\r\n                let y1 = this.pointData[i].y - this.pointData[i].radius\r\n                let y2 = this.pointData[i].y + this.pointData[i].radius\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n\r\n\r\n        let cur_width = maxX - minX\r\n        let cur_height = maxY - minY\r\n\r\n        // let svgwidth1 = 1200\r\n        // let svgheight1 = 1200\r\n\r\n        let svgwidth1 = 1500\r\n        let svgheight1 = 1500\r\n\r\n        //let svgwidth2 = 2000\r\n        //let svgheight2 = 2000\r\n\r\n        //if(cur_width > svgwidth1){\r\n            scale_ratio_x = svgwidth1 / cur_width\r\n        //}\r\n\r\n        //if(cur_height > svgheight1){\r\n            scale_ratio_y = svgheight1 / cur_height\r\n        //}\r\n\r\n        let ratio = Math.min(scale_ratio_x, scale_ratio_y)\r\n\r\n        transform_dx = 0 - minX\r\n        transform_dy = 0 - minY\r\n\r\n        //let ddx = (svgwidth2 / 2)  - ( (minX + transform_dx) * ratio + (maxX + transform_dx) * ratio ) / 2\r\n        //let ddy = (svgheight2 / 2) - ( (minY + transform_dy) * ratio + (maxY + transform_dy) * ratio ) / 2\r\n\r\n        for(let i = 0; i < this.pointData.length; i ++){\r\n\r\n            this.pointData[i].x = (this.pointData[i].x + transform_dx) * ratio\r\n            this.pointData[i].y = (this.pointData[i].y + transform_dy) * ratio\r\n            this.pointData[i].radius *= ratio\r\n            this.pointData[i].width *= ratio\r\n            this.pointData[i].height *= ratio\r\n            //this.pointData[i].shape = \"rectangle\"\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleUpload(){\r\n\r\n        let filename = this.selValue\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    hasLoadData:true\r\n                })\r\n                this.pointData = data;\r\n                //for(let i = 0; i < this.pointData.length; i ++){\r\n                //    this.pointData[i].shape = \"rectangle\"\r\n                //}\r\n                //this.scaleData()\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    // this.pointData[i].width=this.pointData[i].width*1.5\r\n                    // this.pointData[i].height=this.pointData[i].height*1.5\r\n                    this.pointData[i].radius=10\r\n\r\n                }\r\n                //this.setState({\r\n                //    upload: true\r\n                //})\r\n\r\n                this.setState({pointData:this.pointData})\r\n                this.shape = data[0].shape;\r\n\r\n\r\n                this.drawInit();\r\n                this.setState({\r\n                    edges:this.edges\r\n                })\r\n            })\r\n\r\n    }\r\n\r\n    changeSel(e){\r\n        this.selValue = e;\r\n    }\r\n\r\n    handleInput(){\r\n        is_input = !is_input;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    hasCreate(){\r\n        this.hasCreateMST = true;\r\n    }\r\n    saveData(){\r\n        this.child.saveData()\r\n    }\r\n    savePNG(){\r\n        svgsaver.saveSvgAsPng(document.getElementById(\"mainsvg\"), \"result.png\");\r\n    }\r\n    saveSVG(){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"result.svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    handleManually(flag){\r\n        is_input = flag;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    render(){\r\n        let options=this.state.dataFile.map((d)=>{return <option value={d}>{d}</option> })\r\n        console.log(\"Ratio\")\r\n        console.log(ScreenHeight/BeforeHeight)\r\n        console.log(ScreenWidth/BeforeWidth)\r\n        let p1 = 20 * ScreenHeight / BeforeHeight\r\n        let p2 = 50 * ScreenWidth / BeforeWidth\r\n        let p3 = 20 * ScreenHeight / BeforeHeight\r\n        let p4 = 20 * ScreenWidth / BeforeWidth\r\n        let p5 = 25 * ScreenHeight / BeforeHeight\r\n        let pad1 = p1.toString() + \"px \" + p2.toString() + \"px \" + p3.toString() + \"px \" + p4.toString() + \"px\"\r\n        let pad2 = p5.toString() + \"px \" + p4.toString() + \"px\"\r\n        return (\r\n            <>\r\n                <Layout>\r\n                    <Header style={{background: 'rgb(255, 255, 255, 0.1)',textAlign: 'center', fontFamily:\"Segoe UI\",fontWeight:\"bold\",fontSize: '25px', color:\"black\"}}>AceBubble</Header>\r\n                    <Layout>\r\n                        <Content theme={'light'} style={{ padding: pad1, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\" style={{float: \"right\"}}>\r\n                                <svg id=\"mainsvg\" width={1200 * ScreenWidth / BeforeWidth} height={750 * ScreenHeight / BeforeHeight} style={{border:\"1px solid #000000\"}}></svg>\r\n                            </div>\r\n                            <div className=\"left\" style={{float: \"left\"}}>\r\n                                <svg id=\"leftsvg\" width={0} height={0}></svg>\r\n                            </div>\r\n                        </Content>\r\n                        <Sider theme={'light'} width={600 * ScreenWidth / BeforeWidth} className=\"site-layout-background\" style={{ padding: pad2, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\">\r\n                                <Select showSearch style={{ width: 320 * ScreenWidth / BeforeWidth }} placeholder=\"Select an example data..\" onChange={this.changeSel.bind(this)}>\r\n                                    {options}\r\n{/*                                    <Option value='BubbleSetExample1.txt'>example1</Option>\r\n                                    <Option value='BubbleSetExample2.txt'>example2</Option>\r\n                                    <Option value='BubbleSetExample3.txt'>Manually Made Data</Option>\r\n                                    <Option value='test.txt'>test</Option>\r\n                                    <Option value='test(1).txt'>test(1).txt</Option>\r\n                                        <Option value='co2_gdppercapita.txt'>co2_gdppercapita.txt</Option>\r\n                                    <Option value='life_children.txt'>life_children.txt</Option>\r\n                                    <Option value='co2_income.txt'>co2_income.txt</Option>\r\n                                    <Option value='life_income.txt'>life_income.txt</Option>*/}\r\n\r\n\r\n\r\n\r\n\r\n                                </Select>\r\n                                <Button onClick={this.handleUpload.bind(this)}>Load Example Data</Button>\r\n                                <br/>\r\n                                <br/>\r\n                                <p>\r\n                                    <Button onClick={this.saveData.bind(this)}>Save Data</Button>\r\n                                    &nbsp;&nbsp;\r\n                                    <Dropdown overlay={this.menu} arrow>\r\n                                        <Button>Save As <DownOutlined /></Button>\r\n                                    </Dropdown>\r\n                                </p>\r\n\r\n                                <div style={{width:\"90%\"}}>\r\n                                    <Table pagination={{disabled:true, position: ['none', 'none'] }}\r\n                                           scroll={{ y: 200 * ScreenHeight / BeforeHeight }}\r\n                                           rowSelection={{\r\n                                               type: 'radio',\r\n                                               ...rowSelection,\r\n                                           }}\r\n                                           columns={columns}\r\n                                           dataSource={this.state.GroupData}\r\n                                    />\r\n                                </div>\r\n                                <br/>\r\n                                <HierarchicalCluster pointData={this.state.pointData} hasLoadData={this.state.hasLoadData} isedit={this.state.is_input} edges={this.state.edges} hasCreate={this.hasCreate.bind(this)} handleManually={this.handleManually.bind(this)} onRef={this.onRef}/>\r\n                            </div>\r\n                        </Sider>\r\n                    </Layout>\r\n                    <Footer style={{background: 'rgb(255, 255, 255, 0.1)', textAlign: 'center' ,fontSize: '16px'}}>AceBubble 2021</Footer>\r\n                </Layout>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default IndexUI;","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport MainSvg from \"./MainSvg\"\r\nimport DataHacker from \"./dataHacker\"\r\nimport CSVData from \"./CSVData\"\r\nimport GapMinderNew from \"./GapMinderNew\";\r\nimport ManuallyTree from \"./ManuallyTree\";\r\nimport Example1 from\"./Example1\"\r\nimport LocalCluster from\"./LocalCluster\"\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport BMOAlgo from \"./BMOAlgo\";\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport IndexUI from \"./IndexUI\";\r\n\r\nclass BubbleDemo extends  Component{\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    render(){\r\n        // return(<MainSvg></MainSvg>)\r\n        // return(<DataHacker></DataHacker>)\r\n        // return(<CSVData></CSVData>)\r\n        // return(<GapMinderNew ></GapMinderNew>)\r\n        // return(<ManuallyTree ></ManuallyTree>)\r\n        // return(<LocalCluster ></LocalCluster>)\r\n         //return(<HierarchicalCluster ></HierarchicalCluster>)\r\n        //return(<AdaptiveIsovalue ></AdaptiveIsovalue>)\r\n\r\n        return(<IndexUI></IndexUI>)\r\n\r\n        // return(<Example1 ></Example1>)\r\n\r\n    }\r\n}\r\n\r\nexport default BubbleDemo","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\nvar colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\nvar re=20\r\nvar bt=5\r\nvar tanPointsNum=0\r\n\r\nvar cd=1\r\nvar calpha=1\r\nvar ci=100\r\n\r\nvar deltaDeg=10/180*Math.PI\r\n\r\n\r\nclass KelpDiagram extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n        // let filename=\"newExample1.txt\"\r\n        let filename=\"BubbleSetExample1.txt\"\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                this.drawPointData()\r\n                console.time(\"total time\")\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n                this.calTanGraphWithPolygon()\r\n                console.log(this.tanGraphPoints)\r\n                console.log(this.tanGraphEdges)\r\n                // this.calSpacePath()\r\n                // this.calTangentGraph()\r\n                // this.splitCircularEdge()\r\n                this.calShortestPath()\r\n                console.timeEnd(\"total time\")\r\n\r\n\r\n                // this.drawSplitEdge()\r\n                // this.drawTanPoint()\r\n                // this.drawTangentEdges()\r\n                // this.createGraph()\r\n\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                    dearray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n/*                    if(this.tanGraphEdges.length>=60036){\r\n                        console.log()\r\n                    }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n/*        if(index>polypoints.length-1){\r\n            d3.select(\"svg\").selectAll(\"circle\").remove()\r\n            drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n            drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n            drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n        }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                        let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                        let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                        let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index2,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                        let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                        let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                        }\r\n\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex0,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:existindex1,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                        let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:index1,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(  P0,  P1,  P2 )\r\n{\r\n    return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n}\r\n\r\n    RLtangent_PolyPolyC(V,   W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"red\",2)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n/*        for (let i=0;i<polygons.length;i++){\r\n            drawPolygon(polygons[i],0,0,\"red\")\r\n        }*/\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n        }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n         let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n         for (let p=0;p<polypoints.length;p++){\r\n             let thisp=polypoints[p]\r\n             let nextp=polypoints[(p+1)%pointnum]\r\n             // drawLine(thisp,nextp,\"blue\")\r\n             //check intersection between line and circle\r\n             let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n             if(inside){\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     insideLines.push([thisp,nextp])\r\n                 }\r\n         else{\r\n             let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                    let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([thisp,[point.x,point.y]])\r\n                 }\r\n             }\r\n        else{\r\n                 let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                 if(inside2){\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     let point=intersections.points[0]\r\n                     vi.push([point.x,point.y])\r\n                     insideLines.push([[point.x,point.y],nextp])\r\n                 }\r\n        else{\r\n                     let line=ShapeInfo.line(thisp, nextp)\r\n                     const intersections = Intersection.intersect(circle, line);\r\n                     if(intersections.status==\"Intersection\"){\r\n                         let points=intersections.points\r\n                         let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                         let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                         if(dis1<dis2){\r\n                             insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                             vi.push([points[0].x,points[0].y])\r\n                             vi.push([points[1].x,points[1].y])\r\n                         }\r\n                     else{\r\n                             insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                             vi.push([points[1].x,points[1].y])\r\n                             vi.push([points[0].x,points[0].y])\r\n                         }\r\n                     }\r\n                     else{\r\n                         //no intersection with the circle\r\n                     }\r\n\r\n                 }\r\n             }\r\n         }\r\n\r\n         this.VI.push(vi)\r\n        if(insideLines.length>0){\r\n            for (let l=0;l<insideLines.length;l++){\r\n                // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                eleSpace.push({\r\n                    type:\"line\",\r\n                    start:insideLines[l][0],\r\n                    end:insideLines[l][1],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n                let point1=insideLines[l][1]\r\n                let point2=insideLines[(l+1)%insideLines.length][0]\r\n                if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                }\r\n                else{\r\n                    //insert an arc\r\n                    eleSpace.push({\r\n                        type:\"arc\",\r\n                        start:point1,\r\n                        end:point2,\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                }\r\n\r\n            }\r\n        }\r\n        else{\r\n            eleSpace.push({\r\n                type:\"circle\",\r\n                start:[],\r\n                end:[],\r\n                center:[data.x,data.y],\r\n                radius:re\r\n            })\r\n        }\r\n        this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    calSpacePath(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let pathstr=\"\"\r\n            let segs=this.elementSpace[i]\r\n            if(i==5){\r\n                console.log()\r\n            }\r\n            for (let s=0;s<segs.length;s++){\r\n                let type=segs[s].type\r\n                let center=segs[s].center\r\n                let startp=segs[s].start\r\n                let endp=segs[s].end\r\n                let radius=re\r\n\r\n                if(type==\"circle\"){\r\n                    // drawCircle(segs[s].center[0],segs[s].center[1],segs[s].radius,\"none\",\"black\")\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    pathstr+=\"M \"+startpoint[0]+\",\"+startpoint[1]+\" a \"+radius+\",\"+radius+\" 0 1,0 \"+2*radius+\",0\"\r\n                    pathstr+=\" a \"+radius+\",\"+radius+\" 0 1,0 \"+-1*2*radius+\",0\"\r\n                }\r\n                else if(type==\"arc\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    let largearcflag=0\r\n                    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n/*                    if(i==5){\r\n                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                        drawLine(vec1[0],vec1[1],\"red\")\r\n                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                    }*/\r\n\r\n                    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                    if(crossmul>0){\r\n                        largearcflag=1\r\n                    }\r\n                    else if(crossmul<=0){\r\n                        largearcflag=0\r\n                    }\r\n\r\n                    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n\r\n\r\n                }\r\n                else if(type==\"line\"){\r\n                    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                    pathstr+=\"L \"+endp[0]+\",\"+endp[1]\r\n                }\r\n            }\r\n            d3.select(\"svg\")\r\n                .append(\"path\")\r\n                .attr(\"id\",\"elespace\"+i)\r\n                .attr(\"d\",pathstr)\r\n                .attr(\"fill\",\"none\")\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"stroke-width\",\"2\")\r\n            this.pathString.push(pathstr)\r\n        }\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    calTangentGraph(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        console.log(this.catPointDict)\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        /*                            if(index1==80){\r\n                                                        drawLine(linestart,lineend,\"red\",2)\r\n                                                    }*/\r\n                        let startpoint={\r\n                            type:\"tanpoint\",\r\n                            x:linestart[0],\r\n                            y:linestart[1],\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(startpoint)\r\n                        tanPointsNum+=1\r\n                        let endpoint={\r\n                            type:\"tanpoint\",\r\n                            x:lineend[0],\r\n                            y:lineend[1],\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        this.tanGraphPoints.push(endpoint)\r\n                        tanPointsNum+=1\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:startpoint.id,\r\n                            endid:endpoint.id,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                if(this.pointData[i].cat==this.pointData[j].cat){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n                }\r\n\r\n                if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                    //p to q\r\n                    let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    if(eleSpace2.length==1){\r\n                        let point0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point0)\r\n                        let point1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:index2,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(point1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point0.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:point1.id,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints.length;p++){\r\n                            for (let e=0;e<eleSpace2.length;e++){\r\n                                if(eleSpace2[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints[p].x,\r\n                                            y:tanPoints[p].y,\r\n                                            dataindex:index2,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index1,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //q to p\r\n                    let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                    tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                    if(eleSpace1.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[0].x,\r\n                            y:tanPoints2[0].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints2[1].x,\r\n                            y:tanPoints2[1].y,\r\n                            dataindex:index1,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[0].x,tanPoints2[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:index2,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[1].x,tanPoints2[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let p=0;p<tanPoints2.length;p++){\r\n                            for (let e=0;e<eleSpace1.length;e++){\r\n                                if(eleSpace1[e].type==\"arc\"){\r\n                                    if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                        let tanpoint={\r\n                                            type:\"tanpoint\",\r\n                                            x:tanPoints2[p].x,\r\n                                            y:tanPoints2[p].y,\r\n                                            dataindex:index1,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:index2,\r\n                                            endid:tanpoint.id,\r\n                                            // startpoint:[points[j].x,points[j].y],\r\n                                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.newVI[i].dataindex[0]\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].cat\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n                this.tanGraphEdges.push({\r\n                    type:\"line\",\r\n                    startid:this.newVI[i].id,\r\n                    endid:this.pointData[p].id,\r\n                    // startpoint:[points[j].x,points[j].y],\r\n                    // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                })\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let tanpoint0={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[0].x,\r\n                            y:tanPoints[0].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint0)\r\n                        let tanpoint1={\r\n                            type:\"tanpoint\",\r\n                            x:tanPoints[1].x,\r\n                            y:tanPoints[1].y,\r\n                            dataindex:p,\r\n                            id:tanPointsNum\r\n                        }\r\n                        tanPointsNum+=1\r\n                        this.tanGraphPoints.push(tanpoint1)\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint0.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:tanpoint1.id,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n                                        let tanpoint={\r\n                                            type: \"tanpoint\",\r\n                                            x: tanPoints[t].x,\r\n                                            y: tanPoints[t].y,\r\n                                            dataindex: p,\r\n                                            id:tanPointsNum\r\n                                        }\r\n                                        tanPointsNum+=1\r\n                                        this.tanGraphPoints.push(tanpoint)\r\n\r\n                                        this.tanGraphEdges.push({\r\n                                            type: \"line\",\r\n                                            startid: this.newVI[i].id,\r\n                                            endid: tanpoint.id,\r\n                                            // startpoint: vp,\r\n                                            // endpoint: [tanPoints[p].x, tanPoints[p].y]\r\n                                        })\r\n\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(this.tanGraphPoints)\r\n\r\n/*        for (let i=0;i<this.pointData.length;i++){\r\n            let points=this.VI[i]\r\n            for (let p=0;p<points.length;p++){\r\n                this.tanGraphEdges.push({\r\n                    startid:i,\r\n                    endid:i,\r\n                    startpoint:points[p],\r\n                    endpoint:[this.pointData[i].x,this.pointData[i].y]\r\n                })\r\n            }\r\n        }*/\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n/*        for (let i=0;i<tanPointMap.length;i++){\r\n            if(i==91){\r\n                for (let j=0;j<tanPointMap[i].length;j++){\r\n                    drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                }\r\n            }\r\n        }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n/*                    if(i==91){\r\n                        drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                        drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                        for (let o=0;o<onPoints.length;o++){\r\n                            drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                        }\r\n\r\n                    }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                        index:p,\r\n                        degree:degree\r\n                    })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n/*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].dataindex==91){\r\n                drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n            }\r\n        }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    calScoreForAll(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            let startdataid=startpoint.dataindex\r\n            let enddataid=endpoint.dataindex\r\n            let center=this.tanGraphEdges[i].center\r\n            if(this.tanGraphEdges[i].type==\"line\"){\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n            }\r\n\r\n            else{\r\n                //arc edges\r\n                let startvec=[startpoint.x-center[0],startpoint.y-center[1]]\r\n                let endvec=[endpoint.x-center[0],endpoint.y-center[1]]\r\n                let degree=getDegreeTwoVec(startvec,endvec)\r\n                let littledegree=degree\r\n                let crossmul1=crossMul(startvec,endvec)\r\n                if(crossmul1>0){\r\n                    degree=2*Math.PI-degree\r\n                }\r\n                let arcLength=degree*re\r\n                this.tanGraphEdges[i].distance=arcLength\r\n                this.tanGraphEdges[i].crossnum=0\r\n/*                if(degree>Math.PI){\r\n                    this.tanGraphEdges[i].alpha=degree-Math.PI\r\n                }\r\n                else{\r\n                    this.tanGraphEdges[i].alpha=Math.PI-degree\r\n                }*/\r\n                this.tanGraphEdges[i].alpha=littledegree\r\n\r\n                drawArc([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],center,re)\r\n                // console.log()\r\n\r\n            }\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    calScoreForAllWithPoly(){\r\n        //cal distance,alpha and crossing num\r\n        console.time(\"cal score\")\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n\r\n            let center=this.tanGraphEdges[i].center\r\n\r\n                let cat\r\n                if(startpoint.type==\"vi\"){\r\n                    cat=this.pointData[startpoint.dataindex[0]].cat\r\n                }\r\n                else{\r\n                    cat=this.pointData[startpoint.dataindex].cat\r\n                }\r\n                // console.log(cat)\r\n                let dis=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                this.tanGraphEdges[i].distance=dis\r\n                this.tanGraphEdges[i].crossnum=0\r\n                this.tanGraphEdges[i].alpha=0\r\n                //cal intersection with elespacepath\r\n                let crossnum=0\r\n                for (let p=0;p<this.elementPoly.length;p++){\r\n                    let cat2=this.pointData[p].cat\r\n                    if(cat!=cat2&&p!=startpoint.dataindex&&p!=endpoint.dataindex) {\r\n                        let polyPoints=[]\r\n                        for (let e=0;e<this.elementPoly[p].length;e++){\r\n                            polyPoints.push({\r\n                                x:this.elementPoly[p][e].x,\r\n                                y:this.elementPoly[p][e].y\r\n                            })\r\n                        }\r\n                        const poly = ShapeInfo.polygon(polyPoints);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(poly, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    }\r\n/*                for (let e=0;e<this.pathString.length;e++){\r\n                    let cat2=this.pointData[e].cat\r\n                    if(cat!=cat2&&e!=startdataid&&e!=enddataid){\r\n                        const path = ShapeInfo.path(this.pathString[e]);\r\n                        const line = ShapeInfo.line([startpoint.x, startpoint.y], [endpoint.x, endpoint.y]);\r\n                        const intersections = Intersection.intersect(path, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n\r\n                }*/\r\n                this.tanGraphEdges[i].crossnum=crossnum\r\n\r\n\r\n            this.tanGraphEdges[i].cl=cd*this.tanGraphEdges[i].distance+calpha*this.tanGraphEdges[i].alpha+ci*this.tanGraphEdges[i].crossnum\r\n\r\n\r\n        }\r\n        console.timeEnd(\"cal score\")\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n        else{\r\n            return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    calShortestPath(){\r\n        console.log(this.elementPoly)\r\n\r\n        this.calScoreForAllWithPoly()\r\n\r\n        this.normalizeEdgeLength()\r\n        //cal edge dict\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            edgeDict[startid].push(this.tanGraphEdges[i])\r\n            edgeDict[endid].push(this.tanGraphEdges[i])\r\n        }\r\n\r\n        //create graph\r\n        var g = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let score=this.tanGraphEdges[i].cl\r\n            g.addEdge(new jsgraphs.Edge(startid, endid, score));\r\n            g.addEdge(new jsgraphs.Edge(endid, startid, score));\r\n            g.edge(startid,endid).label=i\r\n            g.edge(endid,startid).label=i\r\n\r\n        }\r\n        // this.graph=g\r\n\r\n        var GL= new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length);\r\n\r\n        let dpq={}\r\n        for (var k in this.catPointDict){\r\n            let points=this.catPointDict[k]\r\n            for (let i=0;i<points.length;i++){\r\n                let p1=points[i]\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let p2=points[j]\r\n                    if(!dpq.hasOwnProperty(p1.id)){\r\n                        dpq[p1.id]={}\r\n                    }\r\n                    dpq[p1.id][p2.id]=-1\r\n\r\n                    if(!dpq.hasOwnProperty(p2.id)){\r\n                        dpq[p2.id]={}\r\n                    }\r\n                    dpq[p2.id][p1.id]=-1\r\n                }\r\n            }\r\n        }\r\n\r\n        let paths=[]\r\n\r\n\r\n        while(true){\r\n            let bestscore=-1\r\n            let bestindex1=-1\r\n            let bestindex2=-1\r\n            let minpath=[]\r\n            let hasInfinite=false\r\n\r\n            //find the best link\r\n            for (var k in this.catPointDict){\r\n                let points=this.catPointDict[k]\r\n                for (let i=0;i<points.length;i++){\r\n                    let p1=points[i]\r\n                    var dijkstra = new jsgraphs.Dijkstra(g,p1.id);\r\n\r\n                    for (let j=i+1;j<points.length;j++){\r\n                        let p2=points[j]\r\n\r\n                        //calculate cl and find maximum bpq\r\n                        let path=dijkstra.pathTo(p2.id)\r\n                        let cl=dijkstra.distanceTo(p2.id)\r\n                        let bpq\r\n                        if(dpq[p1.id][p2.id]==-1){\r\n                            if(!hasInfinite){\r\n                                let hasAdded=false\r\n                                for(let p=0;p<paths.length;p++){\r\n                                    if(this.isSamePath(path,paths[p])){\r\n                                        hasAdded=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(!hasAdded){\r\n                                    hasInfinite=true\r\n                                    bestindex1=p1.id\r\n                                    bestindex2=p2.id\r\n                                    bestscore=cl\r\n                                    minpath=path\r\n                                }\r\n                            }\r\n                            else{\r\n                                if(bestscore>cl){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        bestscore=cl\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(hasInfinite){\r\n                                continue\r\n                            }\r\n                            else{\r\n                                bpq=dpq[p1.id][p2.id]/cl\r\n                                if(bpq>bestscore){\r\n                                    let hasAdded=false\r\n                                    for(let p=0;p<paths.length;p++){\r\n                                        if(this.isSamePath(path,paths[p])){\r\n                                            hasAdded=true\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                    if(!hasAdded) {\r\n                                        bestscore=bpq\r\n                                        bestindex1=p1.id\r\n                                        bestindex2=p2.id\r\n                                        minpath=path\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(bestscore<=bt){\r\n                break\r\n            }\r\n            else{\r\n                //add this path and update crossnum and dpq\r\n\r\n                this.drawPath(minpath)\r\n                paths.push(minpath)\r\n\r\n                for (let i=0;i<minpath.length;i++){\r\n                    let e=minpath[i]\r\n                    let start=e.from()\r\n                    let end=e.to()\r\n                    let startpoint=this.tanGraphPoints[start]\r\n                    let endpoint=this.tanGraphPoints[end]\r\n\r\n                    if(GL.edge(start,end)==null){\r\n                        GL.addEdge(new jsgraphs.Edge(start, end, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                        GL.addEdge(new jsgraphs.Edge(end, start, calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)) )\r\n                    }\r\n\r\n                    //update crossnum\r\n                    for (let p=0;p<this.tanGraphEdges.length;p++){\r\n                        if(this.tanGraphEdges[p].type==\"line\"){\r\n                            let cat\r\n                            if(startpoint.type==\"vi\"){\r\n                                cat=this.pointData[startpoint.dataindex[0]].cat\r\n                            }\r\n                            else{\r\n                                cat=this.pointData[startpoint.dataindex].cat\r\n                            }\r\n\r\n                                let start2=this.tanGraphEdges[p].startid\r\n                                let end2=this.tanGraphEdges[p].endid\r\n                                let startpoint2=this.tanGraphPoints[start2]\r\n                                let endpoint2=this.tanGraphPoints[end2]\r\n\r\n                                let cat2\r\n\r\n                                if(startpoint2.type==\"vi\"){\r\n                                    cat2=this.pointData[startpoint2.dataindex[0]].cat\r\n                                }\r\n                                else{\r\n                                    cat2=this.pointData[startpoint2.dataindex].cat\r\n                                }\r\n                                if(cat!=cat2){\r\n                                    if(this.checkEdgeCrossing(startpoint,endpoint,startpoint2,endpoint2)){\r\n                                        this.tanGraphEdges[p].crossnum+=1\r\n                                        this.tanGraphEdges[p].cl+=ci\r\n                                        let startid=this.tanGraphEdges[p].startid\r\n                                        let endid=this.tanGraphEdges[p].endid\r\n                                        g.edge(startid,endid).weight=this.tanGraphEdges[p].cl\r\n                                        g.edge(endid,startid).weight=this.tanGraphEdges[p].cl\r\n                                    }\r\n                                }\r\n\r\n\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                for(let id1=0;id1<this.pointData.length;id1++){\r\n                    let datapoint=this.pointData[id1]\r\n                    var dijkstraGL = new jsgraphs.Dijkstra(GL,datapoint.id);\r\n\r\n                    for (let id2=id1+1;id2<this.pointData.length;id2++){\r\n                        let datapoint2=this.pointData[id2]\r\n/*                        if(id1==10&&id2==15){\r\n                            console.log(GL.adj(15))\r\n                            console.log(GL.adj(16))\r\n                            console.log(dijkstraGL.hasPathTo(15))\r\n                            console.log()\r\n                        }*/\r\n                        if(dijkstraGL.hasPathTo(datapoint2.id)){\r\n                            let newd=dijkstraGL.distanceTo(datapoint2.id)\r\n                            if(dpq[id1][id2]==-1){\r\n                                dpq[id1][id2]=newd\r\n                                dpq[id2][id1]=newd\r\n                            }\r\n                            else{\r\n                                if(dpq[id1][id2]>newd){\r\n                                    dpq[id1][id2]=newd\r\n                                    dpq[id2][id1]=newd\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n        }\r\n\r\n        console.log(paths)\r\n\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let start=e.from()\r\n            let end=e.to()\r\n            let startpoint=this.tanGraphPoints[start]\r\n            let endpoint=this.tanGraphPoints[end]\r\n\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpDiagram","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\nimport './index.css';\r\nimport {\r\n    drawPolygon,\r\n    drawCircle,\r\n    drawLine,\r\n    calDistance,\r\n    calCommonTanPoint,\r\n    getDegreeTwoVec,\r\n    crossMul,\r\n    calTanPoint, drawArc, rotatePoint, clone\r\n} from \"./util\";\r\nimport * as turf from '@turf/turf'\r\n\r\n\r\nconst {ShapeInfo, Intersection, Point2D, IntersectionQuery} = require(\"kld-intersections\");\r\n\r\nvar d3Voronoi = require(\"d3-voronoi\")\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar triangulate = require(\"delaunay-triangulate\")\r\nvar AreaCal = require('2d-polygon-area');\r\nvar FileSaver = require('file-saver');\r\n// var colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar tanPointsNum = 0\r\nvar deltaDeg = 10 / 180 * Math.PI\r\nvar re = 15\r\nvar parameter_C = 0\r\nvar parameter_t = 3\r\nvar parameter_A = -1\r\nvar EdgeWidth = 10\r\nconst eps = 1e-10\r\nvar neighbors = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    //.curve(d3.curveCatmullRom);\r\n\r\n\r\nclass KelpFusion extends Component{\r\n    constructor(){\r\n        super()\r\n        this.pointData = [];\r\n        this.itemShape=\"circle\"\r\n        this.maxX=Number.MIN_VALUE\r\n        this.minX=Number.MAX_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.itemBBox=[]\r\n        this.catPointDict={}\r\n        this.voronoiPolygons=[]\r\n        this.elementSpace=[]\r\n        this.elementPoly=[]\r\n        //this.pathString=[]\r\n        this.VI=[]\r\n        this.tanGraphEdges=[]\r\n        this.tanGraphPoints=[]\r\n        this.edges=[]\r\n        this.newVI=[]\r\n        this.initGraph = {}\r\n        this.initPoints = {}\r\n        this.initEdges = {}\r\n        this.SPGEdges = {}\r\n        this.SPG = {}\r\n        this.catPointMap = {}\r\n        this.catInitEdges = {}\r\n        this.rGEdges = {}\r\n        this.rG = {}\r\n        this.tanPointMap = {}\r\n        this.visited = []\r\n        this.fa = []\r\n        this.circles = {}\r\n        this.polygons = {}\r\n        this.SPGAdjList = {}\r\n        // this.graph=null\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        let file_list = [\r\n            \"co2_gdppercapita\",\r\n            \"co2_income\",\r\n            \"life_children\",\r\n            \"life_income\",\r\n            \"Bronx\",\r\n            \"Brooklyn\",\r\n            \"Citywide\",\r\n            \"Manhattan\",\r\n            \"life_fertility\",\r\n            \"Staten Island\",\r\n            \"ex1\",\r\n            \"ex2\",\r\n            \"ex3\",\r\n            \"ex4\",\r\n            \"ex5\",\r\n            \"ex6\",\r\n            \"ex7\",\r\n            \"ex8\",\r\n            \"ex9\",\r\n            \"ex10\",\r\n            \"ex11\",\r\n            \"ex12\",\r\n            \"ex13\",\r\n            \"ex14\",\r\n            \"ex15\",\r\n            \"ex16\",\r\n            \"ex17\",\r\n            \"ex18\",\r\n            \"ex19\",\r\n            \"ex20\"\r\n        ];\r\n\r\n\r\n        //let fi = file_list[5]\r\n        let fi = \"ex13\"\r\n        let filename =  fi + \".txt\"\r\n        let flag = false\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n\r\n                console.time(\"running time\")\r\n                this.pointData = data;\r\n                this.itemShape = data[0].shape;\r\n                this.centralizeData()\r\n                //this.drawPointData()\r\n                console.log(filename)\r\n\r\n                /*\r\n                if(flag){\r\n                    let content = JSON.stringify(this.catPointDict)\r\n                    let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n                    FileSaver.saveAs(blob, fi + \".json\");\r\n                }\r\n                else{\r\n                    this.drawLineSets(fi)\r\n                }\r\n                 */\r\n\r\n                console.log(\"pointData!\")\r\n                console.log(this.pointData)\r\n                console.time(\"total time\")\r\n\r\n                this.calVoronoiDiagram()\r\n                this.calElementSpace()\r\n                this.approxArcWithPolygon()\r\n                this.drawSpacePathWithPolygon()\r\n\r\n                for(let k in this.catPointDict){\r\n                    this.rGEdges[k] = []\r\n                }\r\n\r\n                this.calTanGraphWithPolygon()\r\n\r\n                // Add point and edges on the element polygon\r\n                let preLen = this.tanGraphPoints.length\r\n                this.tanPointMap = {}\r\n                for(let k in this.catPointDict){\r\n                    this.catPointMap[k] = {}\r\n                }\r\n                let addIdx = {}\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n\r\n                        this.tanPointMap[this.tanGraphPoints[i].dataindex] = i\r\n\r\n                        let idx = this.tanGraphPoints[i].dataindex\r\n                        for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                            let nowcat = this.pointData[idx].catArray[c]\r\n                            if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                                this.catPointMap[nowcat][idx] = 1\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                for(let i = 0; i < this.elementPoly.length; i ++){\r\n                    addIdx[i] = []\r\n                    for(let j = 0; j < this.elementPoly[i].length ; j ++){\r\n                        let idx = this.tanGraphPoints.length\r\n                        addIdx[i].push(idx)\r\n                        this.tanGraphPoints.push({\r\n                            type:\"addpoint\",\r\n                            x:this.elementPoly[i][j].x,\r\n                            y:this.elementPoly[i][j].y,\r\n                            dataindex:i,\r\n                            id:idx\r\n                        })\r\n                    }\r\n                    for(let j = 0; j < addIdx[i].length; j ++){\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                        })\r\n\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:addIdx[i][(j + 1) % addIdx[i].length]\r\n                            })\r\n                        }\r\n\r\n                        //TODO : Bug Fix\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:addIdx[i][j],\r\n                            endid:this.tanPointMap[i]\r\n                        })\r\n\r\n                        let cat_array = this.pointData[i].catArray\r\n                        for(let c = 0; c < cat_array.length; c ++){\r\n                            let nowcat = cat_array[c]\r\n                            this.rGEdges[nowcat].push({\r\n                                type:\"line\",\r\n                                startid:addIdx[i][j],\r\n                                endid:this.tanPointMap[i]\r\n                            })\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < preLen; i ++){\r\n                    if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                        continue\r\n                    }\r\n                    let idx\r\n                    if(this.tanGraphPoints[i].type == \"vi\"){\r\n                        idx = this.tanGraphPoints[i].dataindex\r\n                    }\r\n                    else{\r\n                        idx = [this.tanGraphPoints[i].dataindex]\r\n                    }\r\n                    let x1 = this.tanGraphPoints[i].x\r\n                    let y1 = this.tanGraphPoints[i].y\r\n                    for(let j = 0; j < idx.length; j ++){\r\n                        let pointID = idx[j]\r\n                        let selectIdx = -1\r\n                        let minDis = Number.MAX_VALUE\r\n                        for(let p = 0; p < addIdx[pointID].length; p ++){\r\n                            let x2 = this.tanGraphPoints[addIdx[pointID][p]].x\r\n                            let y2 = this.tanGraphPoints[addIdx[pointID][p]].y\r\n                            let tmpDis = calDistance(x1, y1, x2, y2)\r\n                            if(tmpDis < minDis){\r\n                                minDis = tmpDis\r\n                                selectIdx = addIdx[pointID][p]\r\n                            }\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:i,\r\n                            endid:selectIdx\r\n                        })\r\n                        for(let k in this.catPointDict){\r\n                            this.rGEdges[k].push({\r\n                                type:\"line\",\r\n                                startid:i,\r\n                                endid:selectIdx\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //console.log(\"rGEdges\")\r\n                //console.log(this.rGEdges)\r\n\r\n                //for(let cur_k in this.catPointDict){\r\n                //    let cur_k = \"0\"\r\n                //    for(let i = 0; i < this.rGEdges[cur_k].length; i ++){\r\n                //        let startid = this.rGEdges[cur_k][i].startid\r\n                //        let endid = this.rGEdges[cur_k][i].endid\r\n                //        let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //        let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n//\r\n                //        let idx1 = this.tanGraphPoints[startid].dataindex\r\n                //        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                //            idx1 = [idx1]\r\n                //        }\r\n//\r\n                //        let idx2 = this.tanGraphPoints[endid].dataindex\r\n                //        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                //            idx2 = [idx2]\r\n                //        }\r\n//\r\n                //        let cat1 = this.pointData[idx1[0]].cat\r\n                //        let cat2 = this.pointData[idx2[0]].cat\r\n//\r\n                //        //if(cat1 == cat2 && cat1 == \"2\" && this.tanGraphPoints[endid].type == \"datapoint\" &&this.tanGraphPoints[endid].type == \"datapoint\")\r\n                //            //drawLine(startpoint, endpoint, 'black', 1)\r\n                //    }\r\n               // }\r\n\r\n                //for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n                //    let startid = this.tanGraphEdges[i].startid\r\n                //    let endid = this.tanGraphEdges[i].endid\r\n                //    let startpoint = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                //    let endpoint = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //    //drawLine(startpoint, endpoint, 'black', 1)\r\n                //}\r\n\r\n\r\n                //this.drawTanPoint()\r\n                //this.drawTangentEdges()\r\n                //console.log(\"tanGraph!\")\r\n                //console.log(this.tanGraphPoints)\r\n                //console.log(this.tanGraphEdges)\r\n                //console.log(this.elementPoly)\r\n                //console.log(this.elementSpace)\r\n\r\n                //for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n                //    d3.select('svg').append(\"circle\")\r\n                //        .attr(\"cx\",this.tanGraphPoints[i].x)\r\n                //        .attr(\"cy\",this.tanGraphPoints[i].y)\r\n                //        .attr(\"r\",1)\r\n                //        .attr(\"fill\",\"black\")\r\n                //}\r\n\r\n                //for(let i = 0; i < )\r\n\r\n\r\n                this.createInitGraph()\r\n                this.createSPG()\r\n\r\n                console.timeEnd(\"total time\")\r\n\r\n                //this.calCrossEdges()\r\n\r\n                console.timeEnd(\"running time\")\r\n\r\n                this.findAllCircles()\r\n                this.findPolygons()\r\n                this.judgePolygons()\r\n                this.drawKelpFusion()\r\n                this.drawPointData()\r\n                this.saveSVG(fi)\r\n\r\n                //console.log(this.elementSpace)\r\n\r\n               //console.log(\"element space\")\r\n               //console.log(this.elementSpace)\r\n               //console.log(\"element ploygon\")\r\n               //console.log(this.elementPoly)\r\n\r\n\r\n\r\n            })\r\n\r\n\r\n    }\r\n\r\n    saveSVG(filename){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n        FileSaver.saveAs(blob, filename + \".svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    drawLineSets(fi){\r\n        let filename1 = fi + \".txt\"\r\n        let filename2 = fi + \"_cross.txt\"\r\n        fetch('/data/line_data/'+filename1,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                let path = data\r\n                console.log(path)\r\n                for(let k in this.catPointDict){\r\n                    d3.select(\"svg\").append(\"path\")\r\n                        .attr('d',lineFunction(path[k]))\r\n                        .attr(\"id\",\"path\" + k)\r\n                        .attr(\"fill\",'none')\r\n                        .style('stroke', colors[parseInt(k)])\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n\r\n                this.saveSVG(fi)\r\n\r\n                /*\r\n                fetch('/data/line_data/'+filename2,{\r\n                    method:'GET',\r\n                    headers:{\r\n                        'Content-Type':'application/json;charset=UTF-8'\r\n                    },\r\n                    mode:'cors',\r\n                    cache:'default'\r\n                })\r\n                    .then(res=>res.json())\r\n                    .then(data=>{\r\n                        let cross_edge = data\r\n                        for(let k in cross_edge){\r\n                            let tmpPath = d3.select(\"#path\" + k).node()\r\n                            let totLen = tmpPath.getTotalLength()\r\n                            for(let p = 0; p < cross_edge[k].length; p ++){\r\n                                let st = [cross_edge[k][p][0], cross_edge[k][p][1]]\r\n                                let en = [cross_edge[k][p][2], cross_edge[k][p][3]]\r\n                                //drawLine(st, en, \"red\", 4)\r\n                                let idx1 = -1\r\n                                let idx2 = -1\r\n                                let mindis1 = Number.MAX_VALUE\r\n                                let mindis2 = Number.MAX_VALUE\r\n                                for(let l = 0; l < totLen / 5; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    let dis1 = calDistance(st[0], st[1], tmp_p.x, tmp_p.y)\r\n                                    let dis2 = calDistance(en[0], en[1], tmp_p.x, tmp_p.y)\r\n                                    if(dis1 < mindis1){\r\n                                        mindis1 = dis1\r\n                                        idx1 = l\r\n                                    }\r\n                                    if(dis2 < mindis2){\r\n                                        mindis2 = dis2\r\n                                        idx2 = l\r\n                                    }\r\n                                }\r\n                                let tmp_lines = []\r\n                                for(let l = idx1; l <= idx2; l ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * l)\r\n                                    tmp_lines.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr('d',lineFunction(tmp_lines))\r\n                                    .attr(\"fill\",'none')\r\n                                    .style('stroke', \"red\")\r\n                                    .style(\"stroke-width\", 4);\r\n                            }\r\n                        }\r\n\r\n                        this.saveSVG(fi)\r\n\r\n                    })\r\n                 */\r\n            })\r\n    }\r\n\r\n    addCircularEdge(tanPoints){\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for (let i=0;i<tanPoints.length;i++){\r\n            let points=tanPoints[i]\r\n            for(let e=0;e<this.elementSpace[i].length;e++){\r\n                let eseg=this.elementSpace[i][e]\r\n                if(eseg.type==\"arc\"){\r\n                    let onpoints=[]\r\n                    let dearray=[]\r\n                    for(let p=0;p<points.length;p++){\r\n                        if(this.isPointOnArc([points[p].x,points[p].y],eseg)){\r\n                            onpoints.push(points[p])\r\n                        }\r\n                    }\r\n                    //sort the points according to degree\r\n\r\n                    let startpoint=this.tanGraphPoints[eseg.startid]\r\n                    let endpoint=this.tanGraphPoints[eseg.endid]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n\r\n                    for (let p=0;p<onpoints.length;p++){\r\n                        let pointvec=[onpoints[p].x-eseg.center[0],onpoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n\r\n                        dearray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n                    dearray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<dearray.length;d++){\r\n                        nextd=onpoints[dearray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:nextd.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            })\r\n                        }\r\n\r\n\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:endpoint.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                    /*                    if(this.tanGraphEdges.length>=60036){\r\n                                            console.log()\r\n                                        }*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    findApproxPointOnArc(point,arc){\r\n        let polypoints=arc.polysegment\r\n        let startpoint=arc.start\r\n        let center=arc.center\r\n        let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let degree=getDegreeTwoVec(startvec,pointvec)\r\n        let crossmul1=crossMul(startvec,pointvec)\r\n        if(crossmul1>0){\r\n            degree=2*Math.PI-degree\r\n        }\r\n        if(degree<0.000001){\r\n            return 0\r\n        }\r\n        let index=parseInt(degree/deltaDeg)\r\n\r\n        /*        if(index>polypoints.length-1){\r\n                    d3.select(\"svg\").selectAll(\"circle\").remove()\r\n                    drawCircle(point[0],point[1],5,\"red\",\"none\")\r\n                    drawCircle(polypoints[polypoints.length-1][0],polypoints[polypoints.length-1][1],5,\"blue\",\"none\")\r\n                    drawCircle(polypoints[0][0],polypoints[0][1],5,\"black\",\"none\")\r\n\r\n                }*/\r\n\r\n        return index\r\n    }\r\n\r\n    isExist(p,points){\r\n        for(let i=0;i<points.length;i++){\r\n            if(p[0]==points[i].x&&p[1]==points[i].y){\r\n                return points[i].id\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n\r\n    calTanGraphWithPolygon(){\r\n        let tempTanEdges=[]\r\n        let tempTanPoints=[]\r\n        let pointsOnSameArc=[]\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            pointsOnSameArc.push([])\r\n        }\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.tanGraphPoints.push({\r\n                type:\"datapoint\",\r\n                x:this.pointData[i].x,\r\n                y:this.pointData[i].y,\r\n                dataindex:i,\r\n                id:i\r\n            })\r\n            tanPointsNum+=1\r\n        }\r\n        this.initVI()\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            tempTanPoints.push(this.newVI[i])\r\n        }\r\n        //console.log(this.catPointDict)\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            let index1=this.pointData[i].id\r\n            /*                if(index1==35) {\r\n                                drawCircle(points[i].x,points[i].y,2,\"red\",\"none\")\r\n                            }*/\r\n            let eleSpace1=this.elementSpace[index1]\r\n\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let index2=this.pointData[j].id\r\n                let eleSpace2=this.elementSpace[index2]\r\n\r\n                //type a\r\n                let type1Edge=calCommonTanPoint(this.pointData[i].x,this.pointData[i].y,re,this.pointData[j].x,this.pointData[j].y,re)\r\n                for (let l=0;l<type1Edge.length;l++){\r\n                    let line=type1Edge[l]\r\n                    let linestart=line[0]\r\n                    let lineend=line[1]\r\n\r\n\r\n                    let starton=false\r\n                    let endon=false\r\n                    let arc1\r\n                    let arc2\r\n                    if(eleSpace1.length>1){\r\n                        for (let e=0;e<eleSpace1.length;e++){\r\n                            if(eleSpace1[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(linestart,eleSpace1[e])){\r\n                                    // drawLine(linestart,lineend)\r\n                                    starton=true\r\n                                    arc1=eleSpace1[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        starton=true\r\n                        arc1=eleSpace1[0]\r\n                    }\r\n                    if(eleSpace2.length>1){\r\n                        for (let e=0;e<eleSpace2.length;e++){\r\n                            if(eleSpace2[e].type==\"arc\"){\r\n                                if(this.isPointOnArc(lineend,eleSpace2[e])){\r\n                                    endon=true\r\n                                    arc2=eleSpace2[e]\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        arc2=eleSpace2[0]\r\n                        endon=true\r\n                    }\r\n\r\n                    if(starton&&endon){\r\n                        let polyindex1=this.findApproxPointOnArc(linestart,arc1)\r\n                        let tanpoint1=arc1.polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        // drawCircle(tanpoint1[0],tanpoint1[1],2,\"green\",\"none\")\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:index1,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[index1].push(tanpoint)\r\n                        }\r\n\r\n                        let polyindex2=this.findApproxPointOnArc(lineend,arc2)\r\n\r\n                        let tanpoint2=arc2.polysegment[polyindex2]\r\n                        // drawCircle(tanpoint2[0],tanpoint2[1],2,\"green\",\"none\")\r\n\r\n                        let existindex2=this.isExist(tanpoint2,tempTanPoints)\r\n                        if(existindex2==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint2[0],\r\n                                y:tanpoint2[1],\r\n                                dataindex:index2,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex2=tanpoint.id\r\n                            pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                        }\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:existindex1,\r\n                            endid:existindex2,\r\n                            // startpoint:linestart,\r\n                            // endpoint:lineend\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push({\r\n                                type:\"line\",\r\n                                startid:existindex1,\r\n                                endid:existindex2,\r\n                                // startpoint:linestart,\r\n                                // endpoint:lineend\r\n                            })\r\n                        }\r\n\r\n                        // drawLine([this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],[this.tanGraphPoints[existindex2].x,this.tanGraphPoints[existindex2].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n\r\n                }\r\n\r\n                //type b\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let p = 0; p < this.pointData[i].catArray.length; p ++){\r\n                    for(let q = 0; q < this.pointData[j].catArray.length; q ++){\r\n                        if(this.pointData[i].catArray[p] == this.pointData[j].catArray[q]){\r\n                            sameflag = true\r\n                            addcat.push(this.pointData[i].catArray[p])\r\n                        }\r\n                    }\r\n                }\r\n                //if(sameflag){\r\n                if(true){\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:index1,\r\n                        endid:index2,\r\n                        // startpoint:[points[i].x,points[i].y],\r\n                        // endpoint:[points[j].x,points[j].y]\r\n                    })\r\n\r\n                    for(let p = 0; p < addcat.length; p ++){\r\n                        this.rGEdges[addcat[p]].push({\r\n                            type:\"line\",\r\n                            startid:index1,\r\n                            endid:index2,\r\n                            // startpoint:[points[i].x,points[i].y],\r\n                            // endpoint:[points[j].x,points[j].y]\r\n                        })\r\n                    }\r\n\r\n\r\n                    if(calDistance(this.pointData[i].x,this.pointData[i].y,this.pointData[j].x,this.pointData[j].y)>re){\r\n                        //p to q\r\n                        let tanPoints=calTanPoint(this.pointData[j].x,this.pointData[j].y,re,{x:this.pointData[i].x,y:this.pointData[i].y})\r\n                        tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                        if(eleSpace2.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace2[0])\r\n                            let tanpoint0=eleSpace2[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace2[0])\r\n                            let tanpoint1=eleSpace2[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index2,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index1,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index1,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n\r\n                        }\r\n                        else{\r\n\r\n                            for (let p=0;p<tanPoints.length;p++){\r\n                                for (let e=0;e<eleSpace2.length;e++){\r\n                                    if(eleSpace2[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints[p].x,tanPoints[p].y],eleSpace2[e])\r\n                                            let tanpoint=eleSpace2[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index2,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index2].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index1,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index1,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n                                            // drawLine([this.tanGraphPoints[index1].x,this.tanGraphPoints[index1].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        //q to p\r\n                        let tanPoints2=calTanPoint(this.pointData[i].x,this.pointData[i].y,re,{x:this.pointData[j].x,y:this.pointData[j].y})\r\n                        tanPoints2=[tanPoints2.p1,tanPoints2.p2]\r\n                        if(eleSpace1.length==1){\r\n                            let polyindex0=this.findApproxPointOnArc([tanPoints2[0].x,tanPoints2[0].y],eleSpace1[0])\r\n                            let tanpoint0=eleSpace1[0].polysegment[polyindex0]\r\n                            let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                            if(existindex0==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint0[0],\r\n                                    y:tanpoint0[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex0=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n                            let polyindex1=this.findApproxPointOnArc([tanPoints2[1].x,tanPoints2[1].y],eleSpace1[0])\r\n                            let tanpoint1=eleSpace1[0].polysegment[polyindex1]\r\n                            let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                            if(existindex1==-1){\r\n                                let tanpoint={\r\n                                    type:\"tanpoint\",\r\n                                    x:tanpoint1[0],\r\n                                    y:tanpoint1[1],\r\n                                    dataindex:index1,\r\n                                    id:tanPointsNum\r\n                                }\r\n                                this.tanGraphPoints.push(tanpoint)\r\n                                tempTanPoints.push(tanpoint)\r\n                                tanPointsNum+=1\r\n                                existindex1=tanpoint.id\r\n                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                            }\r\n\r\n\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex0,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                            })\r\n                            this.tanGraphEdges.push({\r\n                                type:\"line\",\r\n                                startid:index2,\r\n                                endid:existindex1,\r\n                                // startpoint:[points[i].x,points[i].y],\r\n                                // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                            })\r\n\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex0,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                })\r\n                            }\r\n\r\n                            for(let cat_k in this.catPointDict){\r\n                                this.rGEdges[cat_k].push({\r\n                                    type:\"line\",\r\n                                    startid:index2,\r\n                                    endid:existindex1,\r\n                                    // startpoint:[points[i].x,points[i].y],\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                })\r\n                            }\r\n\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                            // console.log()\r\n                        }\r\n                        else{\r\n                            for (let p=0;p<tanPoints2.length;p++){\r\n                                for (let e=0;e<eleSpace1.length;e++){\r\n                                    if(eleSpace1[e].type==\"arc\"){\r\n                                        if(this.isPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])){\r\n                                            let polyindex=this.findApproxPointOnArc([tanPoints2[p].x,tanPoints2[p].y],eleSpace1[e])\r\n                                            let tanpoint=eleSpace1[e].polysegment[polyindex]\r\n                                            let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                            if(existindex==-1){\r\n                                                let tanpointp={\r\n                                                    type:\"tanpoint\",\r\n                                                    x:tanpoint[0],\r\n                                                    y:tanpoint[1],\r\n                                                    dataindex:index1,\r\n                                                    id:tanPointsNum\r\n                                                }\r\n                                                this.tanGraphPoints.push(tanpointp)\r\n                                                tempTanPoints.push(tanpointp)\r\n                                                tanPointsNum+=1\r\n                                                existindex=tanpointp.id\r\n                                                pointsOnSameArc[index1].push(tanpoint)\r\n\r\n                                            }\r\n                                            this.tanGraphEdges.push({\r\n                                                type:\"line\",\r\n                                                startid:index2,\r\n                                                endid:existindex,\r\n                                                // startpoint:[points[i].x,points[i].y],\r\n                                                // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                            })\r\n\r\n                                            for(let cat_k in this.catPointDict){\r\n                                                this.rGEdges[cat_k].push({\r\n                                                    type:\"line\",\r\n                                                    startid:index2,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                })\r\n                                            }\r\n\r\n\r\n                                            // drawLine([this.tanGraphPoints[index2].x,this.tanGraphPoints[index2].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                            // console.log()\r\n                                            break\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        //type c\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let cat1=this.pointData[this.newVI[i].dataindex[0]].catArray\r\n            for(let p=0;p<this.pointData.length;p++){\r\n                let cat2=this.pointData[p].catArray\r\n                // if(cat1!=cat2){\r\n                //     continue\r\n                // }\r\n                let dis=calDistance(this.newVI[i].x,this.newVI[i].y,this.pointData[p].x,this.pointData[p].y)\r\n\r\n                let sameflag = false\r\n                let addcat = []\r\n                for(let id1 = 0; id1 < cat1.length; id1 ++){\r\n                    for(let id2 = 0; id2 < cat2.length; id2 ++){\r\n                        if(cat1[id1] == cat2[id2]){\r\n                            sameflag = true\r\n                            addcat.push(cat1[id1])\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //if(sameflag){\r\n                if(true){\r\n                    this.tanGraphEdges.push({\r\n                        type:\"line\",\r\n                        startid:this.newVI[i].id,\r\n                        endid:this.pointData[p].id,\r\n                        // startpoint:[points[j].x,points[j].y],\r\n                        // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                    })\r\n\r\n                    for(let cur_idx = 0; cur_idx < addcat.length; cur_idx ++){\r\n                        this.rGEdges[addcat[cur_idx]].push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:this.pointData[p].id,\r\n                            // startpoint:[points[j].x,points[j].y],\r\n                            // endpoint:[tanPoints2[p].x,tanPoints2[p].y]\r\n                        })\r\n                    }\r\n\r\n                }\r\n\r\n                if(dis>re){\r\n                    let tanPoints=calTanPoint(this.pointData[p].x,this.pointData[p].y,re,{x:this.newVI[i].x,y:this.newVI[i].y})\r\n                    tanPoints=[tanPoints.p1,tanPoints.p2]\r\n                    let eleSpace=this.elementSpace[p]\r\n                    if(eleSpace.length==1){\r\n                        let polyindex0=this.findApproxPointOnArc([tanPoints[0].x,tanPoints[0].y],eleSpace[0])\r\n                        let tanpoint0=eleSpace[0].polysegment[polyindex0]\r\n                        let existindex0=this.isExist(tanpoint0,tempTanPoints)\r\n                        if(existindex0==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint0[0],\r\n                                y:tanpoint0[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex0=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        let polyindex1=this.findApproxPointOnArc([tanPoints[1].x,tanPoints[1].y],eleSpace[0])\r\n                        let tanpoint1=eleSpace[0].polysegment[polyindex1]\r\n                        let existindex1=this.isExist(tanpoint1,tempTanPoints)\r\n                        if(existindex1==-1){\r\n                            let tanpoint={\r\n                                type:\"tanpoint\",\r\n                                x:tanpoint1[0],\r\n                                y:tanpoint1[1],\r\n                                dataindex:p,\r\n                                id:tanPointsNum\r\n                            }\r\n                            this.tanGraphPoints.push(tanpoint)\r\n                            tempTanPoints.push(tanpoint)\r\n                            tanPointsNum+=1\r\n                            existindex1=tanpoint.id\r\n                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                        }\r\n\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex0,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                        })\r\n                        this.tanGraphEdges.push({\r\n                            type:\"line\",\r\n                            startid:this.newVI[i].id,\r\n                            endid:existindex1,\r\n                            // startpoint:vp,\r\n                            // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex0,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[0].x,tanPoints[0].y]\r\n                                }\r\n                            )\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"line\",\r\n                                    startid:this.newVI[i].id,\r\n                                    endid:existindex1,\r\n                                    // startpoint:vp,\r\n                                    // endpoint:[tanPoints[1].x,tanPoints[1].y]\r\n                                }\r\n                            )\r\n                        }\r\n\r\n\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex0].x,this.tanGraphPoints[existindex0].y],\"red\",2)\r\n                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex1].x,this.tanGraphPoints[existindex1].y],\"red\",2)\r\n                        // console.log()\r\n                    }\r\n                    else{\r\n                        for (let t=0;t<tanPoints.length;t++) {\r\n                            for (let e = 0; e < eleSpace.length; e++) {\r\n                                if (eleSpace[e].type == \"arc\") {\r\n                                    if (this.isPointOnArc([tanPoints[t].x, tanPoints[t].y], eleSpace[e])) {\r\n\r\n                                        let polyindex=this.findApproxPointOnArc([tanPoints[t].x,tanPoints[t].y],eleSpace[e])\r\n                                        let tanpoint=eleSpace[e].polysegment[polyindex]\r\n                                        let existindex=this.isExist(tanpoint,tempTanPoints)\r\n\r\n                                        if(existindex==-1){\r\n                                            let tanpointp={\r\n                                                type:\"tanpoint\",\r\n                                                x:tanpoint[0],\r\n                                                y:tanpoint[1],\r\n                                                dataindex:p,\r\n                                                id:tanPointsNum\r\n                                            }\r\n                                            this.tanGraphPoints.push(tanpointp)\r\n                                            tempTanPoints.push(tanpointp)\r\n                                            tanPointsNum+=1\r\n                                            existindex=tanpointp.id\r\n                                            pointsOnSameArc[p].push(tanpoint)\r\n\r\n                                        }\r\n                                        this.tanGraphEdges.push({\r\n                                            type:\"line\",\r\n                                            startid:this.newVI[i].id,\r\n                                            endid:existindex,\r\n                                            // startpoint:[points[i].x,points[i].y],\r\n                                            // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                        })\r\n\r\n                                        for(let cat_k in this.catPointDict){\r\n                                            this.rGEdges[cat_k].push(\r\n                                                {\r\n                                                    type:\"line\",\r\n                                                    startid:this.newVI[i].id,\r\n                                                    endid:existindex,\r\n                                                    // startpoint:[points[i].x,points[i].y],\r\n                                                    // endpoint:[tanPoints[p].x,tanPoints[p].y]\r\n                                                }\r\n                                            )\r\n                                        }\r\n\r\n\r\n                                        // drawLine([this.tanGraphPoints[this.newVI[i].id].x,this.tanGraphPoints[this.newVI[i].id].y],[this.tanGraphPoints[existindex].x,this.tanGraphPoints[existindex].y],\"red\",2)\r\n                                        // console.log()\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        this.addCircularEdge(pointsOnSameArc)\r\n    }\r\n\r\n    above(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) > 0\r\n    }\r\n\r\n    below(P,Vi,Vj)  {\r\n        return this.isLeft(P,Vi,Vj) < 0\r\n    }\r\n\r\n    isLeft(P0, P1, P2) {\r\n        return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n    }\r\n\r\n    RLtangent_PolyPolyC(V, W) {\r\n        let  ix1, ix2;      // search indices for polygons 1 and 2\r\n\r\n        // first get the initial vertex on each polygon\r\n        // ix1 = this.Rtangent_PointPolyC(W[0], V);   // right tangent from W[0] to V\r\n        ix1=this.tangent_PointPoly(W[0],V)[1]\r\n        // ix2 = this.Ltangent_PointPolyC(V[ix1], W); // left tangent from V[ix1] to W\r\n\r\n        ix2=this.tangent_PointPoly(V[ix1],W)[0]\r\n\r\n        // ping-pong linear search until it stabilizes\r\n        let done = false                    // flag when done\r\n        while (done == false) {\r\n            done = true;                     // assume done until...\r\n            while (this.isLeft(W[(ix2+W.length)%W.length], V[ix1], V[ix1+1]) <= 0){\r\n                ++ix1;                       // get Rtangent from W[ix2] to V\r\n            }\r\n\r\n            while (this.isLeft(V[ix1], W[(ix2+W.length)%W.length], W[(ix2-1+W.length)%W.length]) >= 0){\r\n                --ix2;                       // get Ltangent from V[ix1] to W\r\n                done = false;                // not done if had to adjust this\r\n            }\r\n        }\r\n        let t1 = ix1;\r\n        let t2 = ix2;\r\n        if(t1<0){\r\n            t1=t1+V.length\r\n        }\r\n        if(t2<0){\r\n            t2=t2+W.length\r\n        }\r\n\r\n        return[t1,t2]\r\n    }\r\n\r\n    drawSpacePathWithPolygon(){\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let espace=this.elementPoly[i]\r\n            let nowp=espace[0]\r\n            let nextp\r\n            for (let e=1;e<espace.length;e++){\r\n                nextp=espace[e]\r\n                drawLine([nowp.x,nowp.y],[nextp.x,nextp.y],\"black\",1)\r\n                nowp=nextp\r\n            }\r\n        }\r\n    }\r\n\r\n    approxArcWithPolygon(){\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            for (let e=0;e<espace.length;e++){\r\n\r\n                let center=espace[e].center\r\n                let radius=espace[e].radius\r\n                if(espace[e].type==\"arc\"){\r\n                    let startpoint=espace[e].start\r\n                    let endpoint=espace[e].end\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    let endvec=[endpoint[0]-center[0],endpoint[1]-center[1]]\r\n                    // let vecstart=[espace[e].]\r\n                    let degree=getDegreeTwoVec(startvec,endvec)\r\n\r\n                    let crossmul1=crossMul(startvec,endvec)\r\n                    if(crossmul1>0){\r\n                        degree=2*Math.PI-degree\r\n                    }\r\n\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n\r\n                    polySegs.push(startpoint)\r\n                    while(d<degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n                else if(espace[e].type==\"circle\"){\r\n                    let startpoint=[center[0]-radius,center[1]]\r\n                    let endpoint=startpoint\r\n                    espace[e].start=startpoint\r\n                    espace[e].end=endpoint\r\n                    let startvec=[startpoint[0]-center[0],startpoint[1]-center[1]]\r\n                    // drawCircle(startpoint[0],startpoint[1],5,\"blue\",\"none\")\r\n                    // drawCircle(endpoint[0],endpoint[1],5,\"green\",\"none\")\r\n                    let degree=Math.PI*2\r\n                    let d=deltaDeg\r\n                    let polySegs=[]\r\n                    polySegs.push(startpoint)\r\n                    while(d<=degree){\r\n                        //rotate the startpoint\r\n                        let segpoint=rotatePoint(startpoint[0],startpoint[1],center[0],center[1],-1*d)\r\n                        // drawCircle(segpoint[0],segpoint[1],2,\"red\",\"none\")\r\n                        polySegs.push(segpoint)\r\n                        d+=deltaDeg\r\n                    }\r\n                    if(d!=degree){\r\n                        polySegs.push(endpoint)\r\n                    }\r\n                    this.elementSpace[i][e].polysegment=polySegs\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.elementSpace.length;i++){\r\n            let espace=this.elementSpace[i]\r\n            let newespace=[]\r\n            for (let e=0;e<espace.length;e++){\r\n                if(espace[e].type==\"line\"){\r\n                    newespace.push(espace[e])\r\n                }\r\n                else{\r\n                    //arc segments\r\n                    let nowp=espace[e].polysegment[0]\r\n                    for (let s=1;s<espace[e].polysegment.length;s++){\r\n                        let nextp=espace[e].polysegment[s]\r\n                        newespace.push({\r\n                            type:\"line\",\r\n                            center:espace[e].center,\r\n                            radius:re,\r\n                            start:nowp,\r\n                            end:nextp\r\n                        })\r\n                        nowp=nextp\r\n                    }\r\n                }\r\n            }\r\n            this.elementPoly.push(newespace)\r\n        }\r\n\r\n        for (let i=0;i<this.elementPoly.length;i++){\r\n            let eseg=this.elementPoly[i]\r\n            let newsegs=[]\r\n            newsegs.push({\r\n                x:eseg[0].start[0],\r\n                y:eseg[0].start[1],\r\n                degree:0\r\n            })\r\n            for (let e=0;e<eseg.length;e++){\r\n                let point=eseg[e].end\r\n                newsegs.push({\r\n                    x:point[0],\r\n                    y:point[1],\r\n                    degree:0\r\n                })\r\n            }\r\n            this.elementPoly[i]=newsegs\r\n        }\r\n\r\n        console.log(this.elementPoly)\r\n\r\n    }\r\n\r\n    calVoronoiDiagram(){\r\n        let that=this\r\n        let diagram=d3Voronoi.voronoi()\r\n            .extent([[that.minX-50,that.minY-50],[that.maxX+50,that.maxY+50]])\r\n            .x(function(d){\r\n                return d.x\r\n            })\r\n            .y(function(d){\r\n                return d.y\r\n            })\r\n        let polygons=diagram.polygons(this.pointData)\r\n        this.voronoiPolygons=polygons\r\n        //Polygons are also counterclockwise\r\n        /*        for (let i=0;i<polygons.length;i++){\r\n                    drawPolygon(polygons[i],0,0,\"red\")\r\n                }*/\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    drawCircle(this.pointData[i].x,this.pointData[i].y,re,\"none\",\"black\")\r\n                }*/\r\n\r\n        console.log(polygons)\r\n\r\n    }\r\n\r\n    calElementSpace(){\r\n        for (let i=0;i<this.voronoiPolygons.length;i++){\r\n            let polypoints=this.voronoiPolygons[i]\r\n            let pointnum=polypoints.length\r\n            let data=polypoints.data\r\n            let id=polypoints.data.id\r\n            let eleSpace=[]\r\n            let insideLines=[]\r\n            let circle=ShapeInfo.circle({cx: data.x, cy: data.y, r: re})\r\n            let vi=[]\r\n            for (let p=0;p<polypoints.length;p++){\r\n                let thisp=polypoints[p]\r\n                let nextp=polypoints[(p+1)%pointnum]\r\n                // drawLine(thisp,nextp,\"blue\")\r\n                //check intersection between line and circle\r\n                let inside=IntersectionQuery.pointInCircle( {x:thisp[0],y:thisp[1]}, {x:data.x,y:data.y} ,  re)\r\n                if(inside){\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        insideLines.push([thisp,nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([thisp,[point.x,point.y]])\r\n                    }\r\n                }\r\n                else{\r\n                    let inside2=IntersectionQuery.pointInCircle( {x:nextp[0],y:nextp[1]}, {x:data.x,y:data.y} ,  re)\r\n                    if(inside2){\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        let point=intersections.points[0]\r\n                        vi.push([point.x,point.y])\r\n                        insideLines.push([[point.x,point.y],nextp])\r\n                    }\r\n                    else{\r\n                        let line=ShapeInfo.line(thisp, nextp)\r\n                        const intersections = Intersection.intersect(circle, line);\r\n                        if(intersections.status==\"Intersection\"){\r\n                            let points=intersections.points\r\n                            let dis1=calDistance(thisp[0],thisp[1],points[0].x,points[0].y)\r\n                            let dis2=calDistance(thisp[0],thisp[1],points[1].x,points[1].y)\r\n                            if(dis1<dis2){\r\n                                insideLines.push([[points[0].x,points[0].y],[points[1].x,points[1].y]])\r\n                                vi.push([points[0].x,points[0].y])\r\n                                vi.push([points[1].x,points[1].y])\r\n                            }\r\n                            else{\r\n                                insideLines.push([[points[1].x,points[1].y],[points[0].x,points[0].y]])\r\n                                vi.push([points[1].x,points[1].y])\r\n                                vi.push([points[0].x,points[0].y])\r\n                            }\r\n                        }\r\n                        else{\r\n                            //no intersection with the circle\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.VI.push(vi)\r\n            if(insideLines.length>0){\r\n                for (let l=0;l<insideLines.length;l++){\r\n                    // drawLine(insideLines[l][0],insideLines[l][1],\"blue\")\r\n                    eleSpace.push({\r\n                        type:\"line\",\r\n                        start:insideLines[l][0],\r\n                        end:insideLines[l][1],\r\n                        center:[data.x,data.y],\r\n                        radius:re\r\n                    })\r\n                    let point1=insideLines[l][1]\r\n                    let point2=insideLines[(l+1)%insideLines.length][0]\r\n                    if(point1[0]==point2[0]&&point1[1]==point2[1]){\r\n\r\n                    }\r\n                    else{\r\n                        //insert an arc\r\n                        eleSpace.push({\r\n                            type:\"arc\",\r\n                            start:point1,\r\n                            end:point2,\r\n                            center:[data.x,data.y],\r\n                            radius:re\r\n                        })\r\n                    }\r\n\r\n                }\r\n            }\r\n            else{\r\n                eleSpace.push({\r\n                    type:\"circle\",\r\n                    start:[],\r\n                    end:[],\r\n                    center:[data.x,data.y],\r\n                    radius:re\r\n                })\r\n            }\r\n            this.elementSpace.push(eleSpace)\r\n        }\r\n        console.log(this.elementSpace)\r\n    }\r\n\r\n    initVI(){\r\n        // console.log(this.VI)\r\n        let newVI=[]\r\n        for (let i=0;i<this.VI.length;i++){\r\n            for (let j=0;j<this.VI[i].length;j++){\r\n                let vpoint=this.VI[i][j]\r\n                let has=false\r\n                for (let v=0;v<newVI.length;v++){\r\n                    if(vpoint[0]==newVI[v].x&&vpoint[1]==newVI[v].y){\r\n                        has=true\r\n                        break\r\n                    }\r\n                }\r\n                if(!has){\r\n                    let vipoint={\r\n                        type:\"vi\",\r\n                        x:vpoint[0],\r\n                        y:vpoint[1],\r\n                        dataindex:[i,j],\r\n                        id:tanPointsNum\r\n                    }\r\n                    tanPointsNum+=1\r\n                    newVI.push(vipoint)\r\n                    this.tanGraphPoints.push(vipoint)\r\n                }\r\n            }\r\n\r\n        }\r\n        this.newVI=newVI\r\n        for(let i=0;i<newVI.length;i++){\r\n            for (let e=0;e<this.elementSpace.length;e++){\r\n                let espace=this.elementSpace[e]\r\n                for (let s=0;s<espace.length;s++){\r\n                    let eseg=espace[s]\r\n                    if(eseg.type==\"arc\"){\r\n                        let start=eseg.start\r\n                        let end=eseg.end\r\n                        if(start[0]==newVI[i].x&&start[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].startid=newVI[i].id\r\n                        }\r\n                        if(end[0]==newVI[i].x&&end[1]==newVI[i].y){\r\n                            this.elementSpace[e][s].endid=newVI[i].id\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(this.newVI)\r\n    }\r\n\r\n    isPointOnArc(point,arc){\r\n        let start=arc.start\r\n        let end=arc.end\r\n        let center=arc.center\r\n        let startvec=[start[0]-center[0],start[1]-center[1]]\r\n        let endvec=[end[0]-center[0],end[1]-center[1]]\r\n        let pointvec=[point[0]-center[0],point[1]-center[1]]\r\n        let startEndDeg=getDegreeTwoVec(startvec,endvec)\r\n        let pointStartDeg=getDegreeTwoVec(startvec,pointvec)\r\n\r\n        let crossmul1=crossMul(startvec,endvec)\r\n\r\n        if(crossmul1>0){\r\n            startEndDeg=2*Math.PI-startEndDeg\r\n        }\r\n\r\n        let crossmul2=crossMul(startvec,pointvec)\r\n\r\n        if(crossmul2>0){\r\n            pointStartDeg=2*Math.PI-pointStartDeg\r\n        }\r\n\r\n        if(pointStartDeg<=startEndDeg){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    splitCircularEdge(){\r\n        let viMap=[]\r\n        let tanPointMap=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            viMap.push([])\r\n            tanPointMap.push([])\r\n        }\r\n        for (let i=0;i<this.newVI.length;i++){\r\n            let id=this.newVI[i].dataindex[0]\r\n            viMap[id].push(this.newVI[i])\r\n        }\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            if(this.tanGraphPoints[i].type==\"tanpoint\"){\r\n                let index=this.tanGraphPoints[i].dataindex\r\n                tanPointMap[index].push(this.tanGraphPoints[i])\r\n            }\r\n        }\r\n\r\n        /*        for (let i=0;i<tanPointMap.length;i++){\r\n                    if(i==91){\r\n                        for (let j=0;j<tanPointMap[i].length;j++){\r\n                            drawCircle(tanPointMap[i][j].x,tanPointMap[i][j].y,2,\"red\",\"none\")\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n\r\n        function sortDegree(a,b){\r\n            return a.degree-b.degree\r\n        }\r\n        for(let i=0;i<this.elementSpace.length;i++){\r\n            let elespace=this.elementSpace[i]\r\n            let vis=viMap[i]\r\n            let tanpoints=tanPointMap[i]\r\n            for(let e=0;e<elespace.length;e++){\r\n                let eseg=elespace[e]\r\n                if(eseg.type==\"arc\"){\r\n                    //split this eseg\r\n                    let startindex=-1\r\n                    let endindex=-1\r\n                    let startpoint\r\n                    let endpoint\r\n                    let onPoints=[]\r\n                    for (let v=0;v<vis.length;v++){\r\n                        if(vis[v].x==eseg.start[0]&&vis[v].y==eseg.start[1]){\r\n                            startindex=vis[v].id\r\n                            startpoint=this.tanGraphPoints[startindex]\r\n                        }\r\n                        if(vis[v].x==eseg.end[0]&&vis[v].y==eseg.end[1]){\r\n                            endindex=vis[v].id\r\n                            endpoint=this.tanGraphPoints[endindex]\r\n                        }\r\n                    }\r\n                    for (let t=0;t<tanpoints.length;t++){\r\n                        if(this.isPointOnArc([tanpoints[t].x,tanpoints[t].y],eseg)){\r\n                            onPoints.push(tanpoints[t])\r\n                        }\r\n                    }\r\n                    // console.log(startindex,endindex,onPoints)\r\n                    /*                    if(i==91){\r\n                                            drawCircle(startpoint.x,startpoint.y,5,\"red\",\"none\")\r\n                                            drawCircle(endpoint.x,endpoint.y,5,\"green\",\"none\")\r\n                                            for (let o=0;o<onPoints.length;o++){\r\n                                                drawCircle(onPoints[o].x,onPoints[o].y,2,\"blue\",\"none\")\r\n                                            }\r\n\r\n                                        }*/\r\n\r\n                    let deArray=[]\r\n                    let startvec=[startpoint.x-eseg.center[0],startpoint.y-eseg.center[1]]\r\n                    let endvec=[endpoint.x-eseg.center[0],endpoint.y-eseg.center[1]]\r\n                    for (let p=0;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n\r\n                    }\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=startpoint\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6001){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:endpoint.id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:endpoint.id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n                else if(eseg.type==\"circle\"){\r\n                    let onPoints=tanpoints\r\n                    let startvec=[onPoints[0].x-eseg.center[0],onPoints[0].y-eseg.center[1]]\r\n                    let deArray=[]\r\n                    for (let p=1;p<onPoints.length;p++){\r\n                        let pointvec=[onPoints[p].x-eseg.center[0],onPoints[p].y-eseg.center[1]]\r\n                        let degree=getDegreeTwoVec(startvec,pointvec)\r\n                        let crossmul=crossMul(startvec,pointvec)\r\n                        if(crossmul>0){\r\n                            degree=2*Math.PI-degree\r\n                        }\r\n                        deArray.push({\r\n                            index:p,\r\n                            degree:degree\r\n                        })\r\n                    }\r\n\r\n                    deArray.sort(sortDegree)\r\n                    let thisd=onPoints[0]\r\n                    let nextd\r\n                    for (let d=0;d<deArray.length;d++){\r\n                        nextd=onPoints[deArray[d].index]\r\n                        this.tanGraphEdges.push({\r\n                            type:\"arc\",\r\n                            startid:thisd.id,\r\n                            endid:nextd.id,\r\n                            center:eseg.center,\r\n                            radius:re\r\n                        })\r\n\r\n                        for(let cat_k in this.catPointDict){\r\n                            this.rGEdges[cat_k].push(\r\n                                {\r\n                                    type:\"arc\",\r\n                                    startid:thisd.id,\r\n                                    endid:nextd.id,\r\n                                    center:eseg.center,\r\n                                    radius:re\r\n                                }\r\n                            )\r\n                        }\r\n\r\n                        // if(this.tanGraphEdges.length==6002){\r\n                        //     console.log()\r\n                        // }\r\n                        thisd=nextd\r\n                    }\r\n\r\n                    this.tanGraphEdges.push({\r\n                        type:\"arc\",\r\n                        startid:thisd.id,\r\n                        endid:onPoints[0].id,\r\n                        center:eseg.center,\r\n                        radius:re\r\n                    })\r\n\r\n\r\n                    for(let cat_k in this.catPointDict){\r\n                        this.rGEdges[cat_k].push(\r\n                            {\r\n                                type:\"arc\",\r\n                                startid:thisd.id,\r\n                                endid:onPoints[0].id,\r\n                                center:eseg.center,\r\n                                radius:re\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    // if(this.tanGraphEdges.length==6001){\r\n                    //     console.log()\r\n                    // }\r\n\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n        console.log(this.tanGraphEdges)\r\n        /*        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n                    if(this.tanGraphPoints[i].dataindex==91){\r\n                        drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"green\",\"none\")\r\n                    }\r\n                }*/\r\n    }\r\n\r\n    drawSplitEdge(){\r\n        for(let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].type==\"arc\"){\r\n                let pathstr=\"\"\r\n                let startid=this.tanGraphEdges[i].startid\r\n                let endid=this.tanGraphEdges[i].endid\r\n                let startp=[this.tanGraphPoints[startid].x,this.tanGraphPoints[startid].y]\r\n                let endp=[this.tanGraphPoints[endid].x,this.tanGraphPoints[endid].y]\r\n                let center=this.tanGraphEdges[i].center\r\n                let radius=this.tanGraphEdges[i].radius\r\n\r\n                // drawCircle(startp[0],startp[1],2,\"red\",\"none\")\r\n                // drawCircle(endp[0],endp[1],2,\"red\",\"none\")\r\n\r\n                pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n                let largearcflag=0\r\n                let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n                let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n\r\n                /*                    if(i==5){\r\n                                        drawCircle(center[0],center[1],5,\"black\",\"none\")\r\n\r\n                                        drawCircle(startp[0],startp[1],5,\"red\",\"none\")\r\n                                        drawCircle(endp[0],endp[1],5,\"blue\",\"none\")\r\n                                        drawLine(vec1[0],vec1[1],\"red\")\r\n                                        drawLine(vec2[0],vec2[1],\"blue\")\r\n\r\n\r\n                                    }*/\r\n\r\n                let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n                if(crossmul>0){\r\n                    largearcflag=1\r\n                }\r\n                else if(crossmul<=0){\r\n                    largearcflag=0\r\n                }\r\n\r\n                pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n                d3.select(\"svg\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\",pathstr)\r\n                    .attr(\"fill\",\"none\")\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"stroke-width\",\"1\")\r\n            }\r\n        }\r\n    }\r\n\r\n    normalizeEdgeLength(){\r\n        let maxDis=-1\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            if(this.tanGraphEdges[i].distance>maxDis){\r\n                maxDis=this.tanGraphEdges[i].distance\r\n            }\r\n        }\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            this.tanGraphEdges[i].distance=this.tanGraphEdges[i].distance/maxDis\r\n        }\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calPathLength(path){\r\n        let length=0\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let startid=e.from()\r\n            let endid=e.to()\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            length+=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n        }\r\n        return length\r\n    }\r\n\r\n    isSamePath(path1,path2){\r\n        if(path1.length!=path2.length){\r\n            return false\r\n        }\r\n        for (let i=0;i<path1.length;i++){\r\n            let start1=path1[i].from()\r\n            let end1=path1[i].to()\r\n            let start2=path2[i].from()\r\n            let end2=path2[i].to()\r\n            if(start1==start2&&end1==end2||start1==end2&&start2==end1){\r\n\r\n            }\r\n            else{\r\n                return false\r\n            }\r\n\r\n        }\r\n        return true\r\n    }\r\n\r\n    drawPath(path){\r\n        let that=this\r\n        for (let i=0;i<path.length;i++){\r\n            let e=path[i]\r\n            let edgeid=e.label\r\n            let edge=this.tanGraphEdges[edgeid]\r\n            let startpoint=this.tanGraphPoints[edge.startid]\r\n            let endpoint=this.tanGraphPoints[edge.endid]\r\n            if(edge.type==\"line\"){\r\n                // drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"red\",2)\r\n                d3.select(\"svg\").append(\"line\")\r\n                    .attr(\"x1\",startpoint.x)\r\n                    .attr(\"y1\",startpoint.y)\r\n                    .attr(\"x2\",endpoint.x)\r\n                    .attr(\"y2\",endpoint.y)\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"black\")\r\n                        console.log(that.tanGraphEdges[edgeid])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n            }\r\n        }\r\n    }\r\n\r\n    createGraph(){\r\n        //create full graph\r\n        let connectG={}\r\n        let edgeDict=[]\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            edgeDict.push([])\r\n        }\r\n        for (let e=0;e<this.tanGraphEdges.length;e++){\r\n            let edge=this.tanGraphEdges[e]\r\n            let distance=calDistance(edge.startpoint[0],edge.startpoint[1],edge.endpoint[0],edge.endpoint[1])\r\n            edgeDict[edge.startid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n            edgeDict[edge.endid].push({\r\n                edge:edge,\r\n                distance:distance,\r\n                intersec:0\r\n            })\r\n        }\r\n\r\n\r\n        console.log(edgeDict)\r\n        for (var k in this.catPointDict){\r\n            connectG[k]=[]\r\n            let points=this.catPointDict[k]\r\n            for(let i=0;i<points.length;i++){\r\n                let id1=points[i].id\r\n                for (let j=i+1;j<points.length;j++){\r\n                    let id2=points[j].id\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawTanPoint(){\r\n        for (let i=0;i<this.tanGraphPoints.length;i++){\r\n            drawCircle(this.tanGraphPoints[i].x,this.tanGraphPoints[i].y,2,\"red\",\"none\")\r\n        }\r\n    }\r\n\r\n    drawTangentEdges(){\r\n        for (let i=0;i<this.tanGraphEdges.length;i++){\r\n            let startid=this.tanGraphEdges[i].startid\r\n            let endid=this.tanGraphEdges[i].endid\r\n            let startpoint=this.tanGraphPoints[startid]\r\n            let endpoint=this.tanGraphPoints[endid]\r\n            if(startpoint.dataindex==25||endpoint.dataindex==25)\r\n                drawLine([startpoint.x,startpoint.y],[endpoint.x,endpoint.y],\"blue\",1)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData.id=i\r\n        }\r\n\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-40)+\" \"+(miny-40)+\" \"+(maxx-minx+80)+\" \"+(maxy-miny+80))\r\n\r\n\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        let offsetX = minx-20;\r\n        let offsetY = miny-20;\r\n        let viewWidth = maxx-minx+40;\r\n        let viewHeight = maxy-miny+40\r\n\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id=i\r\n            this.pointData[i].cat=this.pointData[i].cat.toString()\r\n            let cats=this.pointData[i].cat.split(\",\")\r\n            let catarray=[]\r\n            if (cats.length>1){\r\n                this.pointData[i].multicat=true\r\n                for (let c=0;c<cats.length;c++){\r\n                    catarray.push(cats[c])\r\n                }\r\n            }\r\n            else{\r\n                this.pointData[i].multicat=false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray=catarray\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n            }\r\n        }\r\n\r\n        // console.log(this.catPointDict)\r\n    }\r\n\r\n    drawPointData(){\r\n        let that=this\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\", this.pointData[i].cat)\r\n                    .attr(\"index\", index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(\"#mainsvg\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 1)\r\n\r\n            }\r\n            let items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    // Phase 1 : Shortest-path graph\r\n    // create the reachability graph for all sets\r\n    // edges are constrained as below:\r\n    // 1. w/2 away from any allocation areas except for the endpoints\r\n    // 2. the edges between the pairs of nodes that are neighbors in the Delauay triangulation\r\n    // 3. the weight of edges = Math.power(|e| + C, t)\r\n\r\n    calDelauayTriangulation(){\r\n        neighbors = {}\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            //let tmp_poly = []\r\n            //tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            //tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            //tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            //drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEdgeConstrains(edge, k){\r\n\r\n\r\n        let startid = edge.startid\r\n        let endid = edge.endid\r\n\r\n        // judge whether the endpoints are neighbors\r\n        let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n        let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n        if(this.tanGraphPoints[startid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex1].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type == \"datapoint\"){\r\n            let cat_Array = this.pointData[dataindex2].catArray\r\n            let flag = false\r\n            for(let c = 0; c < cat_Array.length; c ++){\r\n                if(cat_Array[c] == k){\r\n                    flag = true\r\n                    break\r\n                }\r\n            }\r\n            if(!flag){\r\n                return false\r\n            }\r\n        }\r\n\r\n\r\n        let idx1, idx2\r\n\r\n        if(this.tanGraphPoints[startid].type != \"vi\"){\r\n            idx1 = [dataindex1]\r\n        }\r\n        else{\r\n            idx1 = dataindex1\r\n        }\r\n\r\n        if(this.tanGraphPoints[endid].type != \"vi\"){\r\n            idx2 = [dataindex2]\r\n        }\r\n        else{\r\n            idx2 = dataindex2\r\n        }\r\n\r\n        /*\r\n        let neighborFlag = false\r\n        for(let p = 0; p < idx1.length; p ++){\r\n            let pt1 = idx1[p]\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                let pt2 = idx2[q]\r\n                if(neighbors.hasOwnProperty(pt1)){\r\n                    if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n                if(neighbors.hasOwnProperty(pt2)){\r\n                    if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                        neighborFlag = true\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!neighborFlag){\r\n            //return false\r\n        }\r\n        */\r\n\r\n        let disFlag = true\r\n\r\n        // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n        for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n            let flagg = false\r\n            for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                if(this.pointData[j].catArray[cur_idx] == k){\r\n                    flagg = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            if(flagg){\r\n\r\n                continue\r\n            }\r\n\r\n            let isSame1 = false\r\n            let isSame2 = false\r\n\r\n            for(let p = 0; p < idx1.length; p ++){\r\n                if(j == idx1[p]){\r\n                    isSame1 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            for(let q = 0; q < idx2.length; q ++){\r\n                if(j == idx2[q]){\r\n                    isSame2 = true\r\n                    break\r\n                }\r\n            }\r\n\r\n            //if(isSame1 || isSame2){\r\n            //    continue\r\n            //}\r\n\r\n\r\n            let flagg1 = false\r\n            if(isSame1){\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg1 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg1 = true\r\n                }\r\n            }\r\n\r\n            if(flagg1){\r\n                continue\r\n            }\r\n\r\n            let flagg2 = false\r\n            if(isSame2){\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    for(let cur_idx = 0; cur_idx < this.pointData[j].catArray.length; cur_idx ++){\r\n                        if(this.pointData[j].catArray[cur_idx] == k){\r\n                            flagg2 = true\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    flagg2 = true\r\n                }\r\n            }\r\n\r\n            if(flagg2){\r\n                continue\r\n            }\r\n\r\n            // first cal the perpendicular from the point to the edge\r\n            let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n            let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n            let pt = [this.pointData[j].x, this.pointData[j].y]\r\n            let k1\r\n            let k2\r\n            let pt_o\r\n            let withinFlag = false\r\n            if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                k1 = null\r\n                k2 = 0\r\n                // cal intersection point for two lines\r\n                pt_o = [s_pt[0], pt[1]]\r\n                if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                k1 = 0\r\n                k2 = null\r\n                // cal intersection point for two lines\r\n                pt_o = [pt[0], s_pt[1]]\r\n                if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n            else{\r\n                k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                k2 = (-1.0) / k1\r\n                // cal intersection point for two lines\r\n                let b1 = s_pt[1] - k1 * s_pt[0]\r\n                let b2 = pt[1] - k2 * pt[0]\r\n                let tmpx = (b1 - b2) / (k2 - k1)\r\n                let tmpy = k1 * tmpx + b1\r\n                pt_o = [tmpx, tmpy]\r\n                let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                if(tmpt >= 0 && tmpt <= 1){\r\n                    withinFlag = true\r\n                }\r\n            }\r\n\r\n            // if the intersection point not in the region of edge then continue\r\n            if(!withinFlag){\r\n                let dis1 = calDistance(pt[0], pt[1], s_pt[0], s_pt[1])\r\n                let dis2 = calDistance(pt[0], pt[1], e_pt[0], e_pt[1])\r\n                if(dis1 < dis2){\r\n                    pt_o = [s_pt[0], s_pt[1]]\r\n                }\r\n                else{\r\n                    pt_o = [e_pt[0], e_pt[1]]\r\n                }\r\n            }\r\n\r\n            // else cal the intersection point of the vertical line and the polygon\r\n            let tmp_poly = []\r\n            for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n            }\r\n            let area_poly = ShapeInfo.polygon(tmp_poly)\r\n            let tmpvv = [pt_o[0] - pt[0], pt_o[1] - pt[1]]\r\n            let pt_oo = [pt[0] + 2 * tmpvv[0], pt[1] + 2 * tmpvv[1]]\r\n            let o_line = ShapeInfo.line(pt, pt_oo)\r\n            let intersections = Intersection.intersect(area_poly, o_line)\r\n            let mindis = Number.MAX_VALUE\r\n            let i_pts = intersections.points\r\n\r\n            //console.log(\"intersection points:\")\r\n            //console.log(i_pts)//\r\n\r\n            let hasIntersect = false\r\n\r\n            for(let p = 0; p < i_pts.length; p ++){\r\n                hasIntersect = true\r\n                let tmpdis = calDistance(pt[0], pt[1], i_pts[p].x, i_pts[p].y)\r\n                mindis = Math.min(mindis, tmpdis)\r\n            }\r\n\r\n            if(!hasIntersect){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n            let linedis = calDistance(pt[0], pt[1], pt_o[0], pt_o[1]) - mindis - (EdgeWidth / 2) + 2\r\n\r\n            // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n            if(linedis <= 0){\r\n                disFlag = false\r\n                break\r\n            }\r\n\r\n        }\r\n\r\n        if(!disFlag){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n\r\n\r\n    }\r\n\r\n    moveOutEdge(k, i){\r\n\r\n    }\r\n\r\n    createInitGraph(){\r\n\r\n        // first create (pointData, tanPoints) map\r\n\r\n        for(let k in this.catPointDict){\r\n            //this.catPointMap[k] = {}\r\n            this.catInitEdges[k] = []\r\n        }\r\n\r\n        /*\r\n        for(let i = 0; i < this.tanGraphPoints.length; i ++){\r\n\r\n            let dataidx = this.tanGraphPoints[i].dataindex\r\n            let addidx = []\r\n\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                addidx = dataidx\r\n            }\r\n            else{\r\n                addidx = [dataidx]\r\n            }\r\n\r\n            if(this.tanGraphPoints[i].type == \"datapoint\"){\r\n                this.tanPointMap[addidx[0]] = i\r\n            }\r\n\r\n            for(let j = 0; j < addidx.length ; j ++){\r\n                let idx = addidx[j]\r\n                for (let c = 0; c < this.pointData[idx].catArray.length; c ++){\r\n                    let nowcat = this.pointData[idx].catArray[c]\r\n                    if(!this.catPointMap[nowcat].hasOwnProperty(idx)){\r\n                        this.catPointMap[nowcat][idx] = []\r\n                    }\r\n                    this.catPointMap[nowcat][idx].push(this.tanGraphPoints[i])\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        //let rG = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n\r\n        //this.calDelauayTriangulation()\r\n\r\n        //console.log(neighbors)\r\n        /*\r\n        // constrain the edges to delauay triangulation and w/2 far away from allocation areas\r\n        for(let i = this.tanGraphEdges.length - 1; i >= 0; i --){\r\n            let e = this.tanGraphEdges[i]\r\n            if(this.calEdgeConstrains(e)){\r\n                //console.log(\"yes\")\r\n                // add edge to the rG\r\n                let startid = e.startid\r\n                let endid = e.endid\r\n                let dis = calDistance(\r\n                    this.tanGraphPoints[startid].x,\r\n                    this.tanGraphPoints[startid].y,\r\n                    this.tanGraphPoints[endid].x,\r\n                    this.tanGraphPoints[endid].y\r\n                )\r\n                let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                rG.addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                rG.addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n            }\r\n        }\r\n        */\r\n        //console.log(\"rG\")\r\n        //console.log(rG)\r\n        //return\r\n\r\n        //console.log(\"catPointMap!\")\r\n        //console.log(this.catPointMap)\r\n\r\n        // create the edges array for each cat\r\n        for(let k in this.catPointMap){\r\n\r\n            this.rG[k] = new jsgraphs.WeightedDiGraph(this.tanGraphPoints.length)\r\n\r\n            for(let i = this.rGEdges[k].length - 1; i >= 0; i --){\r\n                let e = this.rGEdges[k][i]\r\n                if(this.calEdgeConstrains(e, k)){\r\n                    //console.log(\"yes\")\r\n                    // add edge to the rG\r\n                    let startid = e.startid\r\n                    let endid = e.endid\r\n                    let dis = calDistance(\r\n                        this.tanGraphPoints[startid].x,\r\n                        this.tanGraphPoints[startid].y,\r\n                        this.tanGraphPoints[endid].x,\r\n                        this.tanGraphPoints[endid].y\r\n                    )\r\n                    //let edge_weight = Math.pow(dis + parameter_C, parameter_t)\r\n                    let edge_weight = dis\r\n                    //let edge_weight = dis\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(startid, endid, edge_weight));\r\n                    this.rG[k].addEdge(new jsgraphs.Edge(endid, startid, edge_weight));\r\n                }\r\n            }\r\n\r\n\r\n            let node_array = []\r\n\r\n            for(let node in this.catPointMap[k]){\r\n                node_array.push(node)\r\n            }\r\n\r\n            //console.log(\"node_array!!!\")\r\n            //console.log(node_array)\r\n\r\n            console.log(\"info!!\")\r\n            console.log(k)\r\n            console.log(node_array)\r\n\r\n            for(let i = 0; i < node_array.length; i ++){\r\n\r\n                //let nodes1 = this.catPointMap[k][node_array[i]]\r\n                //console.log(\"nodes1!!!\")\r\n                //console.log(nodes1)\r\n\r\n                let nodeid1 = this.tanPointMap[node_array[i]]\r\n                let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodeid1)\r\n\r\n                for(let j = i + 1; j < node_array.length; j ++){\r\n\r\n                    //if(i == j){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let nodeid2 = this.tanPointMap[node_array[j]]\r\n\r\n                    if(dijkstra.hasPathTo(nodeid2)){\r\n                        let path = dijkstra.pathTo(nodeid2)\r\n                        let tmp_w = 0\r\n                        for(let eid = 0; eid < path.length; eid ++){\r\n                            tmp_w += path[eid].weight\r\n                        }\r\n                        //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        let tmp_e = {\r\n                            cat:k,\r\n                            start:parseInt(node_array[i]),\r\n                            end:parseInt(node_array[j]),\r\n                            edges:path,\r\n                            weight: Math.pow(tmp_w + parameter_C, parameter_t)\r\n                        }\r\n                        this.catInitEdges[k].push(tmp_e)\r\n                    }\r\n\r\n                    //let nodes2 = this.catPointMap[k][node_array[j]]\r\n                    /*\r\n                    for(let p = 0; p < nodes1.length; p ++){\r\n                        if(this.tanGraphPoints[nodes1[p].id].type != \"datapoint\"){\r\n                            continue\r\n                        }\r\n                        let dijkstra = new jsgraphs.Dijkstra(this.rG[k], nodes1[p].id);\r\n                        for(let q = 0; q < nodes2.length; q ++){\r\n                            if(this.tanGraphPoints[nodes2[q].id].type != \"datapoint\"){\r\n                                continue\r\n                            }\r\n                            if(dijkstra.hasPathTo(nodes2[q].id)){\r\n                                let path = dijkstra.pathTo(nodes2[q].id)\r\n                                let tmp_w = 0\r\n                                for(let eid = 0; eid < path.length; eid ++){\r\n                                    tmp_w += path[eid].weight\r\n                                }\r\n                                //tmp_w = Math.pow(tmp_w + parameter_C, parameter_t)\r\n                                let tmp_e = {\r\n                                    cat:k,\r\n                                    start:parseInt(node_array[i]),\r\n                                    end:parseInt(node_array[j]),\r\n                                    edges:path,\r\n                                    weight:tmp_w\r\n                                }\r\n                                this.catInitEdges[k].push(tmp_e)\r\n                            }\r\n                        }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n        /*\r\n        // add cat attribute for tan points\r\n        for(let i = 0; i < this.tanGraphPoints.length ; i ++){\r\n            let dataindex = this.tanGraphPoints[i].dataindex\r\n            if(this.tanGraphPoints[i].type == \"vi\"){\r\n                if(this.pointData[dataindex[0]].cat != this.pointData[dataindex[1]].cat){\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat, this.pointData[dataindex[1]].cat]\r\n                }\r\n                else{\r\n                    this.tanGraphPoints[i].cat = [this.pointData[dataindex[0]].cat]\r\n                }\r\n            }\r\n            else{\r\n                this.tanGraphPoints[i].cat = [this.pointData[dataindex].cat]\r\n            }\r\n        }\r\n\r\n\r\n        // split tan edges by cat\r\n        let edgeDict = {}\r\n\r\n        for(let i = 0; i < this.tanGraphEdges.length; i ++){\r\n            let startid = this.tanGraphEdges[i].startid\r\n            let endid = this.tanGraphEdges[i].endid\r\n            let cat1 = this.tanGraphPoints[startid].cat\r\n            let cat2 = this.tanGraphPoints[endid].cat\r\n            let dis = calDistance(\r\n                this.tanGraphPoints[startid].x,\r\n                this.tanGraphPoints[startid].y,\r\n                this.tanGraphPoints[endid].x,\r\n                this.tanGraphPoints[endid].y\r\n            )\r\n            this.tanGraphEdges[i].weight = Math.pow(dis + parameter_C, parameter_t)\r\n            let flag = false\r\n            let catidx = {}\r\n            for(let j = 0; j < cat1.length; j ++){\r\n                let idx1 = cat1[j]\r\n                for(let k = 0; k < cat2.length; k ++){\r\n                    if(idx1 == cat2[k]){\r\n                        flag = true\r\n                        catidx[idx1] = 1\r\n                    }\r\n                }\r\n            }\r\n            if(flag){\r\n                for(let key_cat in catidx){\r\n                    if(!edgeDict.hasOwnProperty(key_cat)){\r\n                        edgeDict[key_cat] = []\r\n                    }\r\n                    edgeDict[key_cat].push(this.tanGraphEdges[i])\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"createInitGraph\")\r\n        //console.log(this.catPointDict)\r\n\r\n\r\n        //this.initGraph[k] = new jsgraphs.WeightedDiGraph(points.length)\r\n\r\n\r\n        // cal delauay triangulation\r\n        let tmp_pts = []\r\n        let points = this.pointData\r\n        for(let i = 0; i < points.length; i ++){\r\n            tmp_pts.push([points[i].x, points[i].y])\r\n        }\r\n        let triangles = triangulate(tmp_pts)\r\n        let neighbors = {}\r\n        // construct dict for delauay triangulation neighbors\r\n        for(let i = 0; i < triangles.length; i ++){\r\n\r\n            let p1 = triangles[i][0]\r\n            let p2 = triangles[i][1]\r\n            let p3 = triangles[i][2]\r\n\r\n            let tmp_poly = []\r\n            tmp_poly.push([this.pointData[p1].x, this.pointData[p1].y])\r\n            tmp_poly.push([this.pointData[p2].x, this.pointData[p2].y])\r\n            tmp_poly.push([this.pointData[p3].x, this.pointData[p3].y])\r\n            drawPolygon(tmp_poly, 0, 0, \"red\")\r\n\r\n            //p1 = this.catPointDict[k][p1].id\r\n            //p2 = this.catPointDict[k][p2].id\r\n            //p3 = this.catPointDict[k][p3].id\r\n\r\n\r\n            if(!neighbors.hasOwnProperty(p1)){\r\n                neighbors[p1] = {}\r\n                neighbors[p1][p2] = 1\r\n                neighbors[p1][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p2)){\r\n                neighbors[p2] = {}\r\n                neighbors[p2][p1] = 1\r\n                neighbors[p2][p3] = 1\r\n            }\r\n            if(!neighbors.hasOwnProperty(p3)){\r\n                neighbors[p3] = {}\r\n                neighbors[p3][p1] = 1\r\n                neighbors[p3][p2] = 1\r\n            }\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n            //let points = this.catPointDict[k]\r\n\r\n            for(let i = 0; i < edgeDict[k].length; i ++){\r\n\r\n                let startid = edgeDict[k][i].startid\r\n                let endid = edgeDict[k][i].endid\r\n\r\n                // judge whether the endpoints are neighbors\r\n                let dataindex1 = this.tanGraphPoints[startid].dataindex\r\n                let dataindex2 = this.tanGraphPoints[endid].dataindex\r\n\r\n                let idx1, idx2\r\n\r\n                if(this.tanGraphPoints[startid].type != \"vi\"){\r\n                    idx1 = [dataindex1]\r\n                }\r\n                else{\r\n                    idx1 = dataindex1\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type != \"vi\"){\r\n                    idx2 = [dataindex2]\r\n                }\r\n                else{\r\n                    idx2 = dataindex2\r\n                }\r\n\r\n                let neighborFlag = false\r\n                for(let p = 0; p < idx1.length; p ++){\r\n                    let pt1 = idx1[p]\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        let pt2 = idx2[q]\r\n                        if(neighbors.hasOwnProperty(pt1)){\r\n                            if(neighbors[pt1].hasOwnProperty(pt2)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                        if(neighbors.hasOwnProperty(pt2)){\r\n                            if(neighbors[pt2].hasOwnProperty(pt1)){\r\n                                neighborFlag = true\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(!neighborFlag){\r\n                    continue\r\n                }\r\n\r\n                let disFlag = true\r\n\r\n                // judge whether the edge is w/2 away from any allocation areas except for the endpoints\r\n                for(let j = 0; j < this.elementPoly.length; j ++){\r\n\r\n                    let isSame = false\r\n\r\n                    for(let p = 0; p < idx1.length; p ++){\r\n                        if(j == idx1[p]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n                    for(let q = 0; q < idx2.length; q ++){\r\n                        if(j == idx2[q]){\r\n                            isSame = true\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(isSame){\r\n                        continue\r\n                    }\r\n\r\n                    // first cal the perpendicular from the point to the edge\r\n                    let s_pt = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                    let e_pt = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                    let pt = [this.pointData[j].x, this.pointData[j].y]\r\n                    let k1\r\n                    let k2\r\n                    let pt_o\r\n                    let withinFlag = false\r\n                    if(Math.abs(s_pt[0] - e_pt[0]) < eps){\r\n                        k1 = null\r\n                        k2 = 0\r\n                        // cal intersection point for two lines\r\n                        pt_o = [s_pt[0], pt[1]]\r\n                        if(pt[1] >= Math.min(s_pt[1], e_pt[1]) && pt[1] <= Math.max(s_pt[1], e_pt[1])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else if(Math.abs(s_pt[1] - e_pt[1]) < eps){\r\n                        k1 = 0\r\n                        k2 = null\r\n                        // cal intersection point for two lines\r\n                        pt_o = [pt[0], s_pt[1]]\r\n                        if(pt[0] >= Math.min(s_pt[0], e_pt[0]) && pt[0] <= Math.max(s_pt[0], e_pt[0])){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n                    else{\r\n                        k1 = (e_pt[1] - s_pt[1]) / (e_pt[0] - s_pt[0])\r\n                        k2 = (-1.0) / k1\r\n                        // cal intersection point for two lines\r\n                        let b1 = s_pt[1] - k1 * s_pt[0]\r\n                        let b2 = pt[1] - k2 * pt[0]\r\n                        let tmpx = (b1 - b2) / (k2 - k1)\r\n                        let tmpy = k1 * tmpx + b1\r\n                        pt_o = [tmpx, tmpy]\r\n                        let tmpt = (tmpx - s_pt[0]) / (e_pt[0] - s_pt[0])\r\n                        if(tmpt >= 0 && tmpt <= 1){\r\n                            withinFlag = true\r\n                        }\r\n                    }\r\n\r\n                    // if the intersection point not in the region of edge then continue\r\n                    if(!withinFlag){\r\n                        continue\r\n                    }\r\n\r\n                    // else cal the intersection point of the vertical line and the polygon\r\n                    let tmp_poly = []\r\n                    for(let p = 0; p < this.elementPoly[j].length; p ++){\r\n                        tmp_poly.push([this.elementPoly[j][p].x, this.elementPoly[j][p].y])\r\n                    }\r\n                    let area_poly = ShapeInfo.polygon(tmp_poly)\r\n                    let o_line = ShapeInfo.line(pt, pt_o)\r\n                    let intersections = Intersection.intersect(area_poly, o_line);\r\n                    let mindis = Number.MAX_VALUE\r\n                    let i_pts = intersections.points\r\n\r\n                    //console.log(\"intersection points:\")\r\n                    //console.log(i_pts)//\r\n\r\n                    for(let p = 0; p < i_pts.length; p ++){\r\n                        let tmpdis = calDistance(pt_o[0], pt_o[1], i_pts[p].x, i_pts[p].y)\r\n                        mindis = Math.min(mindis, tmpdis)\r\n                    }\r\n\r\n                    // finally cal the distance from the intersection point to the edge and judge whether the distance > w/2\r\n                    if(mindis < EdgeWidth/2){\r\n                        disFlag = false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(!disFlag){\r\n                    //continue\r\n                }\r\n\r\n                // add the edge to the reachability graph\r\n                if(!this.initEdges.hasOwnProperty(k)){\r\n                    this.initEdges[k] = []\r\n                }\r\n\r\n                this.initEdges[k].push(edgeDict[k][i])\r\n\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                //drawLine(start_points, end_points, \"black\", 2)\r\n\r\n            }\r\n\r\n        }\r\n\r\n        console.log(this.initEdges)\r\n\r\n         */\r\n\r\n    // create SPG according to the Algorithm 2\r\n    createSPG(){\r\n\r\n\r\n\r\n        /*\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            for(let i = 0; i < edges.length; i ++){\r\n                console.log(\"draw\")\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let edge_path = edges[i].edges\r\n                let tmp_color = colors[parseInt(edges[i].cat)]\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let u = edge_path[p].from()\r\n                    let v = edge_path[p].to()\r\n                    let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                    let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                if(edge_path.length == 0){\r\n                    let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n                else{\r\n                    let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                    let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                    drawLine(start_points, end_points, \"black\", 1)\r\n                }\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        console.log(\"catInitEdges!!!\")\r\n        console.log(this.catInitEdges)\r\n\r\n\r\n        for(let k in this.catInitEdges){\r\n            this.catInitEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n            let edges = this.catInitEdges[k]\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            for(let i = 0; i < edges.length; i ++){\r\n                let st = edges[i].start\r\n                let en = edges[i].end\r\n                let w = edges[i].weight\r\n                let e = new jsgraphs.Edge(st, en, w)\r\n                e.label = i\r\n                e.flag = false\r\n                let e1 = new jsgraphs.Edge(en, st, w)\r\n                e1.label = i\r\n                e1.flag = true\r\n                let dijkstra = new jsgraphs.Dijkstra(this.SPG[k], st)\r\n                let drawFlag = false\r\n                if(dijkstra.hasPathTo(en)){\r\n                    let path = dijkstra.pathTo(en)\r\n                    let path_weight = 0\r\n                    for(let p = 0; p < path.length; p ++){\r\n                        path_weight += path[p].weight\r\n                    }\r\n                    if(path_weight >= w){\r\n                        //console.log(\"(\" + path_weight + \", \" + w + \")\")\r\n                        drawFlag = true\r\n                        this.SPG[k].addEdge(e)\r\n                        this.SPG[k].addEdge(e1)\r\n                    }\r\n                }\r\n                else{\r\n                    drawFlag = true\r\n                    this.SPG[k].addEdge(e)\r\n                    this.SPG[k].addEdge(e1)\r\n                }\r\n\r\n                if(drawFlag){\r\n                    if(!this.SPGEdges.hasOwnProperty(k)){\r\n                        this.SPGEdges[k] = []\r\n                    }\r\n                    this.SPGEdges[k].push(i)\r\n                    this.drawEdgePath(k, i, colors[parseInt(k)], 1)\r\n                    //console.log(edges[i])\r\n                    /*\r\n                    let edge_path = edges[i].edges\r\n                    let tmp_color = colors[parseInt(edges[i].cat)]\r\n                    for(let p = 0; p < edge_path.length; p ++){\r\n                        let u = edge_path[p].from()\r\n                        let v = edge_path[p].to()\r\n                        let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                        let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    if(edge_path.length == 0){\r\n                        let start_points = [this.tanGraphPoints[st].x, this.tanGraphPoints[st].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n                    else{\r\n                        let start_points = [this.tanGraphPoints[edge_path[edge_path.length - 1].to()].x, this.tanGraphPoints[edge_path[edge_path.length - 1].to()].y]\r\n                        let end_points = [this.tanGraphPoints[en].x, this.tanGraphPoints[en].y]\r\n                        drawLine(start_points, end_points, tmp_color, 1)\r\n                    }\r\n\r\n                     */\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*\r\n        //console.log(this.pointData)\r\n        for(var k in this.initEdges){\r\n\r\n            // increasing order\r\n            this.initEdges[k].sort(function (a, b){\r\n                return a.weight - b.weight\r\n            })\r\n\r\n            //console.log(this.initEdges[k])\r\n            this.SPG[k] = new jsgraphs.WeightedDiGraph(this.pointData.length)\r\n            this.SPGEdges[k] = []\r\n\r\n            for(let i = 0; i < this.initEdges[k].length; i ++){\r\n                let startid = this.initEdges[k][i].startid\r\n                let endid = this.initEdges[k][i].endid\r\n                let weight = this.initEdges[k][i].weight\r\n                let s_ptid\r\n                let e_ptid\r\n\r\n                if(this.tanGraphPoints[startid].type == \"vi\"){\r\n                    s_ptid = this.tanGraphPoints[startid].dataindex\r\n                }else{\r\n                    s_ptid = [this.tanGraphPoints[startid].dataindex]\r\n                }\r\n\r\n                if(this.tanGraphPoints[endid].type == \"vi\"){\r\n                    e_ptid = this.tanGraphPoints[endid].dataindex\r\n                }else{\r\n                    e_ptid = [this.tanGraphPoints[endid].dataindex]\r\n                }\r\n\r\n                for(let j = s_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[s_ptid[j]].cat != k){\r\n                        s_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                for(let j = e_ptid.length - 1; j >= 0; j --){\r\n                    if(this.pointData[e_ptid[j]].cat != k){\r\n                        e_ptid.splice(j, 1)\r\n                    }\r\n                }\r\n\r\n                if(s_ptid.length == 0 || e_ptid.length == 0){\r\n                    continue\r\n                }\r\n\r\n                for(let j = 0 ; j < s_ptid.length ; j ++){\r\n\r\n                    let startidx = s_ptid[j]\r\n                    var dijkstra = new jsgraphs.Dijkstra(this.SPG[k], startidx);\r\n                    let hasLink = false\r\n                    let adjLink = false\r\n                    //let pathWeight = Number.MAX_VALUE\r\n\r\n                    for(let p = 0; p < e_ptid.length; p ++){\r\n\r\n                        let endidx = e_ptid[p]\r\n                        let adjList = this.SPG[k].adjList\r\n\r\n                        //for(let q = 0; q < adjList[startidx].length; q ++){\r\n                        //    let e = adjList[startidx][q]\r\n                        //    if(e.w == endidx){\r\n                        //        adjLink = true\r\n                        //    }\r\n                        //}\r\n//\r\n                        //if(adjLink){\r\n                        //    continue\r\n                        //}\r\n\r\n                        let tmp_w = 0\r\n                        if(dijkstra.hasPathTo(endidx)){\r\n                            hasLink = true\r\n                            let path = dijkstra.pathTo(e_ptid[p])\r\n                            for(let q = 0; q < path.length; q ++){\r\n                                let e = path[q]\r\n                                tmp_w += e.weight\r\n                            }\r\n                        }\r\n\r\n                        if((!hasLink) || (hasLink && tmp_w >= weight)){\r\n                            // add edge to SPG\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(startidx, endidx, weight))\r\n                            this.SPG[k].addEdge(new jsgraphs.Edge(endidx, startidx, weight))\r\n                            this.SPGEdges[k].push(this.initEdges[k][i])\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n        //console.log(this.SPG)\r\n        //console.log(this.SPGEdges)\r\n\r\n        for(var k in this.SPGEdges){\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let startid = this.SPGEdges[k][i].startid\r\n                let endid = this.SPGEdges[k][i].endid\r\n                let start_points = [this.tanGraphPoints[startid].x, this.tanGraphPoints[startid].y]\r\n                let end_points = [this.tanGraphPoints[endid].x, this.tanGraphPoints[endid].y]\r\n                drawLine(start_points, end_points, \"black\", 3)\r\n            }\r\n        }\r\n\r\n         */\r\n\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calCrossEdges(){\r\n        console.log(this.SPGEdges)\r\n        var Edge_Array = {}\r\n        for(let k in this.SPGEdges){\r\n            Edge_Array[k] = []\r\n            for(let i = 0; i < this.SPGEdges[k].length; i ++){\r\n                let idx = this.SPGEdges[k][i]\r\n                let edge_path = this.catInitEdges[k][idx].edges\r\n                let tmp_e = []\r\n                for(let p = 0; p < edge_path.length; p ++){\r\n                    let tmp_line = {}\r\n                    let u = edge_path[p].v\r\n                    let v = edge_path[p].w\r\n                    tmp_line.start = {x: this.tanGraphPoints[u].x,\r\n                                      y:this.tanGraphPoints[u].y}\r\n                    tmp_line.end = {x:this.tanGraphPoints[v].x,\r\n                                    y:this.tanGraphPoints[v].y}\r\n                    tmp_e.push(tmp_line)\r\n                }\r\n                Edge_Array[k].push(tmp_e)\r\n            }\r\n        }\r\n\r\n        let crossnum = 0\r\n        for(let k1 in Edge_Array){\r\n\r\n            for(let i = 0; i < Edge_Array[k1].length; i ++){\r\n                let e1 = Edge_Array[k1][i]\r\n                for(let k2 in Edge_Array){\r\n                    if(k1 == k2){\r\n                        continue\r\n                    }\r\n                    for(let j = 0; j < Edge_Array[k2].length; j ++){\r\n                        let e2 = Edge_Array[k2][j]\r\n                        let flag = false\r\n                        for(let p = 0; p < e1.length; p ++){\r\n                            let eS1 = e1[p].start\r\n                            let eE1 = e1[p].end\r\n                            for(let q = 0; q < e2.length; q ++){\r\n                                let eS2 = e2[q].start\r\n                                let eE2 = e2[q].end\r\n                                if(this.checkEdgeCrossing(eS1, eE1, eS2, eE2)){\r\n                                    crossnum ++\r\n                                    flag = true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(flag){\r\n\r\n                                for(let q = 0; q < e2.length; q ++){\r\n                                    let eS2 = e2[q].start\r\n                                    let eE2 = e2[q].end\r\n                                    let startpoints = [eS2.x, eS2.y]\r\n                                    let endpoints = [eE2.x, eE2.y]\r\n                                    drawLine(startpoints, endpoints, \"red\", 2)\r\n                                }\r\n\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        crossnum /= 2\r\n\r\n        console.log(\"Points Num : \")\r\n        console.log(this.pointData.length)\r\n        console.log(\"Cross Num : \")\r\n        console.log(crossnum)\r\n\r\n    }\r\n\r\n    //Phase 2 : Fillable faces\r\n    // find all faces in SPG\r\n\r\n    drawEdgePath(k, i, color, width){\r\n        let edge_path = this.catInitEdges[k][i].edges\r\n        for(let p = 0; p < edge_path.length; p ++){\r\n            let u = edge_path[p].v\r\n            let v = edge_path[p].w\r\n            let start_points = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n            let end_points = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n            drawLine(start_points, end_points, color, width)\r\n        }\r\n    }\r\n\r\n    judgeClockWise(pointIdx){\r\n\r\n        //counterclockwise return true\r\n        //clockwise return false\r\n        let p1 = [this.pointData[pointIdx[0]].x, this.pointData[pointIdx[0]].y]\r\n        let p2 = [this.pointData[pointIdx[1]].x, this.pointData[pointIdx[1]].y]\r\n        let p3 = [this.pointData[pointIdx[2]].x, this.pointData[pointIdx[2]].y]\r\n        let res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\r\n        if(res > 0){\r\n            return true\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n    dfs(s, k){\r\n        this.visited[s] = 1\r\n        for(let i = 0; i < this.SPG[k].adjList[s].length; i ++){\r\n            let e = this.SPG[k].adjList[s][i]\r\n            let to = e.w\r\n            if(this.visited[to] == 0){\r\n                this.fa[to] = s\r\n                this.dfs(to, k)\r\n            }\r\n            else if(this.visited[to] == 1 && to != this.fa[s]){\r\n                let tmp = s\r\n                let tmp_circle = []\r\n                tmp_circle.push(to)\r\n                while(tmp != to){\r\n                    tmp_circle.push(tmp)\r\n                    tmp = this.fa[tmp]\r\n                }\r\n                //tmp_circle.push(tmp)\r\n                if(tmp_circle.length < 3){\r\n                    continue\r\n                }\r\n                if(!this.circles.hasOwnProperty(k)){\r\n                    this.circles[k] = []\r\n                }\r\n                if(!this.judgeClockWise(tmp_circle)){\r\n                    tmp_circle.reverse()\r\n                }\r\n                this.circles[k].push(tmp_circle)\r\n                this.circles[k][this.circles[k].length - 1].delflag = false\r\n            }\r\n        }\r\n        this.visited[s] = 2\r\n    }\r\n\r\n    findAllCircles(){\r\n\r\n        console.log(\"SPG\")\r\n        console.log(this.SPG)\r\n\r\n        for(let k in this.SPG){\r\n            for(let i = 0; i < this.SPG[k].V; i ++){\r\n                this.visited = []\r\n                this.fa = []\r\n                this.visited = new Array(this.SPG[k].V).fill(0)\r\n                this.fa = new Array(this.SPG[k].V).fill(-1)\r\n                this.dfs(i, k)\r\n            }\r\n        }\r\n\r\n        //console.log(this.circles)\r\n\r\n        //for(let i = 0; i < this.circles.length; i ++){\r\n        //    for(let j = 0; j < this.circles[i].length ; j ++){\r\n        //        let id1 = this.circles[i][j]\r\n        //        let id2 = this.circles[i][(j + 1) % this.circles[i].length]\r\n        //        let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n        //        let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n        //        drawLine(startpoint, endpoint, \"red\", 3)\r\n        //    }\r\n        //}\r\n\r\n    }\r\n\r\n    // remove same faces\r\n    findPolygons(){\r\n\r\n        this.polygons = {}\r\n\r\n\r\n        // remove same faces\r\n        for(let k in this.circles){\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                let head1 = this.circles[k][i][0]\r\n                let len1 = this.circles[k][i].length\r\n\r\n                for(let j = i + 1; j < this.circles[k].length; j ++){\r\n                    let len2 = this.circles[k][j].length\r\n                    let idx2 = -1\r\n                    if(len1 != len2){\r\n                        continue\r\n                    }\r\n                    for(let p = 0; p < len2; p ++){\r\n                        if(this.circles[k][j][p] == head1){\r\n                            idx2 = p\r\n                        }\r\n                    }\r\n                    if(idx2 == -1){\r\n                        continue\r\n                    }\r\n\r\n                    let sameflag = true\r\n\r\n                    for(let cnt = 0; cnt < len2; cnt ++){\r\n                        let id1 = cnt\r\n                        let id2 = (idx2 + cnt) % len2\r\n                        if(this.circles[k][i][id1] != this.circles[k][j][id2]){\r\n                            sameflag = false\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    if(sameflag){\r\n                        this.circles[k][j].delflag = true\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            for(let i = 0; i < this.circles[k].length; i ++){\r\n\r\n                if(this.circles[k][i].delflag){\r\n                    continue\r\n                }\r\n\r\n                if(!this.polygons.hasOwnProperty(k)){\r\n                    this.polygons[k] = []\r\n                }\r\n\r\n                this.polygons[k].push(this.circles[k][i])\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        //for(let k in this.catPointDict){\r\n        //    this.polygons[k] = []\r\n        //}\r\n        //this.polygons[\"0\"].push([12,10,9])\r\n        //this.polygons[\"0\"].push([26,27,28,32,33])\r\n        //this.polygons[\"0\"].push([29,31,30])\r\n//\r\n        //this.polygons[\"1\"].push([38,41,42,36])\r\n//\r\n        //this.polygons[\"2\"].push([59,61,60])\r\n        //this.polygons[\"2\"].push([66,68,69])\r\n        //this.polygons[\"2\"].push([90,64,65,73])\r\n//\r\n        //for(let k in this.polygons){\r\n        //    for(let i = 0; i < this.polygons[k].length; i ++){\r\n        //        this.polygons[k][i].fillFlag = true\r\n        //    }\r\n        //}\r\n\r\n        //console.log(\"circles\")\r\n        //console.log(this.circles)\r\n        //console.log(\"polygons\")\r\n        //console.log(this.polygons)\r\n\r\n        /*\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n                    //console.log(this.polygons[k][i][j])\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n                    let adjList = this.SPG[k].adjList\r\n                    for(let p = 0; p < adjList[id1].length; p ++){\r\n                        let e = adjList[id1][p]\r\n                        if(e.w == id2){\r\n                            //this.drawEdgePath(k, e.label, \"red\", 3)\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                    //console.log(\"(\" + id1 + \", \" + id2 + \")\")\r\n                    //let startpoint = [this.pointData[id1].x, this.pointData[id1].y]\r\n                    //let endpoint = [this.pointData[id2].x, this.pointData[id2].y]\r\n                    //drawLine(startpoint, endpoint, \"red\", 3)\r\n                }\r\n            }\r\n        }\r\n        */\r\n    }\r\n\r\n    // judge whether a given face can be filled\r\n    judgePolygons(){\r\n\r\n        for(let k in this.polygons){\r\n            for(let i = 0; i < this.polygons[k].length; i ++){\r\n                // cal nodes_f\r\n                this.polygons[k][i].nodes_f = this.polygons[k][i].length\r\n                // cal area\r\n                let p_pts = []\r\n                for(let j = 0; j < this.polygons[k][i].length; j ++){\r\n\r\n                    let id1 = this.polygons[k][i][j]\r\n                    let id2 = this.polygons[k][i][(j + 1) % this.polygons[k][i].length]\r\n\r\n                    let adjList = this.SPG[k].adjList\r\n\r\n                    for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                        let e = adjList[id1][pp]\r\n                        if(e.w == id2){\r\n                            let edge_path = this.catInitEdges[k][e.label].edges\r\n                            let tmp_pts = []\r\n                            for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                let u = edge_path[ppp].v\r\n                                let v = edge_path[ppp].w\r\n                                tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                            }\r\n                            if(e.flag){\r\n                                for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            else{\r\n                                for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                    p_pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                }\r\n                            }\r\n                            break\r\n                        }\r\n                    }\r\n\r\n                }\r\n                //console.log(\"p_pts!\")\r\n                //console.log(p_pts)\r\n                this.polygons[k][i].area_f = Math.abs(AreaCal(p_pts))\r\n                this.polygons[k][i].fillFlag = false\r\n                this.polygons[k][i].PolygonInfo = ShapeInfo.polygon(p_pts)\r\n            }\r\n        }\r\n        let Set_Order = []\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n            let k = Set_Order[i].cat\r\n            if(!this.polygons.hasOwnProperty(k)){\r\n                continue\r\n            }\r\n            let outer_set = {}\r\n            for(let N = 0; N < this.pointData.length; N ++){\r\n                outer_set[N] = 1\r\n            }\r\n            for(let M = 0; M < this.catPointDict[k].length; M ++){\r\n                let cur_id = this.catPointDict[k][M].id\r\n                if(outer_set.hasOwnProperty(cur_id)){\r\n                    delete outer_set[cur_id]\r\n                }\r\n            }\r\n            for(let p = 0; p < this.polygons[k].length; p ++){\r\n                // Rule 1\r\n                let rule1 = false\r\n                let rule1_res = this.polygons[k][p].area_f / ( 1 + this.polygons[k][p].nodes_f)\r\n                if(rule1_res < parameter_A){\r\n                    rule1 = true\r\n                }\r\n                if(!rule1){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule1!\")\r\n                // Rule 2\r\n                let rule2 = true\r\n                for(let idd in outer_set){\r\n                    let tmp_ppt = [this.pointData[parseInt(idd)].x, this.pointData[parseInt(idd)].y]\r\n                    console.log(\"Polygon Info\")\r\n                    console.log(this.polygons[k][p].PolygonInfo.args[0])\r\n                    if(IntersectionQuery.pointInPolygon(tmp_ppt, this.polygons[k][p].PolygonInfo.args[0])){\r\n                        rule2 = false\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule2){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule2!\")\r\n                // Rule 3\r\n                let rule3 = true\r\n                let cur_polygon = this.polygons[k][p].PolygonInfo\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let m = 0; m < n_adj.length; m ++){\r\n                        for(let n = 0; n < n_adj[m].length; n ++){\r\n                            let cur_e = this.catInitEdges[n_k][n_adj[m][n].label].edges\r\n                            for(let a = 0; a < cur_e.length; a ++){\r\n                                let u = cur_e[a].v\r\n                                let v = cur_e[a].w\r\n                                let startpoint = [this.tanGraphPoints[u].x, this.tanGraphPoints[u].y]\r\n                                let endpoint = [this.tanGraphPoints[v].x, this.tanGraphPoints[v].y]\r\n                                let line = ShapeInfo.line(startpoint, endpoint)\r\n                                let pts = Intersection.intersect(line, cur_polygon)\r\n                                if(pts.points.length > 0){\r\n                                    rule3 = false\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(!rule3){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule3){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule3){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule3){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule3!\")\r\n                // Rule 4\r\n                let rule4 = true\r\n                for(let j = Set_Order.length - 1; j > i; j --){\r\n                    let n_k = Set_Order[j].cat\r\n                    let set_other = {}\r\n                    for(let pid = 0; pid < this.catPointDict[n_k].length; pid ++){\r\n                        set_other[this.catPointDict[n_k][pid].id] = 1\r\n                    }\r\n                    let n_adj = this.SPG[n_k].adjList\r\n                    for(let q = 0; q < this.polygons[k][p].length; q ++){\r\n                        let id1 = this.polygons[k][p][q]\r\n                        let id2 = this.polygons[k][p][(q + 1) % this.polygons[k][p].length]\r\n                        for(let alen = 0; alen < n_adj[id1].length; alen ++){\r\n                            let e = n_adj[id1][alen]\r\n                            if(e.w == id2){\r\n                                for(let qq = 0; qq < this.polygons[k][p].length; qq ++){\r\n                                    if(!set_other.hasOwnProperty(this.polygons[k][p][qq])){\r\n                                        rule4 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(!rule4){\r\n                                break\r\n                            }\r\n                        }\r\n                        if(!rule4){\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!rule4){\r\n                        break\r\n                    }\r\n                }\r\n                if(!rule4){\r\n                    this.polygons[k][p].fillFlag = false\r\n                    continue\r\n                }\r\n                //console.log(\"rule4!\")\r\n                console.log(\"A\")\r\n                console.log(rule1_res)\r\n                this.polygons[k][p].fillFlag = true\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    // Phase 3 : Visualization\r\n\r\n    drawAreas(k,curdata){\r\n\r\n        d3.select('svg').append(\"path\")\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 1)\r\n            //.attr('fill-rule',\"evenodd\")\r\n\r\n    }\r\n\r\n\r\n    drawKelpFusion(){\r\n\r\n        console.log(\"Polygons!!\")\r\n        console.log(this.polygons)\r\n\r\n        let Set_Order = []\r\n\r\n        for(let k in this.catPointDict){\r\n            let tmp = {}\r\n            tmp.num = this.catPointDict[k].length\r\n            tmp.cat = k\r\n            Set_Order.push(tmp)\r\n        }\r\n\r\n        Set_Order.sort(function (a, b){\r\n            return a.num - b.num\r\n        })\r\n\r\n        for(let i = Set_Order.length - 1; i >= 0; i --){\r\n\r\n            let cur_k = Set_Order[i].cat\r\n\r\n            // draw points\r\n            for(let j = 0; j < this.catPointDict[cur_k].length; j ++){\r\n                let pointID = this.catPointDict[cur_k][j].id\r\n                let v1 = [this.pointData[pointID].x, this.pointData[pointID].y]\r\n                let tmp_polygon = []\r\n                for(let p = 0; p < this.elementPoly[pointID].length; p ++){\r\n                    //let v2 = [this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y]\r\n                    //let v = [v2[0] - v1[0], v2[1] - v1[1]]\r\n                    //let len = Math.sqrt(v[0] * v[0] + v[1] * v[1])\r\n                    //let cur_v = [v[0] * (len + EdgeWidth / 2) / len, v[1] * (len + EdgeWidth / 2) / len]\r\n                    //tmp_polygon.push([v1[0] + cur_v[0], v1[1] + cur_v[1]])\r\n                    tmp_polygon.push([this.elementPoly[pointID][p].x, this.elementPoly[pointID][p].y])\r\n                }\r\n                this.drawAreas(cur_k, lineFunction(tmp_polygon))\r\n            }\r\n\r\n            // draw edges\r\n\r\n            if(this.SPGEdges.hasOwnProperty(cur_k)){\r\n                if(this.SPGEdges[cur_k].hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.SPGEdges[cur_k].length; j ++){\r\n                        let idx = this.SPGEdges[cur_k][j]\r\n                        let e = this.catInitEdges[cur_k][idx].edges\r\n                        let pts = []\r\n                        let pt1 = []\r\n                        let pt2 = []\r\n                        for(let p = 0; p < e.length; p ++){\r\n                            if(this.tanGraphPoints[e[p].v].type == \"addpoint\" || this.tanGraphPoints[e[p].w].type == \"addpoint\"){\r\n                                //continue\r\n                            }\r\n                            let vidx = e[p].v\r\n                            let widx = e[p].w\r\n\r\n                            let dataindex1 = -1\r\n                            let dataindex2 = -1\r\n                            let st, en\r\n\r\n                            if(this.tanGraphPoints[vidx].type != \"vi\" && this.tanGraphPoints[vidx].type != \"datapoint\"){\r\n                                dataindex1 = this.tanGraphPoints[vidx].dataindex\r\n                            }\r\n\r\n                            if(dataindex1 == -1){\r\n                                st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex1].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    st = [this.tanGraphPoints[vidx].x, this.tanGraphPoints[vidx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[vidx].x - this.pointData[dataindex1].x, this.tanGraphPoints[vidx].y - this.pointData[dataindex1].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    st = [this.tanGraphPoints[vidx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[vidx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            if(this.tanGraphPoints[widx].type != \"vi\" && this.tanGraphPoints[widx].type != \"datapoint\"){\r\n                                dataindex2 = this.tanGraphPoints[widx].dataindex\r\n                            }\r\n\r\n                            if(dataindex2 == -1){\r\n                                en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                            }\r\n                            else{\r\n                                let catArray = this.pointData[dataindex2].catArray\r\n                                let isSame = false\r\n                                for(let c = 0; c < catArray.length; c ++){\r\n                                    if(catArray[c] == cur_k){\r\n                                        isSame = true\r\n                                        break\r\n                                    }\r\n                                }\r\n                                if(isSame){\r\n                                    en = [this.tanGraphPoints[widx].x, this.tanGraphPoints[widx].y]\r\n                                }\r\n                                else{\r\n                                    let ve = [this.tanGraphPoints[widx].x - this.pointData[dataindex2].x, this.tanGraphPoints[widx].y - this.pointData[dataindex2].y]\r\n                                    let nlen = Math.sqrt(ve[0] * ve[0] + ve[1] * ve[1])\r\n                                    en = [this.tanGraphPoints[widx].x + ve[0] * EdgeWidth / (2 * nlen), this.tanGraphPoints[widx].y + ve[1] * EdgeWidth / (2 * nlen)]\r\n                                }\r\n                            }\r\n\r\n                            //drawLine(st, en, colors[cur_k], EdgeWidth)\r\n\r\n                            let v1 = [en[0] - st[0], en[1] - st[1]]\r\n                            let v2 = [(-1.0) * v1[1], v1[0]]\r\n                            let normlen = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1])\r\n                            v2 = [v2[0] / normlen, v2[1] / normlen]\r\n                            // Counterclockwise\r\n                            pt1.push([st[0] + v2[0] * EdgeWidth / 2 , st[1] + v2[1] * EdgeWidth / 2])\r\n                            pt1.push([en[0] + v2[0] * EdgeWidth / 2 , en[1] + v2[1] * EdgeWidth / 2])\r\n                            // Clockwise\r\n                            pt2.push([st[0] - v2[0] * EdgeWidth / 2 , st[1] - v2[1] * EdgeWidth / 2])\r\n                            pt2.push([en[0] - v2[0] * EdgeWidth / 2 , en[1] - v2[1] * EdgeWidth / 2])\r\n                        }\r\n                        for(let p = 0; p < pt1.length; p ++){\r\n                            if(!Object.is(pt1[p][0], NaN) && !Object.is(pt1[p][0], NaN)){\r\n                                //drawCircle(pt1[p][0], pt1[p][1], 2, 'red', 1)\r\n                                pts.push([pt1[p][0], pt1[p][1]])\r\n                            }\r\n                        }\r\n                        for(let p = pt2.length - 1; p >= 0; p --){\r\n                            if(!Object.is(pt2[p][0], NaN) && !Object.is(pt2[p][0], NaN)){\r\n                                //drawCircle(pt2[p][0], pt2[p][1], 2, 'red', 1)\r\n                                pts.push([pt2[p][0], pt2[p][1]])\r\n                            }\r\n                        }\r\n                        //console.log(\"pts!\")\r\n                        //console.log(pts)\r\n                        this.drawAreas(cur_k, lineFunction(pts))\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n\r\n            // fill polygons\r\n            if(this.polygons.hasOwnProperty(cur_k)){\r\n                //if(this.polygons.hasOwnProperty(\"length\")){\r\n                    for(let j = 0; j < this.polygons[cur_k].length; j ++){\r\n                        if(this.polygons[cur_k][j].fillFlag){\r\n                            let pts = []\r\n                            for(let p = 0; p < this.polygons[cur_k][j].length; p ++){\r\n                                let id1 = this.polygons[cur_k][j][p]\r\n                                let id2 = this.polygons[cur_k][j][(p + 1) % this.polygons[cur_k][j].length]\r\n                                let adjList = this.SPG[cur_k].adjList\r\n                                for(let pp = 0; pp < adjList[id1].length; pp ++){\r\n                                    let e = adjList[id1][pp]\r\n                                    if(e.w == id2){\r\n                                        let edge_path = this.catInitEdges[cur_k][e.label].edges\r\n                                        let tmp_pts = []\r\n                                        for(let ppp = 0; ppp < edge_path.length; ppp ++){\r\n                                            let u = edge_path[ppp].v\r\n                                            let v = edge_path[ppp].w\r\n                                            tmp_pts.push([this.tanGraphPoints[u].x, this.tanGraphPoints[u].y])\r\n                                            tmp_pts.push([this.tanGraphPoints[v].x, this.tanGraphPoints[v].y])\r\n                                        }\r\n                                        if(e.flag){\r\n                                            for(let tid = tmp_pts.length - 1; tid >= 0; tid --){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        else{\r\n                                            for(let tid = 0; tid < tmp_pts.length; tid ++){\r\n                                                pts.push([tmp_pts[tid][0], tmp_pts[tid][1]])\r\n                                            }\r\n                                        }\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            console.log(\"fill\")\r\n                            //for(let id = 0; id < pts.length; id ++){\r\n                            //    drawCircle(pts[id][0], pts[id][1], 5, 'red' , 2)\r\n                            //}\r\n\r\n                            this.drawAreas(cur_k, lineFunction(pts))\r\n                        }\r\n                    }\r\n                //}\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={900} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default KelpFusion","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {calDistance, PointToSegDist} from \"./util\"\r\nimport * as A from '@svgdotjs/svg.js'\r\nimport * as B from '@svgdotjs/svg.topoly.js'\r\nimport BSpline from \"./BSpline\";\r\nconst { pathDataToPolys } = require('svg-path-to-polygons');\r\n\r\n\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n\r\nclass CalOverLap extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        //this.getPath()\r\n        this.getSVG()\r\n\r\n    }\r\n\r\n\r\n    getSVG(){\r\n\r\n        let filename=\"Citywide.svg\"\r\n\r\n        fetch('/data/Evaluation/bubbleset/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'image/svg+xml'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.text())\r\n            .then(data=>{\r\n                //console.log(data)\r\n                console.log(data)\r\n\r\n                let doc = new DOMParser();\r\n                let xml = doc.parseFromString(data,\"image/svg+xml\")\r\n                let gs = xml.getElementsByTagName(\"g\")\r\n                console.log(\"select g res:\")\r\n                console.log(gs)\r\n                var paths = []\r\n                for(let i = 0; i < gs.length; i ++){\r\n                    let stylestr = gs[i].attributes[0].nodeValue.toString()\r\n                    let cmpstr = \"fill: none\"\r\n                    if(stylestr.match(cmpstr)==null){\r\n                      paths.push(gs[i].getElementsByTagName(\"path\"))\r\n                    }\r\n                }\r\n                //var paths = xml.getElementsByTagName(\"path\");\r\n\r\n                console.log(paths)\r\n                //console.log(xml)\r\n                //console.log(paths)\r\n\r\n                //console.log(paths)\r\n\r\n                let cat_Polygon = []\r\n                let cat_Area = []\r\n                let cat_Overlap_Area = []\r\n\r\n                let minX = Number.MAX_VALUE\r\n                let minY = Number.MAX_VALUE\r\n                let maxX = Number.MIN_VALUE\r\n                let maxY = Number.MIN_VALUE\r\n\r\n                for(let i = 0; i < paths.length; i ++){\r\n                    //console.log(paths[i])\r\n                    console.time(\"to polygon\")\r\n                    let path_data = paths[i][0].attributes.d.nodeValue\r\n                    let canvas = A.SVG().addTo('body')\r\n                    let p = canvas.path(path_data)\r\n                    let points = p.toPoly('5px')._array\r\n                    cat_Polygon.push(points)\r\n                    cat_Area.push(0)\r\n                    cat_Overlap_Area.push(0)\r\n                    for(let j = 0; j < points.length; j ++){\r\n                        let x = points[j][0]\r\n                        let y = points[j][1]\r\n                        minX = Math.min(minX, x)\r\n                        minY = Math.min(minY, y)\r\n                        maxX = Math.max(maxX, x)\r\n                        maxY = Math.max(maxY, y)\r\n                    }\r\n                    //console.log(points)\r\n                    d3.select(\"#mainsvg\").append(\"path\")\r\n                        .attr(\"d\",path_data)\r\n                        .attr(\"fill\",colors[i])\r\n                        .style('opacity', 0.5)\r\n                    //for(let j = 0; j < points.length; j ++){\r\n                    //    let x = points[j][0]\r\n                    //    let y = points[j][1]\r\n                    //    d3.select(\"#mainsvg\").append('circle')\r\n                    //        .attr(\"cx\",x)\r\n                    //        .attr(\"cy\",y)\r\n                    //        .attr(\"r\",2)\r\n                    //        .attr(\"fill\",\"red\")\r\n                    //}\r\n                    console.timeEnd(\"to polygon\")\r\n                }\r\n\r\n                d3.select(\"#mainsvg\")\r\n                    .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n\r\n                minX -= 5\r\n                minY -= 5\r\n                maxX += 5\r\n                maxY += 5\r\n\r\n                for(let x = minX; x <= maxX; x ++){\r\n                    for(let y= minY; y <= maxY; y ++){\r\n                        let overlapID = []\r\n                        for(let i = 0; i < cat_Polygon.length; i ++){\r\n                            if(IsoInsideTest([x, y], cat_Polygon[i])){\r\n                                overlapID.push(i)\r\n                                cat_Area[i] ++\r\n                            }\r\n                        }\r\n                        if(overlapID.length > 1){\r\n                            d3.select('#mainsvg').append(\"circle\")\r\n                                .attr(\"cx\",x)\r\n                                .attr(\"cy\",y)\r\n                                .attr(\"r\",1)\r\n                                .attr(\"fill\",\"red\")\r\n                            for(let i = 0; i < overlapID.length; i ++){\r\n                                cat_Overlap_Area[i] ++\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let Sum_Area = 0\r\n                let Overlap_Area = 0\r\n\r\n                for(let i = 0; i < cat_Area.length; i ++){\r\n                    Sum_Area += cat_Area[i]\r\n                    Overlap_Area += cat_Overlap_Area[i]\r\n                }\r\n\r\n                console.log(filename)\r\n                console.log(\"OverLap Area: \" + Overlap_Area)\r\n                console.log(\"Sum Area: \" + Sum_Area)\r\n                console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n            })\r\n\r\n    }\r\n\r\n    getPath(){\r\n\r\n        //for(let f = 1; f <= 10; f ++){\r\n            //let filename = \"ex\" + f.toString() + \".txt\"\r\n            //console.log(filename)\r\n            let filename = \"Citywide.txt\"\r\n            fetch('/data/Evaluation/'+filename,{\r\n                method:'GET',\r\n                headers:{\r\n                    'Content-Type':'application/json;charset=UTF-8'\r\n                },\r\n                mode:'cors',\r\n                cache:'default'\r\n            })\r\n                .then(res=>res.json())\r\n                .then(data=>{\r\n                    //console.log(data)\r\n                    var paths = data\r\n\r\n                    let cat_Polygon = {}\r\n                    let cat_Area = {}\r\n                    let cat_Overlap_Area = {}\r\n                    let selectIdx = {}\r\n\r\n                    let minX = Number.MAX_VALUE\r\n                    let minY = Number.MAX_VALUE\r\n                    let maxX = Number.MIN_VALUE\r\n                    let maxY = Number.MIN_VALUE\r\n\r\n                    //console.log(paths)\r\n                    console.time(\"cal\")\r\n                    for(let k in paths){\r\n\r\n                        let draw_data = \"\"\r\n\r\n                        cat_Polygon[k] = []\r\n                        cat_Area[k] = 0\r\n                        cat_Overlap_Area[k] = 0\r\n\r\n                        let sID = 0\r\n                        let maxPath = -1\r\n\r\n                        console.time(\"to polygon\")\r\n                        for(let i = 0; i < paths[k].length; i ++){\r\n                            let path_data = paths[k][i]\r\n                            draw_data += path_data\r\n                            let canvas = A.SVG().addTo('body')\r\n                            let p = canvas.path(path_data)\r\n                            let points = p.toPoly('5px')._array\r\n                            cat_Polygon[k].push(points)\r\n                            if(points.length > maxPath){\r\n                                maxPath = points.length\r\n                                sID = i\r\n                            }\r\n                            for(let j = 0; j < points.length; j ++){\r\n                                let x = points[j][0]\r\n                                let y = points[j][1]\r\n                                minX = Math.min(minX, x)\r\n                                minY = Math.min(minY, y)\r\n                                maxX = Math.max(maxX, x)\r\n                                maxY = Math.max(maxY, y)\r\n                            }\r\n                        }\r\n                        console.timeEnd(\"to polygon\")\r\n\r\n                        selectIdx[k] = sID\r\n\r\n                        d3.select(\"#mainsvg\").append(\"path\")\r\n                            .attr(\"d\",draw_data)\r\n                            .style(\"fill\",colors[parseInt(k)])\r\n                            .style('opacity', 0.5)\r\n\r\n                    }\r\n\r\n                    d3.select(\"#mainsvg\")\r\n                        .attr(\"viewBox\",minX+\" \"+minY+\" \"+(maxX-minX)+\" \"+(maxY-minY))\r\n\r\n                    minX -= 5\r\n                    minY -= 5\r\n                    maxX += 5\r\n                    maxY += 5\r\n\r\n                    //console.log(cat_Polygon)\r\n\r\n                    for(let x = minX; x <= maxX; x ++){\r\n                        for(let y= minY; y <= maxY; y ++){\r\n\r\n                            let overlapID = []\r\n\r\n                            for(let k in cat_Polygon){\r\n\r\n                                let sID = selectIdx[k]\r\n\r\n                                if(!IsoInsideTest([x, y], cat_Polygon[k][sID])){\r\n                                    continue\r\n                                }\r\n\r\n                                let flag2 = true\r\n                                for(let i = 0; i < cat_Polygon[k].length; i ++){\r\n                                    if(i == sID){\r\n                                        continue\r\n                                    }\r\n                                    if(IsoInsideTest([x, y], cat_Polygon[k][i])){\r\n                                        flag2 = false\r\n                                        break\r\n                                    }\r\n                                }\r\n\r\n                                if(flag2){\r\n                                    cat_Area[k] ++\r\n                                    overlapID.push(k)\r\n                                }\r\n\r\n                            }\r\n\r\n                            if(overlapID.length > 1){\r\n                                d3.select('#mainsvg').append(\"circle\")\r\n                                    .attr(\"cx\",x)\r\n                                    .attr(\"cy\",y)\r\n                                    .attr(\"r\",1)\r\n                                    .attr(\"fill\",\"red\")\r\n                                for(let i = 0; i < overlapID.length; i ++){\r\n                                    cat_Overlap_Area[i] ++\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    let Sum_Area = 0\r\n                    let Overlap_Area = 0\r\n\r\n                    for(let k in cat_Area){\r\n                        Sum_Area += cat_Area[k]\r\n                        Overlap_Area += cat_Overlap_Area[k]\r\n                    }\r\n\r\n                    console.log(filename)\r\n                    console.log(\"OverLap Area: \" + Overlap_Area)\r\n                    console.log(\"Sum Area: \" + Sum_Area)\r\n                    console.log(\"Result: \" + Overlap_Area / Sum_Area)\r\n\r\n                    console.timeEnd(\"cal\")\r\n\r\n\r\n\r\n                })\r\n        //}\r\n        //let filename=\"life_fertility.txt\"\r\n\r\n\r\n    }\r\n\r\n\r\n    render(){\r\n        return (\r\n            <div style={{width:1200,margin:\"0 auto\",marginTop:10}}>\r\n                <svg id=\"mainsvg\" width={1200} height={1200} style={{border:\"1px solid #000000\"}}></svg>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default CalOverLap","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport BubbleDemo from \"./BubbleDemo\"\r\nimport KelpDiagram from\"./KelpDiagram\"\r\nimport KelpFusion from \"./KelpFusion\";\r\nimport CalOverLap from \"./CalOverLap\";\r\nimport CSVData from \"./CSVData\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n\r\n      <BubbleDemo></BubbleDemo>\r\n      {/*<KelpDiagram></KelpDiagram>*/}\r\n      {/*<KelpFusion></KelpFusion>*/}\r\n      {/*<CalOverLap></CalOverLap>*/}\r\n      {/*<CSVData></CSVData>*/}\r\n\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}