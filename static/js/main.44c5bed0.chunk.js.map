{"version":3,"sources":["priority_queue.js","reportWebVitals.js","util.js","BSpline.js","AdaptiveIsovalue.js","HierarchicalCluster.js","IndexUI.js","BubbleDemo.js","index.js"],"names":["PriorityQueue","d","this","_d","_elements","module","exports","prototype","checkEdgeCrossing","P1","P2","Q1","Q2","Math","min","x","max","y","isEmpty","size","peek","Error","modify_Prim","e1","e2","thisid","weightcross","szbefore","length","i","s","start","e","end","id","clusterid2","hasOwnProperty","cat","score","splice","tmp","enq","sz","parseInt","adjust","searchFather","f","m","j","_compare","modify_Kruskal_V2","fs","clusterid1","fe","push","modify_Kruskal","fa","deq","first","last","pop","current","largest","left","right","_swap","element","parent","floor","forEach","fn","a","b","aux","pid","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","calDistance","x1","y1","x2","y2","sqrt","pow","normalizeVec","vec","norm","drawRect","width","height","color","d3","append","attr","PointToSegDist","cross","d2","r","px","py","BSpline","points","degree","copy","dimension","baseFunc","basisDeg2","baseFuncRangeInt","basisDeg3","basisDeg4","basisDeg5","seqAt","dim","margin","n","getInterpol","seq","t","rangeInt","tInt","result","calcAt","res","g","offsetX","offsetY","viewWidth","viewHeight","MarchingSquaresJS","require","IsoInsideTest","AreaCal","IntersectionQuery","ShapeInfo","Intersection","Point2D","colors","buffer","nodeR1","nodeR0","edgeR1","edgeR0","defaultEdgeWidth","itemEnergyShape","nodeWeight","edgeWeight","barrierGap","intervals","pixelGroup","gapBetween","fixdis","control_points","initialControlPoints","is_selected","eps","nearpts","hasChangeView","prepoints","svgwidth","svgheight","skipPoint","minItemArea","Number","MAX_VALUE","editSeg","lineFunction","curve","lineFunction_reDraw","clone","obj","Date","setTime","getTime","Array","Object","AdaptiveIsovalue","onChangeEdgeWidth","value","setState","edgeWidth","changeEdgeWidth","selectedEdge","onChangeNodeR0","onChangeNodeR1","onChangeEdgeR0","onChangeEdgeR1","onChangePixelGroup","onChangeGap","state","hasSelectEdge","isfirstcreate","pointData","canvasWidth","canvasHeight","maxX","maxY","minX","minY","maxDis","MIN_VALUE","catPointDict","catEdgeDict","edges","maxDistance","itemShape","itemBBox","catEnergyField","catNotGroup","activeRegion","energyField","field","editMode","editIndex","updatedEnergyPoints","edgeControlPoints","hasMST","updateIdx","hasBubbles","firstFlag","render","componentDidMount","X","Y","Width","Height","props","onRef","document","getElementById","getBoundingClientRect","oncontextmenu","pdict","flag","c","catArray","nowcat","edict","filledges","catarr","startpoint","editPoints","editEdges","HpointData","Hedges","shape","parseFloat","toString","cats","split","catarray","multicat","centralizeData","calEdgeLength","calActiveRegion","updatePoints","updateEdges","preProcessPoints","preProcessEdges","calEnergyField_Part","calFinalEnergeField_Part","fillCrossingEdge_Part","remove","findOutLine","calOutLine","calEdgeControlPoints","that","on","selectAll","filter","init","createMST","radius","PI","loadEdgeData","handleCreated","ViewFlag","minx","miny","maxx","maxy","virtrual","vpoints","virtrualNodes","p","colorArray","call","extent","scaleExtent","transform","event","items","index","getElementsByTagName","getAttribute","getBBox","bbox","sortArr","avgdis","tempcontrolpoints","k","controlpoints","minDis","minindex","edge","dis","order","iscontinue","temppoints","lastindex","sort","dw","dir","firstOutline","secondOutline","p1","vec1","dot","dx","dy","drawPathData","reDraw","stopPropagation","handleClick","vstart","vend","v","thisindex","minlength","maxlength","endpoint","vpoint","nowp","nextp","edgelength","maxEdgeLength","minEdgeLength","nextProps","nextState","nextContext","fieldData","startY","boundingY","startX","boundingX","endY","boundingHeight","endX","boundingWidth","finalField","isoDict","calISOLine","polygontest","tmp_polygon","prelength","polygon","sk","selectidx","curlen","meandis","sidx","isthis","st_idx","pt_len","j_pt","idx1","idx2","ve1","ve2","ve3","ve3_len","test_pt","is_use_inner","j_y","j_x","path_Info","curdata","drawISOLinesV2","calEnergyField","calFinalEnergeField","fillCrossingEdge","createGapInBoundary","drawEdges","drawPointData","ceil","centerX","centerY","barrierMap","fill","item","lx1","ly1","lx2","ly2","projlenSq","dotprod","lenSq","distancetoendnode","distancetoedge","mindis","distancetostartnode","totaldistance","getPointEdgeDistance","enddis","sp","se","selength","distancetonode","rect1","rect2","point","maxpdis","k1","isGroup","isgroup","k2","calDistanceToEdge","pointMap","pointBarrierMap","edgeBarrierMap","pointIndexMap","edgeIndexMap","edgeIndexMap2","subUpdate","members","startx","endx","starty","endy","realx","realy","distance","calDistanceToItem","energy","EDGELENGTH_THRESH","startid","endid","calDistanceToEdgeV2","distancetoEdge","distancetoNode","totalDistance","newR1","delflag","it","relativex","relativey","hasSameCat","samecat","c1","cat1","c2","cat2","area_abc","area_abd","area_cda","gap","deletePoints","isboundary","delta","isolines","isolinepoints","isoLineMap","relativepoints","isoInsidePoints","pointInPolygon","notDeleteIndex","nodePoints","totalInside","isolineIndex","deleteindex","isdelete","newisolines","catarr1","catarr2","gfield","finalvalue","isInside","thisPointID","gpointIndexMap","thisEdgeID","gedgeIndexMap","thiscat","gbarrierMap","gwidth","gheight","othervalue","otherinside","otherPointID","otherEdgeID","othercat","isContained","gpointBarrierMap","Set","updateidx","preK","bounding","smoothEnergyField","idx","val","lines","p2","val1","val2","tmpx","uy","ux","map","style","dat","Polygon","max_y","min_y","max_x","min_x","NET","ymax","AET","curi","abs","CurSize","fx","fy","relativeotherx","relativeothery","P_1","P_2","p_x1","shift","p_x2","x_begin","x_end","cut","len","bx1","by1","bx2","by2","dragstarted","execflag","_groups","attributes","tmp_idx","isnum","iidx","jidx","v1","v2","dragged","sourceEvent","target","ex","ey","reDrawData","cur_len","tmp_pts","q","tmpDict","sid","cur_idx","s_pts","tmpPath","node","totLen","getTotalLength","r1_idx","dis1","r2_idx","dis2","tmp_p","getPointAtLength","tmpdis1","tmpdis2","dragended","v3","vec2","fillPolygon","button","pointpath","data","isoLines","polygons","linearRing","noFrame","isoLineDict","tpoints","splinePoints","spline","kernel","sum","theta","kernelsize","anchor","C","ny","nx","exp","normalizeKernel","isSingular","edgeCrossingList","start1","end1","linesToCheck1","vlength","start2","end2","linesToCheck2","l1","l2","crossInfo","newFieldDict","crossingPoints","fillArea","crosspoint","otherid","line","crossline","dl","lineLength","vec3","linedirvec","normdirvec","step","topBoundPoints","bottomBoundPoints","lastTop","lastBottom","rightstop","topstop","bottomstop","newanchor1","disalongline","topfind","bottomfind","newpointtop","newxtop","newytop","otherx","othery","newpointbottom","newxbottom","newybottom","fillPolyPoints","leftstop","newanchor2","fillPolygonForEdge","getGaussianKernel","sx","sy","cur_width","cur_height","newField","newvalue","formatpoints","isInterior","parentID","updateEnergyPoints","span","onChange","disabled","onClick","getData","bind","hasLoadData","removeOverlaps","Component","defaultProps","preEdgeDict","curEdgeDict","FileSaver","jsgraphs","POINT_EDGE_EPS","DBSCAN_EPS","clustering","weightCross","weightDistance","weightMess","maxCross","DISTANCE_THRESHHOLD","priority_queue","svgid","opsvgid","preEdges","tmpEditEdges","editView","BeforeWidth","BeforeHeight","ScreenWidth","ScreenHeight","HierarchicalCluster","ref","child","read","hasinit","hasEdit","hascreated","editV","issplit","graph","clustergraph","isSelect","selectItem","clusterDict","clustergraphInfo","clusterArr","noiseDict","intersecEdges","vis","heap1","heap2","QTree","edgesdict","draggedIndex","draggedEdgeIndex","draggedEdgeSeg","nodeStartDict","nodeEndDict","lastClickIndex","lastClickItem","deletedEdge","addedEdge","tempEdges","componentWillMount","init_all","window","screen","availHeight","availWidth","dissum","disnum","tmpp1","calEPS","optimizeMST","applyEdit","generateTreeWithHierarchical","hasCreate","Graph","V","label","disArray","messArray","tempedges","mess","calEdgeMess","weight","calEdgeWeight","node1","node2","crossnum","edgecat","sortedEdges","removeEdggeList","sortEdgesGlobal","DepthFirstSearch","hasPathTo","checkNewEdge","addEdge","checkConnect","tempEdgeList","scores","calEdgeWeightWithCrossing","minCost","maxindex","sortEdgesGlobalWithMinDis","edgesnum","nodesnum","dfs","id1","id2","removelist","num","isPointInEdgeRange","calPointEdgeDistance","getVecNorm","calVecCosine","vec4","seg1","SVGElement","select","empty","insert","drawOneEdge","each","savedData","fetch","method","headers","mode","cache","json","console","log","removeindex","isedit","newGraph","cc","ConnectedComponents","newClusterDict","componentCount","componentId","idnum","getElementsByClassName","newEdges","recalculateSpanningTreeAfterEdit","drawOneEdgeAfterEdit","tmpe","recalculateSpanningTree","new","ei","thisedge","startp","endp","pcat","linesToCheck","ids","swap","checkline","intersecInfo","findCrossingBetweenEdgeRect","rec","rect","line1","line3","line2","line4","point1","point2","vnode","cornerpointindex","cornerpoint","iternum","vnode1","vnode2","centerpoint","movevec","movenorm","checkVNodeInBound","minCross","bestVnode","potentialNode","pnode","count","node3","temppoint","samepoiint","newid","index1","index2","newedge","isLocalTree","surfaceRoutingEdge","oneEdge","dragControlPoint","edgeindex","segindex","bubbleState","editReDraw","dragEdge","handleMouseDown","newline","edgeIndex","segIndex","thisedgeindex","thissegindex","deleteEdge","findCircle","catEdges","nodeDegree","finish","circleEdges","has","lastcat","checkCircle","isAdded","worstindex","worstscore","worstEdge","drag","nodeindex","st","en","rerouting","w","h","deleteEdges","reroutingEdges","pointedgedis","preEdge","tmpp","vnodes1","flag1","st1_p","en1_p","st2_p","en2_p","vnodes2","path","clickIndex","hasLinked","lines1","vnodes","lines2","p3","p4","midx","midy","midnode","initWithNoCluster","preAddedClusters","catclusters","startclusterid","endclusterid","merged","newclusterdict","createGraphWithCluster","createLocalTree","hierarchicalMergeV2","dbscan","DBSCAN","dataset","pointDataSet","clusters","run","clusterPoints","noise","g2","cluster1","cluster2","calClusterDistance","minstart","minend","minScore","bestStart","bestEnd","minScoreWithDis","links","minIndex","minScoreWithDistance","minIndexWithDistance","hasBest","checkConnectBetweenTwoCluster","rectangle","top","intersections","intersect","status","pointInRectangle","isDeleted","checkConnectBetweenTwoClusterV2","totcluster","optimalLinks1","optimalLinks2","addLinks","checkConnectBetweenAllCluster","bestLink","unionFather","checkConnectBetweenAllClusterV2","optimalLinks","link","findOptimalLink","findMinScore","sortEdgesGlobalWithCluster","findLinkBetweenCluster","checkConnectBetweenCluster","clusterstart","clusterend","infostr","handleManually","afterEditReDraw","content","JSON","stringify","blob","Blob","type","saveAs","marginTop","checkedChildren","unCheckedChildren","editBackbone","checked","svg","svgsaver","Header","Select","Option","Layout","Footer","Sider","Content","columns","title","dataIndex","text","key","tags","tag","keynum","GroupDict","cur_set","is_input","IndexUI","updateview","GroupData","name","dataFile","scaleX","scaleY","selValue","hasCreateMST","menu","Item","rel","savePNG","saveSVG","saveData","box","handleMousedown","cx","cy","undefined","Scale","tmpg","handleDeleteNode","addNewPoints","set","tmp_index","findIndex","GroupCat","curcat","tmpcat","tmpGroupData","alert","scale_ratio_x","scale_ratio_y","transform_dx","transform_dy","ratio","filename","drawInit","saveSvgAsPng","viewbox","svgstr","html","options","p5","pad1","pad2","background","textAlign","fontFamily","fontWeight","fontSize","theme","padding","className","float","border","showSearch","placeholder","changeSel","handleUpload","overlay","arrow","DownOutlined","pagination","position","scroll","dataSource","BubbleDemo","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.44c5bed0.chunk.js","sourcesContent":["//https://github.com/janogonzalez/priorityqueuejs\n\nmodule.exports = PriorityQueue;\n\nfunction PriorityQueue(d) {\n    this._d = d;\n    this._elements = [];\n}\n\nPriorityQueue.prototype.checkEdgeCrossing = function(P1,P2,Q1,Q2){\n    if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\n        Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\n        Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\n        Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\n        if(\n            ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\n            ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\n        ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false\n    }\n}\n\nPriorityQueue.prototype.isEmpty = function() {\n    return this.size() === 0;\n};\n\nPriorityQueue.prototype.peek = function() {\n    if (this.isEmpty()) throw new Error('PriorityQueue is empty');\n    return this._elements[0];\n};\n\nPriorityQueue.prototype.modify_Prim = function(e1,e2,thisid,weightcross){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    let szbefore = this._elements.length;\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let id = this._d[this._elements[i]].clusterid2;\n        if((!this._d.hasOwnProperty(this._elements[i])) || id == thisid){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n    }\n    let tmp = this._elements;\n    this._elements = [];\n    for(let i = 0;i< tmp.length;i++){\n        this.enq(tmp[i]);\n    }\n\n    let sz = this._elements.length;\n    if(sz <= 1 || sz == szbefore){\n        return;\n    }\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n}\n\nPriorityQueue.prototype.searchFather = function (f,x){\n    while(x!=f[x]){\n        f[x] = f[f[x]];\n        x = f[x];\n    }\n    return x;\n}\n\nPriorityQueue.prototype.adjust = function(start, m){\n    let i = start;\n    let j = 2 * i + 1;\n    let tmp = this._elements[i];\n    while(j <= m){\n        if(j < m && this._compare(j, j + 1)){\n            j ++;\n        }\n        if(this._d[tmp].score <= this._d[this._elements[j]].score){\n            break;\n        }\n        else{\n            this._elements[i] = this._elements[j];\n            //V1\n            //this._d[this._elements[i]].pid = i;\n            i = j;\n            j = 2 * j + 1;\n        }\n    }\n    this._elements[i] = tmp;\n    //V1\n    //this._d[this._elements[i]].pid = i;\n}\n//function(e1,e2,f,weightcross,fa)\n\nPriorityQueue.prototype.modify_Kruskal_V2 = function(e1,e2,f,weightcross){\n\n    //let szbefore = this._elements.length;\n    let tmp = []\n    for(let i = this._elements.length - 1;i >= 0;i --){\n        let s = this._d[this._elements[i]].start;\n        let e = this._d[this._elements[i]].end;\n        let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n        let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n        if((!this._d.hasOwnProperty(this._elements[i]))){\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(fs == fe){\n            delete this._d[this._elements[i]];\n            this._elements.splice(i,1);\n            continue;\n        }\n        if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n            this._d[this._elements[i]].score += weightcross\n        }\n        tmp.push(this._elements[i])\n    }\n\n    let sz = tmp.length;\n\n    if(sz <= 1){\n        return;\n    }\n\n    this._elements=[]\n\n    for(let i = 0;i < sz;i ++){\n        this.enq(tmp[i]);\n    }\n\n    //for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n    //    this.adjust(i,sz - 1);\n    //}\n\n}\n\nPriorityQueue.prototype.modify_Kruskal = function(e1,e2,f,weightcross,fa){\n    //let a = this._elements.length\n    //console.log(\"modify before: \" + a)\n    //let szbefore = this._elements.length;\n    //for(let i = this._elements.length - 1;i >= 0;i --){\n    //    let s = this._d[this._elements[i]].start;\n    //    let e = this._d[this._elements[i]].end;\n    //    let fs = this.searchFather(f,this._d[this._elements[i]].clusterid1);\n    //    let fe = this.searchFather(f,this._d[this._elements[i]].clusterid2);\n    //    if((!this._d.hasOwnProperty(this._elements[i]))){\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(fs == fa && fe == fa){\n    //        delete this._d[this._elements[i]];\n    //        this._elements.splice(i,1);\n    //        continue;\n    //    }\n    //    if(this.checkEdgeCrossing(s,e,e1,e2) && s.cat != e1.cat && e.cat != e2.cat){\n    //        this._d[this._elements[i]].score += weightcross\n    //    }\n    //}\n\n    let sz = this._elements.length;\n\n    //if(sz <= 1 || sz == szbefore){\n    //    return;\n    //}\n\n    for(let i = parseInt((sz - 2) / 2);i >= 0;i --){\n        this.adjust(i,sz - 1);\n    }\n\n    //for(let i = 0;i < sz;i ++){\n    //    this._d[this._elements[i]].pid = i;\n    //}\n\n}\n\nPriorityQueue.prototype.deq = function() {\n    //let a = this._elements.length\n    //console.log(\"deq before: \" + a)\n    //delete this._d[this._elements[0]];\n    var first = this.peek();\n    //V1\n    //this._d[first].pid = -1;\n    var last = this._elements.pop();\n    var size = this.size();\n    if (size === 0) return first;\n\n    this._elements[0] = last;\n    var current = 0;\n\n    while (current < size) {\n        var largest = current;\n        var left = (2 * current) + 1;\n        var right = (2 * current) + 2;\n\n        if (left < size && this._compare(left, largest) >= 0) {\n            largest = left;\n        }\n\n        if (right < size && this._compare(right, largest) >= 0) {\n            largest = right;\n        }\n\n        if (largest === current) break;\n\n        this._swap(largest, current);\n        current = largest;\n    }\n    //let b = this._elements.length\n    //console.log(\"deq after: \" + b)\n    return first;\n};\n\nPriorityQueue.prototype.enq = function(element) {\n    //let a = this._elements.length\n    //console.log(\"enq before: \" + a)\n    var size = this._elements.push(element);\n    var current = size - 1;\n\n    while (current > 0) {\n        var parent = Math.floor((current - 1) / 2);\n        if (this._compare(current, parent) <= 0) break;\n        this._swap(parent, current);\n        current = parent;\n    }\n   //let b = this._elements.length\n   //console.log(\"enq after: \" + b)\n    return size;\n};\n\nPriorityQueue.prototype.size = function() {\n    return this._elements.length;\n};\n\nPriorityQueue.prototype.forEach = function(fn) {\n    return this._elements.forEach(fn);\n};\n\nPriorityQueue.prototype._compare = function(a, b) {\n    return this._d[this._elements[b]].score - this._d[this._elements[a]].score;\n};\n\nPriorityQueue.prototype._swap = function(a, b) {\n    var aux = this._elements[a];\n    this._d[this._elements[a]].pid = b;\n    this._d[this._elements[b]].pid = a;\n    this._elements[a] = this._elements[b];\n    this._elements[b] = aux;\n};","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import * as d3 from \"d3\";\r\n\r\nexport function add(a,b){\r\n    return a+b\r\n}\r\n\r\nexport function calDistance(x1,y1,x2,y2){\r\n    return Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2))\r\n}\r\n\r\nexport function getVecNorm(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    return norm\r\n}\r\n\r\nexport function normalizeVec(vec){\r\n    let norm=Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    let newvec=[vec[0]/norm,vec[1]/norm]\r\n    return newvec\r\n}\r\n\r\nexport function drawCircle(x,y,r,fill,stroke){\r\n    d3.select(\"#mainsvg\")\r\n        .append(\"circle\")\r\n        .attr(\"class\",\"elespace\")\r\n        .attr(\"cx\",x)\r\n        .attr(\"cy\",y)\r\n        .attr(\"r\",r)\r\n        .attr(\"fill\",fill)\r\n        .attr(\"stroke\",stroke)\r\n        .attr(\"stroke-width\",1)\r\n}\r\n\r\nexport function drawRect(x,y,width,height,color){\r\n    d3.select(\"svg\")\r\n        .append(\"rect\")\r\n        .attr(\"x\",x-width/2)\r\n        .attr(\"y\",y-height/2)\r\n        .attr(\"width\",width)\r\n        .attr(\"height\",height)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",color)\r\n        .attr(\"stroke-width\",2)\r\n}\r\n\r\nexport function drawPolygon(points,dx,dy,color){\r\n    d3.select(\"svg\").append(\"path\")\r\n        .style(\"fill\", \"none\")\r\n        .style(\"stroke\",color)\r\n        .style(\"stroke-width\", 0.5)\r\n        .attr(\"d\", function () {\r\n            var p = \"\";\r\n            p += (d3.line()\r\n                    .x(function (dat) {\r\n                        return dat[0]+dx;\r\n                    })\r\n                    .y(function (dat) {\r\n                        return dat[1]+dy;\r\n                    })\r\n            )(points)+ \"\";\r\n            return p;\r\n        })\r\n        .on('mouseover', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"red\")\r\n                .style(\"stroke-width\", 2);\r\n        })\r\n        .on('mouseout', function () {\r\n            d3.select(this)\r\n                .style('stroke', \"black\")\r\n                .style(\"stroke-width\", 0.5);\r\n        });\r\n}\r\nexport function drawLine(start,end,color,width){\r\n    d3.select(\"svg\").append(\"line\")\r\n        .attr(\"x1\",start[0])\r\n        .attr(\"y1\",start[1])\r\n        .attr(\"x2\",end[0])\r\n        .attr(\"y2\",end[1])\r\n        .attr(\"stroke-width\",width)\r\n        .attr(\"stroke\",color)\r\n        .on(\"mouseover\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",\"red\")\r\n        })\r\n        .on(\"mouseout\",function(){\r\n            d3.select(this)\r\n                .attr(\"stroke\",color)\r\n        })\r\n}\r\n\r\nexport function  isContained(catarr,cat){\r\n    catarr=catarr.split(\",\")\r\n    for(let i=0;i<catarr.length;i++){\r\n        if(catarr[i]==cat){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nexport function  PointToSegDist( x,  y,  x1,  y1,  x2,  y2)\r\n{\r\n     let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n    // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n    if (cross <= 0) return -1\r\n\r\n     let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n    // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n    if (cross >= d2) return -1\r\n\r\n\r\n\r\n    let r = cross / d2;\r\n    let px = x1 + (x2 - x1) * r;\r\n    let py = y1 + (y2 - y1) * r;\r\n    return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));\r\n}\r\n\r\nfunction calLineCirclePoint(){\r\n    //ax+by+c=0\r\n}\r\n\r\nexport function calTanPoint(cx,cy,radius,point) {\r\n    //\r\n    let d = Math.sqrt(Math.pow(cx - point.x,2) + Math.pow(cy - point.y,2));\r\n    let vc1c2 = {x:point.x - cx,y:-point.y + cy}; //y\r\n    let radC1C2 = Math.acos(vc1c2.x / Math.sqrt(Math.pow(vc1c2.x,2) + Math.pow(vc1c2.y,2)));\r\n    let theta = Math.acos(radius/d);\r\n    if(point.y < cy){\r\n        let p1 = {x:cx + Math.cos(theta + radC1C2)*radius,y:cy - Math.sin(theta + radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(theta - radC1C2)*radius,y:cy + Math.sin(theta - radC1C2)*radius};\r\n        return {p1:p1,p2:p2};\r\n    }else{\r\n        radC1C2 = Math.PI - radC1C2;\r\n        let p1 = {x:cx + Math.cos(Math.PI - theta - radC1C2)*radius,y:cy + Math.sin(Math.PI - theta - radC1C2)*radius};\r\n        let p2 = {x:cx + Math.cos(Math.PI - (theta - radC1C2))*radius,y:cy - Math.sin(Math.PI - (theta - radC1C2))*radius};\r\n        return {p1:p1,p2:p2};\r\n    }\r\n}\r\n\r\nexport function calCommonTanPoint(x1,y1,r1,x2,y2,r2){\r\n    let tanPoints=[]\r\n    let delta1=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1+r2,2)//+\r\n    let delta2=Math.pow(x1-x2,2)+Math.pow(y1-y2,2)-Math.pow(r1-r2,2)//-\r\n\r\n    let p1=r1*(x2*x2+y2*y2-x1*x2-y1*y2)\r\n    let p2=r2*(x1*x1+y1*y1-x1*x2-y1*y2)\r\n    let q=x1*y2-x2*y1\r\n\r\n    //four points\r\n    let vecpq=[x2-x1,y2-y1]\r\n    let normvec=[-vecpq[1],vecpq[0]]\r\n    let dir=normalizeVec(normvec)\r\n    let newpointp=[x1+r1*dir[0],y1+r1*dir[1]]\r\n    let newpointq=[x2+r2*dir[0],y2+r2*dir[1]]\r\n\r\n    tanPoints.push([newpointp,newpointq])\r\n\r\n    let dir2=[-1*dir[0],-1*dir[1]]\r\n    let newpointp2=[x1+r1*dir2[0],y1+r1*dir2[1]]\r\n    let newpointq2=[x2+r2*dir2[0],y2+r2*dir2[1]]\r\n\r\n    tanPoints.push([newpointp2,newpointq2])\r\n\r\n\r\n    if(delta1<0&&delta2<0){\r\n        return []\r\n    }\r\n    else if(delta1<0&&delta2>0){\r\n        //, just four points, two lines\r\n        return tanPoints\r\n    }\r\n    else if(delta1==0&&delta2>0){\r\n        //, five points, two lines\r\n        return tanPoints\r\n\r\n    }\r\n    else if(delta1>0&&delta2>0){\r\n        //, eight points, four lines\r\n        let intersecx=(r1*x2+r2*x1)/(r1+r2)\r\n        let intersecy=(r1*y2+r2*y1)/(r1+r2)\r\n        let tanpoints1=calTanPoint(x1,y1,r1,{x:intersecx,y:intersecy})\r\n        let tanpoints2=calTanPoint(x2,y2,r2,{x:intersecx,y:intersecy})\r\n\r\n        let p1=tanpoints1.p1\r\n        let p2={x:intersecx,y:intersecy}\r\n        let p3=tanpoints2.p1\r\n\r\n        let delta=(p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x)\r\n        if(Math.abs(delta)<=0.000001){\r\n            //p1p1\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n\r\n        }\r\n    else{\r\n        //p1p2\r\n            tanPoints.push([[tanpoints1.p1.x,tanpoints1.p1.y],[tanpoints2.p2.x,tanpoints2.p2.y]])\r\n            tanPoints.push([[tanpoints1.p2.x,tanpoints1.p2.y],[tanpoints2.p1.x,tanpoints2.p1.y]])\r\n        }\r\n\r\n    return tanPoints\r\n\r\n    }\r\n\r\n    else{\r\n        return []\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nexport function drawArc(startp,endp,center,radius){\r\n    let pathstr=\"\"\r\n    pathstr+=\"M \"+startp[0]+\",\"+startp[1]\r\n    let largearcflag=0\r\n    let vec1=[startp[0]-center[0],startp[1]-center[1]]\r\n\r\n    let vec2=[endp[0]-center[0],endp[1]-center[1]]\r\n    let crossmul=vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n    if(crossmul>0){\r\n        largearcflag=1\r\n    }\r\n    else if(crossmul<=0){\r\n        largearcflag=0\r\n    }\r\n    pathstr+=\" A \"+radius+\",\"+radius+\" 0 \"+largearcflag+\" ,0 \"+(endp[0])+\",\"+(endp[1])\r\n    d3.select(\"svg\")\r\n        .append(\"path\")\r\n        .attr(\"d\",pathstr)\r\n        .attr(\"fill\",\"none\")\r\n        .attr(\"stroke\",\"black\")\r\n        .attr(\"stroke-width\",\"1\")\r\n}\r\n\r\nexport function getDegreeTwoVec(vec1,vec2){\r\n    let norm1=getVecNorm(vec1)\r\n    let norm2=getVecNorm(vec2)\r\n    let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n\r\n    let cos=dot/(norm1*norm2)\r\n\r\n    return Math.acos(cos)\r\n\r\n}\r\n\r\nexport function rotatePoint(x,y,rx0,ry0,alpha){\r\n    let x0= (x - rx0)*Math.cos(alpha) - (y - ry0)*Math.sin(alpha) + rx0 ;\r\n    let y0= (x - rx0)*Math.sin(alpha) + (y - ry0)*Math.cos(alpha) + ry0 ;\r\n    return [x0,y0]\r\n}\r\n\r\nexport function crossMul(vec1,vec2){\r\n\r\n    return vec1[0]*vec2[1]-vec2[0]*vec1[1]\r\n}\r\n\r\nexport function clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}","var BSpline = function(points,degree,copy){\r\n    if(copy){\r\n        this.points = []\r\n        for(var i = 0;i<points.length;i++){\r\n            this.points.push(points[i]);\r\n        }\r\n    }else{\r\n        this.points = points;\r\n    }\r\n    this.degree = degree;\r\n    this.dimension = points[0].length;\r\n    if(degree == 2){\r\n        this.baseFunc = this.basisDeg2;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 3){\r\n        this.baseFunc = this.basisDeg3;\r\n        this.baseFuncRangeInt = 2;\r\n    }else if(degree == 4){\r\n        this.baseFunc = this.basisDeg4;\r\n        this.baseFuncRangeInt = 3;\r\n    }else if(degree == 5){\r\n        this.baseFunc = this.basisDeg5;\r\n        this.baseFuncRangeInt = 3;\r\n    } \r\n};\r\n\r\nBSpline.prototype.seqAt = function(dim){\r\n    var points = this.points;\r\n    var margin = this.degree + 1;\r\n    return function(n){\r\n        if(n < margin){\r\n            return points[0][dim];\r\n        }else if(points.length + margin <= n){\r\n            return points[points.length-1][dim];\r\n        }else{\r\n            return points[n-margin][dim];\r\n        }\r\n    };\r\n};\r\n\r\nBSpline.prototype.basisDeg2 = function(x){\r\n    if(-0.5 <= x && x < 0.5){\r\n        return 0.75 - x*x;\r\n    }else if(0.5 <= x && x <= 1.5){\r\n        return 1.125 + (-1.5 + x/2.0)*x;\r\n    }else if(-1.5 <= x && x < -0.5){\r\n        return 1.125 + (1.5 + x/2.0)*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg3 = function(x){\r\n    if(-1 <= x && x < 0){\r\n        return 2.0/3.0 + (-1.0 - x/2.0)*x*x;\r\n    }else if(1 <= x && x <= 2){\r\n        return 4.0/3.0 + x*(-2.0 + (1.0 - x/6.0)*x);\r\n    }else if(-2 <= x && x < -1){\r\n        return 4.0/3.0 + x*(2.0 + (1.0 + x/6.0)*x);\r\n    }else if(0 <= x && x < 1){\r\n        return 2.0/3.0 + (-1.0 + x/2.0)*x*x;\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg4 = function(x){\r\n    if(-1.5 <= x && x < -0.5){\r\n        return 55.0/96.0 + x*(-(5.0/24.0) + x*(-(5.0/4.0) + (-(5.0/6.0) - x/6.0)*x));\r\n    }else if(0.5 <= x && x < 1.5){\r\n        return 55.0/96.0 + x*(5.0/24.0 + x*(-(5.0/4.0) + (5.0/6.0 - x/6.0)*x));\r\n    }else if(1.5 <= x && x <= 2.5){\r\n        return 625.0/384.0 + x*(-(125.0/48.0) + x*(25.0/16.0 + (-(5.0/12.0) + x/24.0)*x));\r\n    }else if(-2.5 <= x && x <= -1.5){\r\n        return 625.0/384.0 + x*(125.0/48.0 + x*(25.0/16.0 + (5.0/12.0 + x/24.0)*x));\r\n    }else if(-1.5 <= x && x < 1.5){\r\n        return 115.0/192.0 + x*x*(-(5.0/8.0) + x*x/4.0);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.basisDeg5 = function(x){\r\n    if(-2 <= x && x < -1){\r\n        return 17.0/40.0 + x*(-(5.0/8.0) + x*(-(7.0/4.0) + x*(-(5.0/4.0) + (-(3.0/8.0) - x/24.0)*x)));\r\n    }else if(0 <= x && x < 1){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 - x/12.0)*x*x);\r\n    }else if(2 <= x && x <= 3){\r\n        return 81.0/40.0 + x*(-(27.0/8.0) + x*(9.0/4.0 + x*(-(3.0/4.0) + (1.0/8.0 - x/120.0)*x)));\r\n    }else if(-3 <= x && x < -2){\r\n        return 81.0/40.0 + x*(27.0/8.0 + x*(9.0/4.0 + x*(3.0/4.0 + (1.0/8.0 + x/120.0)*x)));\r\n    }else if(1 <= x && x < 2){\r\n        return 17.0/40.0 + x*(5.0/8.0 + x*(-(7.0/4.0) + x*(5.0/4.0 + (-(3.0/8.0) + x/24.0)*x)));\r\n    }else if(-1 <= x && x < 0){\r\n        return 11.0/20.0 + x*x*(-(1.0/2.0) + (1.0/4.0 + x/12.0)*x*x);\r\n    }else{\r\n        return 0;\r\n    }\r\n};\r\n\r\nBSpline.prototype.getInterpol = function(seq,t){\r\n    var f = this.baseFunc;\r\n    var rangeInt = this.baseFuncRangeInt;\r\n    var tInt = Math.floor(t);\r\n    var result = 0;\r\n    for(var i = tInt - rangeInt;i <= tInt + rangeInt;i++){\r\n        result += seq(i)*f(t-i);\r\n    }\r\n    return result;\r\n};\r\n\r\nBSpline.prototype.calcAt = function(t){\r\n    t = t*((this.degree+1)*2+this.points.length);//t must be in [0,1]\r\n    if(this.dimension == 2){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t)];\r\n    }else if(this.dimension == 3){\r\n        return [this.getInterpol(this.seqAt(0),t),this.getInterpol(this.seqAt(1),t),this.getInterpol(this.seqAt(2),t)];\r\n    }else{\r\n        var res = [];\r\n        for(var i = 0;i<this.dimension;i++){\r\n            res.push(this.getInterpol(this.seqAt(i),t));\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nexport default BSpline\r\n","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport { Slider, InputNumber, Row, Col } from 'antd';\r\nimport 'antd/dist/antd.css'; // or 'antd/dist/antd.less'\r\nimport { Button } from 'antd';\r\n\r\nimport * as d3 from \"d3\"\r\nimport {calDistance, drawRect, normalizeVec, drawPolygon, drawLine,PointToSegDist,getVecNorm} from \"./util\"\r\nimport BSpline from \"./BSpline\";\r\n\r\nvar MarchingSquaresJS = require('marchingsquares');\r\nvar IsoInsideTest = require('point-in-polygon');\r\nvar AreaCal = require('2d-polygon-area');\r\n//barrier map:\r\n//1: inside the gap of a node\r\n//2: inside the gap of an edge\r\n//3. inside a node\r\n//4. inside an edge\r\n//5. inside the initial field of a node\r\n//6. inside the initial field of an edge\r\n\r\n// Note: X and Y attribute are all center point for both circle and rectangle!\r\n\r\nvar pointDataName=\"BubbleSetExample1.txt\"\r\nvar edgeDataName=\"BubbleSetEdge1.txt\"\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar buffer=10\r\n// var nodeR0=10\r\n// var nodeR1=20\r\n// var edgeR0=15\r\n// var edgeR1=20\r\nvar nodeR1=15\r\nvar nodeR0=nodeR1-5\r\n\r\nvar edgeR1=20\r\nvar edgeR0=edgeR1-5\r\n\r\n\r\nvar defaultEdgeWidth=5\r\nvar edgeWidth=5 //5-10\r\nvar itemEnergyShape=\"circle\"\r\nvar nodeWeight=1\r\nvar edgeWeight=1\r\nvar nodeNegWeight=-0.8\r\nvar edgeNegWeight=0\r\nvar barrierGap=3\r\nvar intervals = [0.001]\r\nvar pixelGroup = 2\r\nvar gapBetween=1\r\nvar fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\nvar control_points={}\r\nvar initialControlPoints={}\r\nvar is_selected={}\r\nvar eps = 1e-10\r\nvar move_points = []\r\nvar mid_point = 0\r\nvar nearpts = []\r\nvar svg;\r\nvar g;\r\nvar hasChangeView = false;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\nvar prepoints = []\r\n\r\nvar svgwidth = 2000\r\nvar svgheight = 2000\r\nvar skipPoint = 10\r\nvar minItemArea = Number.MAX_VALUE\r\n\r\nvar editSeg = {}\r\nvar recalNum = 0\r\nvar recal = false\r\nvar remove_Polys = {}\r\n\r\nvar lineFunction = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveBasisClosed);\r\n\r\nvar lineFunction_reDraw = d3.line()\r\n    .x(function(d) { return d[0]; })\r\n    .y(function(d) { return d[1]; })\r\n    .curve(d3.curveCardinal);\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//d3.select(\"svg\")\r\nclass AdaptiveIsovalue extends  Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n        edges: PropTypes.array\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[],\r\n        edges:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        }\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init(){\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.updateIdx = []\r\n        this.firstFlag = true\r\n    }\r\n\r\n    init_all(){\r\n\r\n        colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        buffer=10\r\n        nodeR1=15\r\n        nodeR0=nodeR1-5\r\n        edgeR1=20\r\n        edgeR0=edgeR1-5\r\n        defaultEdgeWidth=5\r\n        edgeWidth=5\r\n        itemEnergyShape=\"circle\"\r\n        nodeWeight=1\r\n        edgeWeight=1\r\n        nodeNegWeight=-0.8\r\n        edgeNegWeight=0\r\n        barrierGap=3\r\n        intervals = [0.001]\r\n        pixelGroup = 2\r\n        gapBetween=1\r\n        fixdis = Math.sqrt(0.25 * (pixelGroup - 1) * (pixelGroup - 1) + 0.25 * (pixelGroup - 1) * (pixelGroup - 1))\r\n        control_points={}\r\n        initialControlPoints={}\r\n        is_selected={}\r\n        eps = 1e-10\r\n        move_points = []\r\n        mid_point = 0\r\n        nearpts = []\r\n        hasChangeView = false;\r\n        prepoints = []\r\n        svgwidth = 2000\r\n        svgheight = 2000\r\n        skipPoint = 10\r\n        minItemArea = Number.MAX_VALUE\r\n        editSeg = {}\r\n        recalNum = 0\r\n        recal = false\r\n        remove_Polys = {}\r\n\r\n        this.setState({\r\n            nodeR0: 10,\r\n            nodeR1: 20,\r\n            edgeR0: 15,\r\n            edgeR1: 20,\r\n            pixelGroup: 3,\r\n            gapBetween:1,\r\n            edgeWidth: defaultEdgeWidth,\r\n            hasSelectEdge:false\r\n        })\r\n        this.isfirstcreate=true\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.catEdgeDict={}\r\n        this.edges=[]\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.itemBBox=[]\r\n        this.catEnergyField={}\r\n        this.catNotGroup={}\r\n        this.activeRegion={\r\n            x:0,\r\n            y:0,\r\n            width:0,\r\n            height:0\r\n        }\r\n        this.energyField={\r\n            width:0,\r\n            height:0,\r\n            field:[]\r\n        }\r\n        this.editMode=false\r\n        this.editIndex=-1\r\n        this.updatedEnergyPoints={}\r\n        this.selectedEdge=-1\r\n        this.edgeControlPoints=[]\r\n        this.hasMST=false\r\n        this.updateIdx = []\r\n        this.hasBubbles = false\r\n        this.firstFlag = true\r\n\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n    }\r\n\r\n    bubbleState(){\r\n        return this.hasBubbles\r\n    }\r\n\r\n    setViewBox(X, Y, Width, Height){\r\n        X = offsetX\r\n        Y = offsetY\r\n        Width = viewWidth\r\n        Height = viewHeight\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n        //let svg = d3.select(\"svg\");\r\n\r\n\r\n        //this.getData()\r\n    }\r\n\r\n    preProcessPoints(points, pdict){\r\n        for(let i = 0;i < points.length; i ++){\r\n            let tmp\r\n            if(points[i].flag == true){\r\n                tmp = this.pointData[points[i].id]\r\n                tmp.flag = true\r\n            }\r\n            else{\r\n                tmp = points[i]\r\n            }\r\n            for (let c = 0;c < tmp.catArray.length; c ++){\r\n                let nowcat = tmp.catArray[c]\r\n                if(!pdict.hasOwnProperty(nowcat)){\r\n                    pdict[nowcat] = []\r\n                }\r\n                pdict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    preProcessEdges(edges, edict, filledges){\r\n        //console.log(\"preProcessEdges\")\r\n        //console.log(edges)\r\n        //console.log(this.edges)\r\n        for(let i = 0;i < edges.length; i ++){\r\n            let tmp\r\n            let catarr\r\n            if(edges[i].flag == true){\r\n                tmp = this.edges[edges[i].id]\r\n                tmp.flag = true\r\n                catarr = this.pointData[tmp.start].catArray\r\n                filledges.push(tmp)\r\n            }\r\n            else{\r\n                tmp = edges[i]\r\n                catarr = tmp.startpoint.catArray\r\n            }\r\n            for (let c = 0;c < catarr.length; c ++){\r\n                let nowcat = catarr[c]\r\n                if(!edict.hasOwnProperty(nowcat)){\r\n                    edict[nowcat] = []\r\n                }\r\n                edict[nowcat].push(tmp)\r\n            }\r\n        }\r\n    }\r\n\r\n    editReDraw(editPoints, editEdges, HpointData, Hedges){\r\n\r\n        let tmpedges = clone(this.edges)\r\n\r\n        this.pointData = HpointData\r\n        this.edges = Hedges\r\n        this.catPointDict = {}\r\n        this.catEdgeDict = {}\r\n        this.updateIdx = []\r\n        this.itemShape = this.pointData[0].shape\r\n\r\n        for (let i = 0; i < this.pointData.length; i++) {\r\n            this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n            this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n            this.pointData[i].id = i\r\n            this.pointData[i].cat = this.pointData[i].cat.toString()\r\n            let cats = this.pointData[i].cat.split(\",\")\r\n            let catarray = []\r\n            if (cats.length > 1) {\r\n                this.pointData[i].multicat = true\r\n                for (let c = 0; c < cats.length; c++) {\r\n                    catarray.push(cats[c])\r\n                }\r\n            } else {\r\n                this.pointData[i].multicat = false\r\n                catarray.push(this.pointData[i].cat)\r\n            }\r\n            this.pointData[i].catArray = catarray\r\n        }\r\n\r\n        this.centralizeData(false)\r\n\r\n        this.calEdgeLength()\r\n\r\n        this.calActiveRegion(false)\r\n\r\n        let updatePoints = {}\r\n        let updateEdges = {}\r\n        let filledges = []\r\n\r\n        this.preProcessPoints(editPoints, updatePoints)\r\n        this.preProcessEdges(editEdges, updateEdges, filledges)\r\n\r\n        this.calEnergyField_Part(updatePoints, updateEdges)\r\n\r\n        this.calFinalEnergeField_Part()\r\n\r\n        this.fillCrossingEdge_Part(filledges)\r\n\r\n        d3.selectAll(\"path\").remove()\r\n        //d3.selectAll(\"rect\").remove()\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        let that=this\r\n        function handleSvgClick(){\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n        //let that=this\r\n        //fetch('/data/'+pointDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n            //.then(res=>res.json())\r\n            //.then(data=>{\r\n        if(this.props.pointData && this.props.edges) {\r\n            if(this.props.edges.length > 0){\r\n                this.hasMST = true;\r\n            }\r\n            this.init();\r\n            if(this.hasMST == false){\r\n                let tmp = this.props.createMST()\r\n                this.pointData = tmp[0]\r\n                this.edges = tmp[1]\r\n                colors = tmp[2]\r\n                this.hasMST = true;\r\n            }\r\n            else{\r\n                this.pointData = this.props.pointData\r\n                this.edges = this.props.edges\r\n            }\r\n            //console.log(\"Draw Bubbles\")\r\n            //console.log(this.pointData)\r\n            //console.log(this.edges)\r\n            this.itemShape = this.pointData[0].shape\r\n            for (let i = 0; i < this.pointData.length; i++) {\r\n                this.pointData[i].x = parseFloat(this.pointData[i].x)\r\n                this.pointData[i].y = parseFloat(this.pointData[i].y)\r\n                this.pointData[i].id = i\r\n                this.pointData[i].cat = this.pointData[i].cat.toString()\r\n\r\n                if(this.pointData[i].hasOwnProperty(\"radius\")){\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].radius * this.pointData[i].radius * Math.PI)\r\n                }\r\n                else{\r\n                    minItemArea = Math.min(minItemArea, this.pointData[i].width * this.pointData[i].width)\r\n                }\r\n\r\n                let cats = this.pointData[i].cat.split(\",\")\r\n                let catarray = []\r\n                if (cats.length > 1) {\r\n                    this.pointData[i].multicat = true\r\n                    for (let c = 0; c < cats.length; c++) {\r\n                        catarray.push(cats[c])\r\n                    }\r\n                } else {\r\n                    this.pointData[i].multicat = false\r\n                    catarray.push(this.pointData[i].cat)\r\n                }\r\n                this.pointData[i].catArray = catarray\r\n            }\r\n\r\n            this.loadEdgeData()\r\n            if(this.props.handleCreated){\r\n                this.props.handleCreated()\r\n            }\r\n        }\r\n            //})\r\n\r\n    }\r\n\r\n\r\n\r\n    centralizeData(ViewFlag){\r\n        this.minX=Number.MAX_VALUE\r\n        this.minY=Number.MAX_VALUE\r\n        this.maxX=Number.MIN_VALUE\r\n        this.maxY=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            //this.pointData[i].isGroup=true;\r\n            if(itemEnergyShape==\"circle\"){\r\n                if(this.itemShape==\"rectangle\"){\r\n                    let r=Math.sqrt(Math.pow(this.pointData[i].width,2)+Math.pow(this.pointData[i].height,2))/2\r\n                    this.pointData[i].radius=r\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].radius\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].radius\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].radius\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].radius\r\n\r\n            }\r\n            else if(itemEnergyShape==\"rectangle\"){\r\n                if(this.itemShape==\"circle\"){\r\n                    this.pointData[i].width=this.pointData[i].radius*2\r\n                    this.pointData[i].height=this.pointData[i].radius*2\r\n                }\r\n                this.pointData[i].maxX=this.pointData[i].x+this.pointData[i].width/2\r\n                this.pointData[i].minX=this.pointData[i].x-this.pointData[i].width/2\r\n                this.pointData[i].maxY=this.pointData[i].y+this.pointData[i].height/2\r\n                this.pointData[i].minY=this.pointData[i].y-this.pointData[i].height/2\r\n\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,this.pointData[i].maxX)\r\n            this.maxY=Math.max(this.maxY,this.pointData[i].maxY)\r\n            this.minX=Math.min(this.minX,this.pointData[i].minX)\r\n            this.minY=Math.min(this.minY,this.pointData[i].minY)\r\n\r\n            for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                let nowcat=this.pointData[i].catArray[c]\r\n                if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                    this.catPointDict[nowcat]=[]\r\n                    this.catPointDict[nowcat].minX = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxX = Number.MIN_VALUE\r\n                    this.catPointDict[nowcat].minY = Number.MAX_VALUE\r\n                    this.catPointDict[nowcat].maxY = Number.MIN_VALUE\r\n                }\r\n                this.catPointDict[nowcat].push(this.pointData[i])\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,this.pointData[i].minX)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,this.pointData[i].maxX)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,this.pointData[i].minY)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,this.pointData[i].maxY)\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let catarr=this.pointData[start].catArray\r\n\r\n            let minx=Math.min(this.pointData[start].x,this.pointData[end].x)\r\n            let miny=Math.min(this.pointData[start].y,this.pointData[end].y)\r\n            let maxx=Math.max(this.pointData[start].x,this.pointData[end].x)\r\n            let maxy=Math.max(this.pointData[start].y,this.pointData[end].y)\r\n\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                for (let p=0;p<vpoints.length;p++){\r\n                    let x=vpoints[p][0]\r\n                    let y=vpoints[p][1]\r\n                    minx=Math.min(minx,x)\r\n                    miny=Math.min(miny,y)\r\n                    maxx=Math.max(maxx,x)\r\n                    maxy=Math.max(maxy,y)\r\n                }\r\n            }\r\n\r\n            this.maxX=Math.max(this.maxX,maxx)\r\n            this.maxY=Math.max(this.maxY,maxy)\r\n            this.minX=Math.min(this.minX,minx)\r\n            this.minY=Math.min(this.minY,miny)\r\n\r\n            this.edges[i].x=minx\r\n            this.edges[i].y=miny\r\n            this.edges[i].width=maxx-minx\r\n            this.edges[i].height=maxy-miny\r\n\r\n            //this.edges[i].isGroup=true;\r\n\r\n            for (let c=0;c<catarr.length;c++){\r\n                // let catarr=this.pointData[this.edges[i].start].catArray\r\n                let nowcat=catarr[c]\r\n                this.catPointDict[nowcat].minX = Math.min(this.catPointDict[nowcat].minX,minx)\r\n                this.catPointDict[nowcat].maxX = Math.max(this.catPointDict[nowcat].maxX,maxx)\r\n                this.catPointDict[nowcat].minY = Math.min(this.catPointDict[nowcat].minY,miny)\r\n                this.catPointDict[nowcat].maxY = Math.max(this.catPointDict[nowcat].maxY,maxy)\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat=this.edges[i].cat\r\n            if(!this.catEdgeDict.hasOwnProperty(cat)){\r\n                this.catEdgeDict[cat]=[]\r\n            }\r\n            this.catEdgeDict[cat].push(this.edges[i])\r\n\r\n        }\r\n        //console.log(this.catEdgeDict)\r\n\r\n        if(ViewFlag){\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n////\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"viewBox\",(this.minX-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.minY-Math.max(nodeR1,edgeR1)-buffer-10)+\" \"+(this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20)+\" \"+(this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20))\r\n//\r\n            d3.selectAll('g').attr(\"transform\",\"\");\r\n        }\r\n\r\n\r\n        if(hasChangeView == false){\r\n            offsetX = this.minX-Math.max(nodeR1,edgeR1)-buffer-10\r\n            offsetY = this.minY-Math.max(nodeR1,edgeR1)-buffer-10\r\n            viewWidth = this.maxX-this.minX+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            viewHeight = this.maxY-this.minY+Math.max(nodeR1,edgeR1)*2+buffer*2+20\r\n            hasChangeView = true\r\n        }\r\n\r\n    }\r\n\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        // d3.select(\"svg\").selectAll(\"*\").remove();\r\n        svg = d3.select('svg');\r\n\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            d3.select(this)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n\r\n        let items=[]\r\n\r\n\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"circle\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    \"id\":items[i].getAttribute(\"index\"),\r\n                    \"bbox\":items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                g.append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"catefory\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                    })\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    // .call(drag)\r\n            }\r\n            items=document.getElementsByTagName(\"rect\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    isInEdgeRange(x,y,start,end){\r\n        let x1=start.x\r\n        let y1=start.y\r\n        let x2=end.x\r\n        let y2=end.y\r\n\r\n        let cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n        // if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n        if (cross <= 0) return false\r\n\r\n        let d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        // if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));\r\n        if (cross >= d2) return false\r\n\r\n        return true\r\n    }\r\n\r\n    calEdgeControlPoints(){\r\n        function sortArr(a,b){\r\n            return a.avgdis-b.avgdis\r\n        }\r\n        this.edgeControlPoints=[]\r\n        let tempcontrolpoints=[]\r\n        for(let i=0;i<this.edges.length;i++){\r\n            this.edgeControlPoints.push([])\r\n            tempcontrolpoints.push([])\r\n        }\r\n        for (var k in control_points){\r\n            for (let n=0;n<control_points[k].length;n++){\r\n                let controlpoints=control_points[k][n]\r\n                for(let i=0;i<controlpoints.length;i++){\r\n                    let minDis=Number.MAX_VALUE\r\n                    let minindex=-1\r\n                    for(let e=0;e<this.edges.length;e++){\r\n                        let edge=this.edges[e]\r\n                        if(edge.cat!=k){\r\n                            continue\r\n                        }\r\n                        let start=this.pointData[edge.start]\r\n                        let end=this.pointData[edge.end]\r\n                        let dis=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n                        if(dis>0){\r\n                            if(dis<minDis){\r\n                                minDis=dis\r\n                                minindex=e\r\n                            }\r\n                        }\r\n                    }\r\n                    if(minindex>=0){\r\n                        tempcontrolpoints[minindex].push({\r\n                            order:n,\r\n                            index:i,\r\n                            dis:minDis\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        // console.log(tempcontrolpoints[153])\r\n\r\n        for(let i=0;i<tempcontrolpoints.length;i++){\r\n            let iscontinue=false\r\n            let temppoints=[]\r\n            for(let j=1;j<tempcontrolpoints[i].length;j++){\r\n                let lastindex=tempcontrolpoints[i][j-1].index\r\n                let index=tempcontrolpoints[i][j].index\r\n                if(index-lastindex==1){\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                    else{\r\n                        iscontinue=true\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                    }\r\n                }\r\n                else{\r\n                    if(iscontinue){\r\n                        temppoints.push(tempcontrolpoints[i][j-1])\r\n                        iscontinue=false\r\n\r\n                        this.edgeControlPoints[i].push(temppoints)\r\n\r\n                        temppoints=[]\r\n                    }\r\n                    else{\r\n\r\n                    }\r\n                }\r\n            }\r\n            if(iscontinue){\r\n                temppoints.push(tempcontrolpoints[i][tempcontrolpoints[i].length-1])\r\n                this.edgeControlPoints[i].push(temppoints)\r\n            }\r\n        }\r\n\r\n        for (let i=0;i<this.edgeControlPoints.length;i++){\r\n            if(this.edgeControlPoints[i].length>2){\r\n                for (let j=0;j<this.edgeControlPoints[i].length;j++){\r\n                    let avgdis=0\r\n                    for (let p=0;p<this.edgeControlPoints[i][j].length;p++){\r\n                        avgdis+=this.edgeControlPoints[i][j][p].dis\r\n                    }\r\n                    avgdis=avgdis/this.edgeControlPoints[i][j].length\r\n                    this.edgeControlPoints[i][j].avgdis=avgdis\r\n                }\r\n                this.edgeControlPoints[i].sort(sortArr)\r\n                let tmp=[this.edgeControlPoints[i][0],this.edgeControlPoints[i][1]]\r\n                this.edgeControlPoints[i]=tmp\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    changeEdgeWidth(index,width){\r\n        let dw=width-defaultEdgeWidth\r\n        dw=dw*1.5\r\n        // console.log(width,dw)\r\n        //recalculate energy field\r\n/*        let i=index\r\n        let edges=this.edges\r\n        let k=edges[index].cat\r\n        let controlpoints=control_points[k]\r\n        let start=this.pointData[edges[index].start]\r\n        let end=this.pointData[edges[index].end]\r\n        let distances=[]\r\n        for (let i=0;i<controlpoints.length;i++){\r\n            let distoedge=PointToSegDist(controlpoints[i][0],controlpoints[i][1],start.x,start.y,end.x,end.y)\r\n            distances.push(distoedge)\r\n        }\r\n\r\n        let iscontinue=false\r\n        let temppoints={\r\n            points:[],\r\n            dis:0\r\n        }\r\n        let potentialPoints=[]\r\n        for(let i=0;i<distances.length;i++){\r\n            if(distances[i]>=0){\r\n                if(iscontinue){\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n                else{\r\n                    iscontinue=true\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    temppoints.points.push(i)\r\n                    temppoints.dis+=distances[i]\r\n                }\r\n            }\r\n            else{\r\n                if(iscontinue){\r\n                    if(temppoints.points.length>1){\r\n                        temppoints.dis=temppoints.dis/temppoints.points.length\r\n                        potentialPoints.push(temppoints)\r\n                    }\r\n                    temppoints={\r\n                        points:[],\r\n                        dis:0\r\n                    }\r\n                    iscontinue=false\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n        }\r\n        for(let i=0;i<potentialPoints.length;i++){\r\n            for(let p=0;p<potentialPoints[i].points.length;p++){\r\n                let point=controlpoints[potentialPoints[i].points[p]]\r\n                drawRect(point[0],point[1],1,1,\"red\")\r\n            }\r\n        }\r\n        console.log(potentialPoints)*/\r\n        let k=this.edges[index].cat\r\n        let start=this.pointData[this.edges[index].start]\r\n        let end=this.pointData[this.edges[index].end]\r\n        let dir=[end.x-start.x,end.y-start.y]\r\n\r\n        let norm=[-dir[1],dir[0]]\r\n        norm=normalizeVec(norm)\r\n\r\n        // drawLine([start.x,start.y],[start.x+50*norm[0],start.y+50*norm[1]],\"red\")\r\n\r\n        //console.log(\"changEdgeWidth:\")\r\n        //console.log(this.edgeControlPoints)\r\n\r\n        let controlpoints=this.edgeControlPoints[index]\r\n            let firstOutline=controlpoints[0]\r\n            let secondOutline=controlpoints[1]\r\n            let p1=control_points[k][firstOutline[0].order][firstOutline[0].index]\r\n            let vec1=[p1[0]-start.x,p1[1]-start.y]\r\n            let dot=vec1[0]*norm[0]+vec1[1]*norm[1]\r\n\r\n            let firstMidpoint=firstOutline.length/2\r\n            let secondMidpoint=secondOutline.length/2\r\n\r\n            if(dot>0){\r\n                //same direction with firstOutline\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n\r\n            }\r\n            else{\r\n                let dx=dw*norm[0]\r\n                let dy=dw*norm[1]\r\n                for (let p=0;p<firstOutline.length;p++){\r\n                    // if(p==0||p==firstOutline.length-1)\r\n                    //     continue\r\n                    let index=firstOutline[p].index\r\n                    let order=firstOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]-dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]-dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n                for (let p=0;p<secondOutline.length;p++){\r\n                    // if(p==0||p==secondOutline.length-1)\r\n                    //     continue\r\n                    let index=secondOutline[p].index\r\n                    let order=secondOutline[p].order\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    control_points[k][order][index][0]=initialControlPoints[k][order][index][0]+dx\r\n                    control_points[k][order][index][1]=initialControlPoints[k][order][index][1]+dy\r\n                    // console.log(initialControlPoints[k][order][index][0])\r\n                    // drawRect(control_points[k][order][index][0],control_points[k][order][index][1],1,1,\"red\")\r\n\r\n                }\r\n            }\r\n\r\n            //apply changes to energy field\r\n\r\n\r\n\r\n        let drawPathData=\"\";\r\n        for(let j = 0;j < control_points[k].length; j ++){\r\n            drawPathData += lineFunction(control_points[k][j]);\r\n        }\r\n        this.reDraw(k,this,drawPathData)\r\n\r\n\r\n    }\r\n\r\n    handleEdgeWidth(event, element){\r\n        event.stopPropagation()\r\n        let that = this\r\n        that.selectedEdge=parseInt(d3.select(element).attr(\"index\"))\r\n        that.setState({\r\n            hasSelectEdge:true\r\n        })\r\n        d3.select(\"svg\").selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(element).attr(\"index\"))==that.selectedEdge\r\n            })\r\n            .attr(\"stroke\",\"red\")\r\n            .attr(\"opacity\",1)\r\n    }\r\n\r\n    drawEdges(){\r\n        d3.select(\"#mainsvg\").selectAll(\"line\").remove()\r\n        let that=this\r\n\r\n        function handleClick(event){\r\n            event.stopPropagation()\r\n            that.selectedEdge=parseInt(d3.select(this).attr(\"index\"))\r\n            that.setState({\r\n                hasSelectEdge:true\r\n            })\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",1)\r\n        }\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let index=i\r\n            if(this.edges[i].virtrual){\r\n                let vpoints=this.edges[i].virtrualNodes\r\n                let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                let vend\r\n                for (let v=0;v<vpoints.length;v++){\r\n                    vend=vpoints[v]\r\n                    g.append(\"line\")\r\n                        .attr(\"x1\",vstart[0])\r\n                        .attr(\"y1\",vstart[1])\r\n                        .attr(\"x2\",vend[0])\r\n                        .attr(\"y2\",vend[1])\r\n                        .attr(\"index\",index)\r\n                        .attr(\"stroke-width\",3)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"opacity\",0)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",1)\r\n                        })\r\n                        .on(\"mouseout\",function(d,i){\r\n                            if(that.state.hasSelectEdge){\r\n                                return\r\n                            }\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.select(\"svg\")\r\n                                .selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"opacity\",0)\r\n                        })\r\n                        .on(\"click\",handleClick)\r\n                    vstart=vend\r\n                }\r\n                vend=[this.pointData[end].x,this.pointData[end].y]\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n            else{\r\n                g.append(\"line\")\r\n                    .attr(\"x1\",this.pointData[start].x)\r\n                    .attr(\"y1\",this.pointData[start].y)\r\n                    .attr(\"x2\",this.pointData[end].x)\r\n                    .attr(\"y2\",this.pointData[end].y)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"stroke-width\",3)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"opacity\",0)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(d,i){\r\n                        if(that.state.hasSelectEdge){\r\n                            return\r\n                        }\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(\"svg\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0)\r\n                    })\r\n                    .on(\"click\",handleClick)\r\n\r\n            }\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n    }\r\n\r\n    calEdgeLength(){\r\n        let minlength=Number.MAX_VALUE\r\n        let maxlength=Number.MIN_VALUE\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let startpoint=this.pointData[this.edges[i].start]\r\n            let endpoint=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vpoint=this.edges[i].virtrualNodes\r\n                let nowp\r\n                let nextp\r\n                let edgelength=0\r\n                nowp=[startpoint.x,startpoint.y]\r\n                for (let i=0;i<vpoint.length;i++){\r\n                    nextp=vpoint[i]\r\n                    edgelength+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                    nowp=nextp\r\n                }\r\n                edgelength+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let edgelength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(edgelength>maxlength){\r\n                    maxlength=edgelength\r\n                }\r\n                if(edgelength<minlength){\r\n                    minlength=edgelength\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n        this.maxEdgeLength=maxlength\r\n        this.minEdgeLength=minlength\r\n\r\n    }\r\n\r\n    componentWillUpdate(nextProps, nextState, nextContext) {\r\n    }\r\n\r\n    findOutLine(){\r\n        for (var k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n        intervals=[0.01]\r\n\r\n        // total field to active region\r\n        let fieldData = {}\r\n        for(var k in this.catEnergyField){\r\n            fieldData[k] = []\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let i = 0\r\n            for(let y = startY; y < endY; y ++){\r\n                fieldData[k].push([])\r\n                for(let x = startX; x < endX; x ++){\r\n                    fieldData[k][i].push(this.catEnergyField[k].finalField[y][x])\r\n                }\r\n                i ++\r\n            }\r\n        }\r\n\r\n        let isoDict=this.calISOLine(intervals, fieldData)\r\n\r\n        //console.log(isoDict)\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {};\r\n\r\n\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].boundingX\r\n            let dy=this.catEnergyField[k].boundingY\r\n            let prelength = 0\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                let sk = skipPoint\r\n                if(isoDict[k][i].length < 30){\r\n                    //continue;\r\n                }\r\n                if(isoDict[k][i].length < 50){\r\n                    //sk = 1\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n\r\n                    if(prelength==0){\r\n                        tmp_polygon[k].selectidx = []\r\n                        control_points[k] = []\r\n                    }\r\n\r\n                    tmp_polygon[k].selectidx.push(tmp_polygon[k].length - 1)\r\n\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += sk){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n\r\n                    let curlen = control_points[k].length\r\n                    control_points[k][curlen] = [];\r\n                    control_points[k][curlen] = polygon;\r\n\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                    prelength ++\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        //console.log(tmp_polygon)\r\n\r\n        for(let k in this.catEnergyField){\r\n            this.updatedEnergyPoints[k] = []\r\n        }\r\n\r\n\r\n        //remove_Polys = {}\r\n\r\n        for(var k in isoDict){\r\n            //let dx=this.catEnergyField[k].boundingX\r\n            //let dy=this.catEnergyField[k].boundingY\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                let isthis = false\r\n                for(let j = 0;j < sidx.length; j ++){\r\n                    if(i == sidx[j]){\r\n                        isthis = true\r\n                        break\r\n                    }\r\n                }\r\n                if(isthis){\r\n                    continue\r\n                }\r\n                let flag = true;\r\n                for(let p = 0; p < sidx.length; p ++){\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx[p]]);\r\n                        if(flag == false){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n\r\n                    if(AreaCal(tmp_polygon[k][i]) < minItemArea){\r\n                        continue\r\n                    }\r\n\r\n                    let st_idx = 0\r\n                    let pt_len = tmp_polygon[k][i].length\r\n                    let j_pt = [-1,-1]\r\n                    while(st_idx < pt_len){\r\n                        let idx1 = (st_idx - 1 + pt_len) % pt_len\r\n                        let idx2 = (st_idx + 1) % pt_len\r\n                        let ve1 = [tmp_polygon[k][i][idx1][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx1][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve2 = [tmp_polygon[k][i][idx2][0] - tmp_polygon[k][i][st_idx][0], tmp_polygon[k][i][idx2][1] - tmp_polygon[k][i][st_idx][1]]\r\n                        let ve3 = [ve1[0] + ve2[0], ve1[1] + ve2[1]]\r\n                        let ve3_len = Math.sqrt(ve3[0] * ve3[0] + ve3[1] * ve3[1])\r\n                        if(ve3_len != 0){\r\n                            ve3 = [ve3[0] / ve3_len, ve3[1] / ve3_len]\r\n                        }\r\n                        let test_pt = [tmp_polygon[k][i][st_idx][0] + 2 * ve3[0], tmp_polygon[k][i][st_idx][1] + 2 * ve3[1]]\r\n                        if(IsoInsideTest(test_pt, tmp_polygon[k][i])){\r\n                            j_pt = [test_pt[0], test_pt[1]]\r\n                            break;\r\n                        }\r\n                        st_idx ++\r\n                    }\r\n\r\n                    let is_use_inner = true\r\n\r\n                    if(j_pt[0] != -1 && j_pt[1] != -1){\r\n                        //if(k==\"2\"){\r\n                        //  g.append(\"circle\")\r\n                        //      .attr(\"cx\",j_pt[0])\r\n                        //      .attr(\"cy\",j_pt[1])\r\n                        //      .attr(\"r\",3)\r\n                        //      .attr(\"fill\",\"black\")\r\n//\r\n                        //}\r\n\r\n                        let j_y = parseInt((j_pt[1] -this.catEnergyField[k].y) / pixelGroup)\r\n                        let j_x = parseInt((j_pt[0] -this.catEnergyField[k].x) / pixelGroup)\r\n                        //if(k==\"2\"){\r\n                        //    console.log(\"inner outline!\")\r\n                        //    console.log(\"(\" + j_pt[0] + \", \" + j_pt[1] + \")\")\r\n                        //    console.log(this.catEnergyField[\"2\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"2\"].edgeIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].field[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].finalField[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].barrierMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].pointIndexMap[j_y][j_x])\r\n                        //    console.log(this.catEnergyField[\"3\"].edgeIndexMap[j_y][j_x])\r\n                        //}\r\n                        //console.log(\"inner outline!\")\r\n                        //console.log(this.catEnergyField[k].field[j_y][j_x])\r\n                        //console.log(this.catEnergyField[k].finalField[j_y][j_x])\r\n                        if(this.catEnergyField[k].finalField[j_y][j_x] > 0.01){\r\n                            is_use_inner = false\r\n                        }\r\n                    }\r\n\r\n                    if(!is_use_inner){\r\n                        continue\r\n                    }\r\n\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n                /*\r\n                else{\r\n                    recal = true\r\n                    if(!remove_Polys.hasOwnProperty(k)){\r\n                        remove_Polys[k] = []\r\n                    }\r\n                    let tmp_polygon = []\r\n                    let sub_polygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j ++){\r\n                        let realx = isoDict[k][i][j][0]*pixelGroup + dx\r\n                        let realy = isoDict[k][i][j][1]*pixelGroup + dy\r\n                        sub_polygon.push([realx, realy])\r\n                        let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                        let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n                        tmp_polygon.push([x, y])\r\n                    }\r\n                    remove_Polys[k].push(tmp_polygon)\r\n                    this.fillPolygon(sub_polygon, k, 0, true)\r\n                }\r\n\r\n                 */\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    calOutLine(){\r\n\r\n        //if(recal && recalNum == 0){\r\n        //    recalNum += 1\r\n        //    for(let k in remove_Polys){\r\n        //        this.recalFinalEnergeField(k)\r\n        //    }\r\n        //}\r\n//\r\n        //if(this.firstFlag){\r\n        //    this.firstFlag = false\r\n        //    this.createGapInBoundary()\r\n        //}\r\n\r\n\r\n        //this.findOutLine()\r\n\r\n        let path_Info = {}\r\n\r\n        for(var k in this.catEnergyField){\r\n            path_Info[k] = []\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                path_Info[k].push(lineFunction(control_points[k][i]))\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n\r\n        //for(let k in this.catEnergyField){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        for (var k in control_points){\r\n            initialControlPoints[k]=[]\r\n            for (let i=0;i<control_points[k].length;i++){\r\n                initialControlPoints[k][i]=[]\r\n                for (let j=0;j<control_points[k][i].length;j++){\r\n                    initialControlPoints[k][i].push([])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][0])\r\n                    initialControlPoints[k][i][j].push(control_points[k][i][j][1])\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    loadEdgeData(){\r\n        //let that=this\r\n        //fetch('/data/'+edgeDataName,{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n                //this.edges=data\r\n\r\n                this.centralizeData(true)\r\n\r\n\r\n                // this.drawEdges()\r\n                this.calEdgeLength()\r\n                this.calActiveRegion(true)\r\n\r\n\r\n                this.calEnergyField()\r\n                //this.calFinalEnergeFieldV2()\r\n                this.calFinalEnergeField()\r\n                this.fillCrossingEdge()\r\n                this.createGapInBoundary()\r\n\r\n                //console.time(\"smooth\")\r\n                // this.smoothEnergyField()\r\n                //console.timeEnd(\"smooth\")\r\n\r\n                // for(let k in this.catPointDict){\r\n                //    this.drawEnergyField(k);\r\n                // }\r\n\r\n\r\n\r\n                d3.select(\"svg\").selectAll(\"*\").remove()\r\n                g = d3.select('svg').append(\"g\")\r\n\r\n                //g.append(\"image\")\r\n                //    .attr(\"x\",-42)\r\n                //    .attr(\"y\",-42)\r\n                //    .attr(\"width\",995)\r\n                //    .attr(\"height\",1350)\r\n                //    .attr(\"xlink:href\",\"/data/background/Manhatton.jpg\")\r\n\r\n                recal = false\r\n                recalNum = 0\r\n\r\n                this.findOutLine()\r\n                this.calOutLine()\r\n\r\n                /*\r\n\r\n                // re-cal the energy field for inner outline\r\n                for (var k in this.catEnergyField){\r\n                    this.catEnergyField[k].tfinalField = []\r\n                    for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                        this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                        for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                            let val = this.catEnergyField[k].finalField[y][x];\r\n                            if(IsoInsideTest([x, y], polygontest[k])){\r\n                                //console.log(\"test!!\")\r\n                                if(val > 0){\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                                }\r\n                                else{\r\n                                    this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                                }\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].finalField[y][x] = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                let isoLineDict={}\r\n                for (var k in this.catEnergyField){\r\n                    var isoLines = [];\r\n                    isoLines=MarchingSquaresJS\r\n                        .isoLines(this.catEnergyField[k].tfinalField,\r\n                            intervals,\r\n                            {\r\n                                polygons: false,\r\n                                linearRing: false,\r\n                                noFrame:true\r\n                            }\r\n                        )\r\n                    isoLineDict[k]=isoLines[0]\r\n                }\r\n\r\n                for (var k in isoLineDict){\r\n                    //console.log(isoLineDict[k])\r\n                    let dx=this.catEnergyField[k].x\r\n                    let dy=this.catEnergyField[k].y\r\n                    for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                        if(isoLineDict[k][i].length < 30){\r\n                            continue;\r\n                        }\r\n                        let curlen = control_points[k].length;\r\n                        control_points[k][curlen] = [];\r\n                        for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                            control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                        }\r\n                        let meandis = 0;\r\n                        let sz = control_points[k][curlen].length;\r\n                        for(let j = 0; j < sz; j ++){\r\n                            meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                                control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                        }\r\n                        meandis /= sz\r\n                        control_points[k][curlen].meandis = meandis;\r\n                    }\r\n                    //this.drawEnergyField(k);\r\n                }\r\n\r\n                 */\r\n\r\n                //this.drawEnergyField(\"2\")\r\n                //this.drawEnergyField(\"3\")\r\n\r\n                this.calEdgeControlPoints()\r\n\r\n\r\n\r\n                this.drawEdges()\r\n                this.drawPointData()\r\n\r\n                //for(let k in this.catEnergyField){\r\n                //    this.drawEnergyField(k)\r\n                //}\r\n\r\n                let that=this\r\n                function handleSvgClick(){\r\n                    d3.select(\"svg\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                        .attr(\"opacity\",0)\r\n                    that.selectedEdge=-1\r\n                    that.setState({\r\n                        hasSelectEdge:false,\r\n                        edgeWidth:defaultEdgeWidth\r\n                    })\r\n                }\r\n                        d3.select(\"svg\")\r\n                            .on(\"click\",handleSvgClick)\r\n\r\n            //})\r\n    }\r\n\r\n    afterEditReDraw(){\r\n\r\n        this.pointData = this.props.pointData\r\n\r\n        this.edges = this.props.edges\r\n\r\n        this.drawEdges()\r\n\r\n        this.drawPointData()\r\n\r\n        let that=this\r\n\r\n        function handleSvgClick(){\r\n            d3.select(\"svg\").selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==that.selectedEdge\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"opacity\",0)\r\n            that.selectedEdge=-1\r\n            that.setState({\r\n                hasSelectEdge:false,\r\n                edgeWidth:defaultEdgeWidth\r\n            })\r\n        }\r\n        d3.select(\"svg\")\r\n            .on(\"click\",handleSvgClick)\r\n\r\n    }\r\n\r\n    calActiveRegion(flag){\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(flag || !this.catEnergyField.hasOwnProperty(k)){\r\n                this.catEnergyField[k]={}\r\n                //console.log(\"calActiveRegion:\")\r\n                //console.log(k)\r\n            }\r\n\r\n            let maxx=this.catPointDict[k].maxX\r\n            let minx=this.catPointDict[k].minX\r\n            let maxy=this.catPointDict[k].maxY\r\n            let miny=this.catPointDict[k].minY\r\n\r\n            //console.log(\"active region: \")\r\n            //console.log([maxx, minx, maxy, miny])\r\n\r\n            this.catEnergyField[k].boundingX=minx-Math.max(nodeR1,edgeR1)-buffer\r\n            this.catEnergyField[k].boundingY=miny-Math.max(nodeR1,edgeR1)-buffer\r\n\r\n            this.catEnergyField[k].boundingWidth=Math.ceil((maxx-minx+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n            this.catEnergyField[k].boundingHeight=Math.ceil((maxy-miny+Math.max(nodeR1,edgeR1)*2+buffer*2)/pixelGroup)\r\n\r\n            if(flag || !this.catEnergyField[k].hasOwnProperty(\"field\")){\r\n\r\n                let centerX = this.catEnergyField[k].boundingX + 0.5 * this.catEnergyField[k].boundingWidth\r\n                let centerY = this.catEnergyField[k].boundingY + 0.5 * this.catEnergyField[k].boundingHeight\r\n\r\n                this.catEnergyField[k].x = parseInt((centerX - 0.5 * svgwidth))\r\n                this.catEnergyField[k].y = parseInt((centerY - 0.5 * svgheight))\r\n\r\n                this.catEnergyField[k].width = parseInt(svgwidth / pixelGroup)\r\n                this.catEnergyField[k].height = parseInt(svgheight / pixelGroup)\r\n\r\n                this.catEnergyField[k].field=[]\r\n                this.catEnergyField[k].barrierMap=[]\r\n                for (let i=0;i<svgheight;i++){\r\n                    this.catEnergyField[k].field.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].barrierMap.push(new Array(svgwidth).fill(0))\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.hasBubbles = true\r\n\r\n    }\r\n\r\n    calDistanceToItem(x,y,item){\r\n        //TODO: Rectangle items\r\n        //inside is 0\r\n        if(itemEnergyShape==\"circle\"){\r\n            let dis=calDistance(x,y,item.x,item.y)\r\n            if(dis<item.radius){\r\n                return 0\r\n            }\r\n            else{\r\n                return dis-item.radius\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    getPointEdgeDistance(lx1, ly1, lx2, ly2, x, y) {\r\n        var x1 = lx1;\r\n        var y1 = ly1;\r\n        var x2 = lx2 - x1;\r\n        var y2 = ly2 - y1;\r\n        var px = x - x1;\r\n        var py = y - y1;\r\n        var dotprod = px * x2 + py * y2;\r\n        var projlenSq;\r\n        if(dotprod <= 0) {\r\n            projlenSq = 0;\r\n        } else {\r\n            px = x2 - px;\r\n            py = y2 - py;\r\n            dotprod = px * x2 + py * y2;\r\n            if(dotprod <= 0) {\r\n                projlenSq = 0;\r\n            } else {\r\n                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\r\n            }\r\n        }\r\n        var lenSq = px * px + py * py - projlenSq;\r\n        if(lenSq < 0) {\r\n            lenSq = 0;\r\n        }\r\n        return Math.sqrt(lenSq);\r\n    }\r\n\r\n    calDistanceToEdgeV2(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint, endpoint\r\n        if(edge.flag == false){\r\n            startpoint = edge.startpoint\r\n            endpoint = edge.endpoint\r\n        }\r\n        else{\r\n            startpoint=this.pointData[edge.start]\r\n            endpoint=this.pointData[edge.end]\r\n        }\r\n        if(edge.virtrual && edge.virtrualNodes.length > 0){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calDistanceToEdge(x,y,edge){\r\n        //return the distance to the edge and distance to two nodes\r\n        let startpoint=this.pointData[edge.start]\r\n        let endpoint=this.pointData[edge.end]\r\n        if(edge.virtrual){\r\n            let vpoint=edge.virtrualNodes\r\n            let nowp=[startpoint.x,startpoint.y]\r\n            let nextp\r\n            let mindis=Number.MAX_VALUE\r\n            let distancetostartnode=0\r\n            let distancetoendnode=0\r\n            let distancetoedge=0\r\n            let totaldistance=0\r\n            let minindex=-1\r\n            for (let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                let dis=this.getPointEdgeDistance(nowp[0],nowp[1],nextp[0],nextp[1],x,y)\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                    minindex=i\r\n                }\r\n                nowp=nextp\r\n            }\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<minindex;i++){\r\n                nextp=vpoint[i]\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            if(minindex==0){\r\n                nowp=[startpoint.x,startpoint.y]\r\n                nextp=vpoint[0]\r\n            }\r\n            else{\r\n                nowp=vpoint[minindex-1]\r\n                nextp=vpoint[minindex]\r\n            }\r\n\r\n            let enddis=this.getPointEdgeDistance(endpoint.x,endpoint.y,vpoint[vpoint.length-1][0],vpoint[vpoint.length-1][1],x,y)\r\n            if(enddis<mindis){\r\n                mindis=enddis\r\n                distancetostartnode+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n                nextp=[endpoint.x,endpoint.y]\r\n            }\r\n\r\n            distancetoedge=mindis\r\n\r\n            let sp=[x-nowp[0],y-nowp[1]]\r\n            let se=[nextp[0]-nowp[0],nextp[1]-nowp[1]]\r\n            let es=[nowp[0]-nextp[0],nowp[1]-nextp[1]]\r\n            let ep=[x-nextp[0],x-nextp[1]]\r\n            let selength=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n            let n=sesp/selength\r\n\r\n            // if(sesp>0&&esep>0){\r\n            distancetostartnode+=n\r\n            // }\r\n\r\n\r\n            nowp=[startpoint.x,startpoint.y]\r\n            for(let i=0;i<vpoint.length;i++){\r\n                nextp=vpoint[i]\r\n                totaldistance+=calDistance(nowp[0],nowp[1],nextp[0],nextp[1])\r\n                nowp=nextp\r\n            }\r\n            totaldistance+=calDistance(nowp[0],nowp[1],endpoint.x,endpoint.y)\r\n            distancetoendnode=totaldistance-distancetostartnode\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n                // drawRect(x,y,5,5,\"red\")\r\n                // console.log()\r\n            }\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n\r\n        }\r\n        else{\r\n            let distancetoedge=this.getPointEdgeDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y,x,y)\r\n            let sp=[x-startpoint.x,y-startpoint.y]\r\n            let se=[endpoint.x-startpoint.x,endpoint.y-startpoint.y]\r\n            let es=[startpoint.x-endpoint.x,startpoint.y-endpoint.y]\r\n            let ep=[x-endpoint.x,y-endpoint.y]\r\n\r\n            let selength=calDistance(startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n            let sesp=se[0]*sp[0]+se[1]*sp[1]\r\n            let esep=es[0]*ep[0]+es[1]*ep[1]\r\n\r\n\r\n            let n=sesp/selength\r\n\r\n            // let dir=[se[0]/selength*n,se[1]/selength*n]\r\n            // let newp=[se[0]+dir[0],se[1]+dir[1]]\r\n\r\n\r\n            let distancetostartnode=n\r\n            let distancetoendnode=selength-n\r\n            let distancetonode=Math.min(distancetostartnode,distancetoendnode)\r\n            if(distancetonode<0){\r\n                distancetonode=-1\r\n\r\n            }\r\n\r\n            let totaldistance=selength\r\n\r\n            return [distancetoedge,distancetonode,totaldistance]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    isRectIntersects (rect1,rect2) {\r\n        if(rect1.width <= 0 || rect1.height <= 0 || rect2.width <= 0 || rect2.height <= 0) return false;\r\n        return (rect2.maxX > rect1.minX &&\r\n            rect2.maxY > rect1.minY &&\r\n            rect2.minX < rect1.maxX &&\r\n            rect2.minY < rect1.maxY);\r\n    };\r\n\r\n    isThisCat(point,cat){\r\n        let catarr=point.catArray\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    LabelGroupElement(){\r\n        let maxpdis = nodeR1 * 2\r\n        for(let k1 in this.catPointDict){\r\n\r\n            // cal for points\r\n            for(let i = 0;i < this.catPointDict[k1].length; i ++){\r\n                if(this.catPointDict[k1][i].isGroup==false){\r\n                    continue;\r\n                }\r\n                let isgroup = true;\r\n                let x1 = this.catPointDict[k1][i].x;\r\n                let y1 = this.catPointDict[k1][i].y;\r\n                for(let k2 in this.catPointDict){\r\n//\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n//\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(calDistance(x1,y1,x2,y2) < maxpdis + this.catPointDict[k2][j].radius + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n//\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    // cal edge\r\n                    if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                        continue;\r\n                    }\r\n                    for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                        if(this.calDistanceToEdge(x1,y1,this.catEdgeDict[k2][j])[0] < maxpdis + this.catPointDict[k1][i].radius){\r\n                            isgroup = false;\r\n                            this.catEdgeDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n                }\r\n                this.catPointDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n            // cal for edges\r\n            if(!this.catEdgeDict.hasOwnProperty(k1)){\r\n                continue;\r\n            }\r\n            for(let i = 0;i < this.catEdgeDict[k1].length;i ++){\r\n                let s1 = this.pointData[this.catEdgeDict[k1][i].start];\r\n                let e1 = this.pointData[this.catEdgeDict[k1][i].end];\r\n                if(this.catEdgeDict[k1][i].isGroup == false){\r\n                    continue;\r\n                }\r\n                let isgroup = true\r\n                for(let k2 in this.catPointDict){\r\n                    if(k1==k2){\r\n                        continue;\r\n                    }\r\n                    // cal node\r\n                    for(let j = 0;j < this.catPointDict[k2].length; j ++){\r\n                        let x2 = this.catPointDict[k2][j].x;\r\n                        let y2 = this.catPointDict[k2][j].y;\r\n                        if(this.calDistanceToEdge(x2,y2,this.catEdgeDict[k1][i])[0] < maxpdis + this.catPointDict[k2][j].radius){\r\n                            isgroup = false;\r\n                            this.catPointDict[k2][j].isGroup = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(isgroup==false){\r\n                        break;\r\n                    }\r\n//\r\n                    //// cal edge\r\n                    //if(!this.catEdgeDict.hasOwnProperty(k2)){\r\n                    //    continue;\r\n                    //}\r\n                    //for(let j = 0;j < this.catEdgeDict[k2].length; j ++ ){\r\n                    //    let s2 = this.pointData[this.catEdgeDict[k2][j].start];\r\n                    //    let e2 = this.pointData[this.catEdgeDict[k2][j].end];\r\n                    //    if(this.checkEdgeCrossing(s1,e1,s2,e2)[0]){\r\n                    //        isgroup = false;\r\n                    //        this.catEdgeDict[k2][j].isGroup = false;\r\n                    //        break;\r\n                    //    }\r\n                    //}\r\n                    //if(isgroup==false){\r\n                    //    break;\r\n                    //}\r\n//\r\n                }\r\n                this.catEdgeDict[k1][i].isGroup = isgroup\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField_Part(updatePoints, updateEdges){\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            if(!this.catEnergyField[k].hasOwnProperty(\"finalField\")){\r\n                // group attrs\r\n                this.catPointDict[k].pointMap=[]\r\n                this.catEnergyField[k].pointBarrierMap=[]\r\n                this.catEnergyField[k].edgeBarrierMap=[]\r\n                this.catEnergyField[k].pointIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap=[]\r\n                this.catEnergyField[k].edgeIndexMap2=[]\r\n                this.catEnergyField[k].finalField = []\r\n                this.catEnergyField[k].subUpdate = []\r\n\r\n                for (let y=0;y<svgheight;y++){\r\n                    this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                    this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                    this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n\r\n                    this.catEnergyField[k].edgeIndexMap2.push([])\r\n                    for(let x=0;x<svgwidth;x++){\r\n                        this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for(var k in this.catPointDict){\r\n\r\n            if(!updatePoints.hasOwnProperty(k)){\r\n                updatePoints[k] = []\r\n            }\r\n\r\n            if(!updateEdges.hasOwnProperty(k)){\r\n                updateEdges[k] = []\r\n            }\r\n\r\n            let members = updatePoints[k]\r\n\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                //this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n\r\n                            if(members[i].flag == false){\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.015 || this.catEnergyField[k].edgeIndexMap[y][x] == -1){\r\n                                    this.catEnergyField[k].field[y][x] = 0\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=-1\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                            }\r\n                            else{\r\n\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                                }\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                    this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                        if(members[i].flag == true){\r\n\r\n                            if(distance<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=1\r\n                                }\r\n                                if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                    this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                                }\r\n                            }\r\n\r\n                            if(distance<=fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=3\r\n                                //this.catPointDict[k].pointMap[i].push([x,y])\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n            // cal positive value of edges\r\n            let edges=updateEdges[k]\r\n            edges.sort(function(a,b){\r\n                return a.flag - b.flag\r\n            })\r\n            //console.log(\"Sort Edegs:\")\r\n            //console.log(edges)\r\n            for (let i=0;i<edges.length;i++){\r\n                // cal positive value for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                let startid=edges[i].start\r\n                let endid=edges[i].end\r\n                startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                startx = Math.max(0, startx)\r\n                endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                endx = Math.max(0, endx)\r\n                starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                starty = Math.max(0, starty)\r\n                endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                endy = Math.max(0, endy)\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        //if(!this.updateIdx.hasOwnProperty(realy)){\r\n                        //    this.updateIdx[realy] = {}\r\n                        //}\r\n//\r\n                        //this.updateIdx[realy][realx] = 1\r\n\r\n                        this.updateIdx.push([parseInt(realy), parseInt(realx)])\r\n\r\n                        let distance=this.calDistanceToEdgeV2(realx,realy,edges[i])\r\n                        let distancetoEdge=distance[0]\r\n                        let distancetoNode=distance[1]\r\n                        let totalDistance=distance[2]\r\n\r\n                        if(distancetoNode<0){\r\n                            continue\r\n                        }\r\n\r\n                        if(distancetoEdge<edgeR1+fixdis){\r\n                            let newR1=edgeR1\r\n                            let reducefactor=edgeR1/10\r\n                            let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                            if(totalDistance>EDGELENGTH_THRESH){\r\n                                newR1=2*edgeR1/(1+factor*distancetoNode)\r\n                            }\r\n                            if(newR1>edgeR1){\r\n                                newR1=edgeR1\r\n                            }\r\n\r\n                            if(newR1>2*nodeR1){\r\n                                newR1=2*nodeR1\r\n                            }\r\n                            let energy\r\n                            if(distancetoEdge>newR1){\r\n                                energy=0\r\n                            }\r\n                            else{\r\n                                energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                            }\r\n\r\n\r\n                            if(edges[i].flag == true){\r\n                                let preenergy = this.catEnergyField[k].finalField[y][x]\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 0\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n                            }\r\n                            else{\r\n                                this.catEnergyField[k].field[y][x]-=energy\r\n                                this.catEnergyField[k].finalField[y][x]=0\r\n                                this.catEnergyField[k].subUpdate[y][x] = 1\r\n                                let delflag = false\r\n                                if(this.catEnergyField[k].pointIndexMap[y][x] == -1 && this.catEnergyField[k].edgeIndexMap2[y][x].length == 1){\r\n                                    if(this.catEnergyField[k].edgeIndexMap2[y][x][0].start == startid && this.catEnergyField[k].edgeIndexMap2[y][x][0].end == endid){\r\n                                        delflag = true\r\n                                    }\r\n                                }\r\n                                if(this.catEnergyField[k].field[y][x] <= 0.015 || delflag){\r\n                                    this.catEnergyField[k].field[y][x]=0\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                    for(let it = this.catEnergyField[k].edgeIndexMap2[y][x].length - 1; it >= 0 ; it --){\r\n                                        let s = this.catEnergyField[k].edgeIndexMap2[y][x][it].start\r\n                                        let e = this.catEnergyField[k].edgeIndexMap2[y][x][it].end\r\n                                        if(s==startid&&e==endid){\r\n                                            this.catEnergyField[k].edgeIndexMap2[y][x].splice(it,1)\r\n                                        }\r\n                                    }\r\n                                    this.catEnergyField[k].barrierMap[y][x]=0\r\n                                }\r\n                                //if(this.catEnergyField[k].pointIndexMap[y][x] != -1){\r\n                                //    this.catEnergyField[k].barrierMap[y][x]=this.catEnergyField[k].pointBarrierMap[y][x]\r\n                                //    this.catEnergyField[k].edgeBarrierMap[y][x]=0\r\n                                //    this.catEnergyField[k].edgeIndexMap[y][x]=-1\r\n                                //}\r\n                            }\r\n\r\n                        }\r\n\r\n                        /*\r\n                        let startpoint=this.pointData[startid]\r\n                        let endpoint=this.pointData[endid]\r\n\r\n                        if(startpoint.multicat&&endpoint.multicat){\r\n                            let hasSameCat=false\r\n                            let samecat=-1\r\n                            for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                let cat1=startpoint.catArray[c1]\r\n                                if(cat1!=k){\r\n                                    for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                        let cat2=endpoint.catArray[c2]\r\n                                        if(cat2!=k){\r\n                                            if(cat2==cat1){\r\n                                                hasSameCat=true\r\n                                                samecat=cat1\r\n                                                break\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n                            }\r\n                            if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                if(distancetoEdge<edgeR1+20+fixdis){\r\n                                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                    let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                    let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                    let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                    // let energyscale=100\r\n\r\n                                    if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                        this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                        this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        */\r\n\r\n                        if(edges[i].flag == true){\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calEnergyField(){\r\n\r\n        //TODO: edge and node use different barrier map\r\n\r\n        for (var k in this.catPointDict){\r\n\r\n            // group attrs\r\n            this.catPointDict[k].pointMap=[]\r\n            this.catEnergyField[k].pointBarrierMap=[]\r\n            this.catEnergyField[k].edgeBarrierMap=[]\r\n            this.catEnergyField[k].pointIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap=[]\r\n            this.catEnergyField[k].edgeIndexMap2=[]\r\n            this.catEnergyField[k].finalField = []\r\n            this.catEnergyField[k].subUpdate = []\r\n\r\n            for (let y=0;y<svgheight;y++){\r\n                this.catEnergyField[k].subUpdate.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].finalField.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].edgeBarrierMap.push(new Array(svgwidth).fill(0))\r\n                this.catEnergyField[k].pointIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap.push(new Array(svgwidth).fill(-1))\r\n                this.catEnergyField[k].edgeIndexMap2.push([])\r\n                for(let x=0;x<svgwidth;x++){\r\n                    this.catEnergyField[k].edgeIndexMap2[y].push([])\r\n                }\r\n            }\r\n\r\n            //// not group attrs\r\n            //this.catPointDict[k].gpointMap=[]\r\n            //this.catEnergyField[k].gpointBarrierMap=[]\r\n            //this.catEnergyField[k].gedgeBarrierMap=[]\r\n            //this.catEnergyField[k].gpointIndexMap=[]\r\n            //this.catEnergyField[k].gedgeIndexMap=[]\r\n//\r\n            //for(let y=0;y<this.catEnergyField[k].gheight;y++){\r\n            //    this.catEnergyField[k].gpointBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gedgeBarrierMap.push(new Array(this.catEnergyField[k].gwidth).fill(0))\r\n            //    this.catEnergyField[k].gpointIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //    this.catEnergyField[k].gedgeIndexMap.push(new Array(this.catEnergyField[k].gwidth).fill(-1))\r\n            //}\r\n\r\n\r\n        }\r\n\r\n        // cal bbox of edges\r\n        // fix to cal at this.centralizeData()\r\n\r\n        // cal the real active region\r\n        //this.LabelGroupElement()\r\n\r\n        for(var k in this.catPointDict){\r\n            let members=this.catPointDict[k]\r\n            // cal positive energy of nodes and barrier map\r\n            for (let i=0;i<members.length;i++){\r\n                let point=members[i]\r\n                this.catPointDict[k].pointMap.push([])\r\n                // cal influence area for pixel group\r\n                let startx\r\n                let endx\r\n                let starty\r\n                let endy\r\n                startx=Math.floor((point.minX-nodeR1-10-this.catEnergyField[k].x) / pixelGroup);\r\n                endx=Math.min(Math.ceil((point.maxX+nodeR1+10-this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                starty=Math.floor((point.minY-nodeR1-10-this.catEnergyField[k].y) / pixelGroup);\r\n                endy=Math.min(Math.ceil((point.maxY+nodeR1+10-this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                for (let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n                        let distance=this.calDistanceToItem(realx,realy,point)\r\n                        if(distance<nodeR1+fixdis){\r\n                            let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                            this.catEnergyField[k].field[y][x]+=energy\r\n                            if(this.catEnergyField[k].barrierMap[y][x]==0){\r\n                                this.catEnergyField[k].barrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]==0){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=5\r\n                            }\r\n                            if(this.catEnergyField[k].pointIndexMap[y][x]==-1){\r\n                                this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                            }\r\n                        }\r\n                        if(point.multicat){\r\n                            let catarr=point.catArray\r\n                            for (let c=0;c<catarr.length;c++){\r\n                                if(catarr[c]!=k&&parseInt(catarr[c])<parseInt(k)){\r\n                                    if(distance<nodeR1+10){\r\n                                        let realx=x * pixelGroup + this.catEnergyField[k].x\r\n                                        let realy=y * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[catarr[c]].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[catarr[c]].y)/pixelGroup)\r\n                                        let energy=nodeWeight*Math.pow(nodeR1-distance,2)/Math.pow(nodeR1-nodeR0,2)\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[catarr[c]].width&&relativey<this.catEnergyField[catarr[c]].height){\r\n                                            // this.catEnergyField[catarr[c]].field[relativey][relativex]+=energy\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if(distance<=barrierGap+fixdis){\r\n                            if(this.catEnergyField[k].barrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].barrierMap[y][x]=1\r\n                            }\r\n                            if(this.catEnergyField[k].pointBarrierMap[y][x]!=3){\r\n                                this.catEnergyField[k].pointBarrierMap[y][x]=1\r\n                            }\r\n                        }\r\n\r\n                        if(distance<=fixdis){\r\n                            //inside\r\n                            this.catEnergyField[k].barrierMap[y][x]=3\r\n                            this.catPointDict[k].pointMap[i].push([x,y])\r\n                            this.catEnergyField[k].pointBarrierMap[y][x]=3\r\n                            this.catEnergyField[k].pointIndexMap[y][x]=point.id\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            // let EDGELENGTH_THRESH=(this.maxEdgeLength+this.minEdgeLength)/3\r\n            let EDGELENGTH_THRESH=this.maxEdgeLength/2\r\n            // let EDGELENGTH_THRESH=this.maxEdgeLength/1.5\r\n\r\n            // cal positive value of edges\r\n            if(this.catEdgeDict.hasOwnProperty(k)){\r\n                let edges=this.catEdgeDict[k]\r\n                for (let i=0;i<edges.length;i++){\r\n                    // cal positive value for pixel group\r\n                    let startx\r\n                    let endx\r\n                    let starty\r\n                    let endy\r\n                    let startid=edges[i].start\r\n                    let endid=edges[i].end\r\n                    startx=Math.floor((edges[i].x-edgeR1-10-this.catEnergyField[k].x)/pixelGroup)\r\n                    endx=Math.min(Math.ceil((edges[i].x+edges[i].width+edgeR1+10-this.catEnergyField[k].x)/pixelGroup),this.catEnergyField[k].width)\r\n                    starty=Math.floor((edges[i].y-edgeR1-10-this.catEnergyField[k].y)/pixelGroup)\r\n                    endy=Math.min(Math.ceil((edges[i].y+edges[i].height+edgeR1+10-this.catEnergyField[k].y)/pixelGroup),this.catEnergyField[k].height)\r\n                    for (let y=starty;y<endy;y++){\r\n                        for (let x=startx;x<endx;x++){\r\n                            let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                            let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                            let distance=this.calDistanceToEdge(realx,realy,edges[i])\r\n                            let distancetoEdge=distance[0]\r\n                            let distancetoNode=distance[1]\r\n                            let totalDistance=distance[2]\r\n\r\n                            if(distancetoNode<0){\r\n                                continue\r\n                            }\r\n\r\n                            if(distancetoEdge<edgeR1+fixdis){\r\n                                let newR1=edgeR1\r\n                                // let factor=(edgeR1-2)/this.maxEdgeLength\r\n                                let reducefactor=edgeR1/10\r\n                                let factor=(edgeR1-2)/(reducefactor*totalDistance)\r\n\r\n                                if(totalDistance>EDGELENGTH_THRESH){\r\n                                    newR1=2*edgeR1/(1+factor*distancetoNode)\r\n\r\n\r\n                                    // newR1=2*edgeR1/(1+factor*distancetoNode/4)\r\n\r\n                                    // weight=1-Math.pow(factor,2)\r\n                                    // let factor=2*(Math.exp(2)-1)/this.maxEdgeLength\r\n                                    // weight=1/(Math.log(1+factor*distancetoNode)+2)\r\n\r\n                                    // weight=weight*2\r\n                                }\r\n                                if(newR1>edgeR1){\r\n                                    newR1=edgeR1\r\n                                }\r\n\r\n                                if(newR1>2*nodeR1){\r\n                                    newR1=2*nodeR1\r\n                                }\r\n                                let energy\r\n                                if(distancetoEdge>newR1){\r\n                                    energy=0\r\n                                }\r\n                                else{\r\n                                    energy=edgeWeight*Math.pow(newR1-distancetoEdge,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                }\r\n                                this.catEnergyField[k].field[y][x]+=energy\r\n\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==0||this.catEnergyField[k].barrierMap[y][x]==5){\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].barrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]==0||this.catEnergyField[k].edgeBarrierMap[y][x]==5) {\r\n                                    if(energy>0)\r\n                                        this.catEnergyField[k].edgeBarrierMap[y][x]=6\r\n                                }\r\n\r\n                                if(energy>0){\r\n                                    this.catEnergyField[k].edgeIndexMap[y][x]=startid\r\n                                    this.catEnergyField[k].edgeIndexMap2[y][x].push({start:startid,end:endid})\r\n                                }\r\n\r\n\r\n                            }\r\n\r\n                            let startpoint=this.pointData[startid]\r\n                            let endpoint=this.pointData[endid]\r\n\r\n                            if(startpoint.multicat&&endpoint.multicat){\r\n                                let hasSameCat=false\r\n                                let samecat=-1\r\n                                for (let c1=0;c1<startpoint.catArray.length;c1++){\r\n                                    let cat1=startpoint.catArray[c1]\r\n                                    if(cat1!=k){\r\n                                        for (let c2=0;c2<endpoint.catArray.length;c2++){\r\n                                            let cat2=endpoint.catArray[c2]\r\n                                            if(cat2!=k){\r\n                                                if(cat2==cat1){\r\n                                                    hasSameCat=true\r\n                                                    samecat=cat1\r\n                                                    break\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                    }\r\n                                }\r\n                                if(hasSameCat&&parseInt(samecat)<parseInt(k)){\r\n                                    if(distancetoEdge<edgeR1+20+fixdis){\r\n                                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                                        let relativex=Math.floor((realx-this.catEnergyField[samecat].x)/pixelGroup)\r\n                                        let relativey=Math.floor((realy-this.catEnergyField[samecat].y)/pixelGroup)\r\n                                        let energy=edgeWeight*Math.pow(edgeR1-0,2)/Math.pow(edgeR1-edgeR0,2)\r\n                                        // let energyscale=100\r\n\r\n                                        if(relativex>0&&relativey>0&&relativex<this.catEnergyField[samecat].width&&relativey<this.catEnergyField[samecat].height){\r\n                                            this.catEnergyField[samecat].field[relativey][relativex]+=energy\r\n                                            this.catEnergyField[samecat].edgeIndexMap[relativey][relativex]=startpoint.id\r\n                                            this.catEnergyField[samecat].edgeIndexMap2[relativey][relativex].push({start:startpoint.id, end:endpoint.id})\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=barrierGap+fixdis){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]!=4&&this.catEnergyField[k].barrierMap[y][x]!=3&&this.catEnergyField[k].barrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].barrierMap[y][x]=2\r\n                                }\r\n                                if(this.catEnergyField[k].edgeBarrierMap[y][x]!=4&&this.catEnergyField[k].edgeBarrierMap[y][x]!=3&&this.catEnergyField[k].edgeBarrierMap[y][x]!=1){\r\n                                    this.catEnergyField[k].edgeBarrierMap[y][x]=2\r\n                                }\r\n                            }\r\n\r\n                            if(distancetoEdge<=2+fixdis){\r\n                                //inside\r\n                                this.catEnergyField[k].barrierMap[y][x]=4\r\n                                this.catEnergyField[k].edgeBarrierMap[y][x]=4\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    checkEdgeCrossing(a, b, c, d){\r\n\r\n        // abc 2\r\n        var area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\r\n\r\n        // abd 2\r\n        var area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);\r\n\r\n        // , (,);\r\n        if ( area_abc*area_abd>=0 ) {\r\n            return [false];\r\n        }\r\n\r\n        // cda 2\r\n        var area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);\r\n        // cdb 2\r\n        // : .,.\r\n        var area_cdb = area_cda + area_abc - area_abd ;\r\n        if (  area_cda * area_cdb >= 0 ) {\r\n            return [false];\r\n        }\r\n\r\n        //\r\n        var t = area_cda / ( area_abd- area_abc );\r\n        var dx= t*(b.x - a.x),\r\n            dy= t*(b.y - a.y);\r\n        return[true, { x: a.x + dx , y: a.y + dy }];\r\n\r\n    }\r\n\r\n    createGapInBoundary(){\r\n        let gap=this.state.gapBetween\r\n        if(gap==0)\r\n            return\r\n        for (var k in this.catEnergyField){\r\n            let field=this.catEnergyField[k].finalField\r\n            let deletePoints=[]\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    if(field[y][x]==0){\r\n                        continue\r\n                    }\r\n\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4)\r\n                        continue\r\n\r\n                    //check if it is the boundary\r\n                    let isboundary=false\r\n                    for (let i=0;i<gap;i++){\r\n                        let delta=i+1\r\n                        //right\r\n                        if(x+delta<this.catEnergyField[k].width){\r\n                            if(field[y][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left\r\n                        if(x-delta>0){\r\n                            if(field[y][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //up\r\n                        if(y-delta>0){\r\n                            if(field[y-delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //down\r\n                        if(y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-top\r\n                        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n                            if(field[y-delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //right-bottom\r\n                        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x+delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-top\r\n                        if(x-delta>0&&y-delta>0){\r\n                            if(field[y-delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n                        //left-bottom\r\n                        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n                            if(field[y+delta][x-delta]==0){\r\n                                isboundary=true\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(isboundary){\r\n                        // this.catEnergyField[k].finalField[y][x]=0\r\n                        deletePoints.push([x,y])\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for (let i=0;i<deletePoints.length;i++){\r\n                let x=deletePoints[i][0]\r\n                let y=deletePoints[i][1]\r\n                this.catEnergyField[k].finalField[y][x]=0\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    removeEmptyZone(isoDict){\r\n\r\n        // for (var k in this.catEnergyField){\r\n        //     for (let y=0;y<this.catEnergyField[k].height;y++){\r\n        //         for (let x=0;x<this.catEnergyField[k].width;x++){\r\n        //             if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==4){\r\n        //                 this.catEnergyField[k].finalField[y][x]=0\r\n        //             }\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        for (var k in isoDict){\r\n            let isolines=isoDict[k]\r\n            let isolinepoints=[]\r\n            let finalField=this.catEnergyField[k].finalField\r\n            this.catEnergyField[k].isoLineMap=[]\r\n\r\n            for (let i=0;i<isolines.length;i++){\r\n                let relativepoints=[]\r\n                for (let p=0;p<isolines[i].length;p++){\r\n                    relativepoints.push({x:isolines[i][p][0], y:isolines[i][p][1]})\r\n                }\r\n                isolinepoints.push(relativepoints)\r\n            }\r\n\r\n            let isoInsidePoints=[]\r\n            for (let i=0;i<isolinepoints.length;i++){\r\n                isoInsidePoints.push([])\r\n            }\r\n\r\n            for (let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].isoLineMap.push([])\r\n                for (let x=0;x<this.catEnergyField[k].width;x++){\r\n                    this.catEnergyField[k].isoLineMap[y].push(-1)\r\n\r\n                    if(finalField[y][x]>0){\r\n                        for (let i=0;i<isolinepoints.length;i++){\r\n                            //check if it is inside the isoline\r\n                            let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},isolinepoints[i])\r\n                            if(intersect){\r\n                                isoInsidePoints[i].push([x,y])\r\n                                this.catEnergyField[k].isoLineMap[y][x]=i\r\n                                break\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            let notDeleteIndex=[]\r\n            for (let i=0;i<this.catPointDict[k].pointMap.length;i++){\r\n                let nodePoints=this.catPointDict[k].pointMap[i]\r\n                let totalInside=true\r\n                let isolineIndex=-1\r\n\r\n                // if(k==\"5\"&&i==0){\r\n                //     console.log()\r\n                // }\r\n\r\n                for (let n=0;n<nodePoints.length;n++){\r\n                    let x=nodePoints[n][0]\r\n                    let y=nodePoints[n][1]\r\n                    if(n==0){\r\n                        if(this.catEnergyField[k].isoLineMap[y][x]>-1){\r\n                            isolineIndex=this.catEnergyField[k].isoLineMap[y][x]\r\n                        }\r\n                    }\r\n                    if(this.catEnergyField[k].isoLineMap[y][x]==-1||this.catEnergyField[k].isoLineMap[y][x]!=isolineIndex){\r\n                        totalInside=false\r\n                        break\r\n                    }\r\n\r\n                }\r\n\r\n                if(totalInside){\r\n                    notDeleteIndex.push(isolineIndex)\r\n                }\r\n\r\n            }\r\n\r\n            let deleteindex=[]\r\n\r\n            for(let i=0;i<isoInsidePoints.length;i++){\r\n                let isdelete=true\r\n                for (let j=0;j<notDeleteIndex.length;j++){\r\n                    if(i==notDeleteIndex[j]){\r\n                        isdelete=false\r\n                        break\r\n                    }\r\n                }\r\n                if(isdelete){\r\n                    deleteindex.push(i)\r\n                }\r\n            }\r\n\r\n\r\n            for (let i=0;i<deleteindex.length;i++){\r\n                let index=deleteindex[i]\r\n                let deletePoints=isoInsidePoints[index]\r\n\r\n                for(let p=0;p<deletePoints.length;p++){\r\n                    let x=deletePoints[p][0]\r\n                    let y=deletePoints[p][1]\r\n                    this.catEnergyField[k].finalField[y][x]=0\r\n                }\r\n            }\r\n\r\n            let newisolines=[]\r\n            for (let i=0;i<isolines.length;i++){\r\n                let isdelete=false\r\n                for (let j=0;j<deleteindex.length;j++){\r\n                    if(i==deleteindex[j]){\r\n                        isdelete=true\r\n                        break\r\n                    }\r\n\r\n                }\r\n                if(!isdelete){\r\n                    newisolines.push(isolines[i])\r\n                }\r\n\r\n            }\r\n\r\n            isoDict[k]=newisolines\r\n        }\r\n        return isoDict\r\n    }\r\n\r\n    isSameCat(catarr1,catarr2){\r\n        for(let i=0;i<catarr1.length;i++){\r\n            let cat1=catarr1[i]\r\n            for (let j=0;j<catarr2.length;j++){\r\n                let cat2=catarr2[j]\r\n                if(cat1==cat2){\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isContained(catarr,cat){\r\n        for(let i=0;i<catarr.length;i++){\r\n            if(catarr[i]==cat){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calFinalEnergeFieldForOverlap(){\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = this.catEnergyField[k].field\r\n            for(let y in this.catNotGroup[k]){\r\n                //this.catEnergyField[k].finalField.push(new Array(this.catEnergyField[k].width).fill(0))\r\n                for(let x in this.catNotGroup[k][y]){\r\n                    y = parseInt(y);\r\n                    x = parseInt(x);\r\n                    let px = Math.ceil(x/pixelGroup)\r\n                    let py = Math.ceil(y/pixelGroup)\r\n                    let realx=x+this.catEnergyField[k].x\r\n                    let realy=y+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].gfield[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].gpointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].gedgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].gbarrierMap[y][x]==3||this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].gfield[y][x]==0){\r\n                        // drawRect(realx,realy,1,1,\"red\")\r\n                        value=1\r\n                        this.catEnergyField[k].gfield[y][x]=1\r\n                        this.catEnergyField[k].field[py][px]=1\r\n                    }\r\n\r\n\r\n                    /*                    if (!isInside&&value==0){\r\n                                            continue\r\n                                        }*/\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].x+this.catEnergyField[k2].gwidth&&realx>this.catEnergyField[k2].x&&realy<this.catEnergyField[k2].y+this.catEnergyField[k2].gheight&&realy>this.catEnergyField[k2].y){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x))\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y))\r\n\r\n                                let othervalue=this.catEnergyField[k2].gfield[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].gpointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].gedgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].gpointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].gbarrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].gbarrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].gbarrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[py][px]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[py][px]==4){\r\n                        this.catEnergyField[k].finalField[py][px]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateEnergyPoints(){\r\n        //update final energyfield according to this.updatedEnergyPoints\r\n        for (var k in this.updatedEnergyPoints){\r\n            for (let p=0;p<this.updatedEnergyPoints[k].length;p++){\r\n                let x=this.updatedEnergyPoints[k][p][0]\r\n                let y=this.updatedEnergyPoints[k][p][1]\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=this.catEnergyField[k].field[y][x]\r\n                // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                let finalvalue=value\r\n                let isInside=false\r\n\r\n                if(value == 0){\r\n                    continue;\r\n                }\r\n\r\n               if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    isInside=true\r\n                }\r\n\r\n                if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                    value=1\r\n                    this.catEnergyField[k].field[y][x]=1\r\n                }\r\n\r\n                if (value==0){\r\n                    // drawRect(realx,realy,1,1,\"black\")\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField){\r\n                    if(k2==k)\r\n                        continue\r\n\r\n                    if(k2!=k){\r\n                        if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                            let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                            let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                            let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                            let otherinside=false\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ){\r\n\r\n                                if(this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==1|| this.catEnergyField[k2].pointBarrierMap[relativey][relativex]==3){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                otherinside=true\r\n                            }\r\n\r\n\r\n                            if (othervalue==0){\r\n                                // drawRect(realx,realy,1,1,\"black\")\r\n                                continue\r\n                            }\r\n\r\n                            // drawRect(realx,realy,2,2,\"red\")\r\n\r\n                            // drawRect(realx,realy,1,1,\"blue\")\r\n                            if(!isInside&&!otherinside){\r\n\r\n                                if(othervalue>value){\r\n                                    finalvalue=0\r\n                                    // drawRect(realx,realy,2,2,\"red\")\r\n                                    // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                    break\r\n                                }\r\n                                else{\r\n                                    finalvalue=value\r\n                                }\r\n                                // finalvalue=0\r\n                                // finalvalue=value\r\n\r\n                            }\r\n                            else if(isInside&&!otherinside){\r\n                                // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                //pass\r\n\r\n                                finalvalue=value\r\n                            }\r\n                            else if(!isInside&&otherinside){\r\n                                // drawRect(realx,realy,2,2,\"black\")\r\n                                // drawRect(realx,realy,1,1,\"orange\")\r\n                                finalvalue=0\r\n                                break\r\n                            }\r\n                            else if(isInside&&otherinside){\r\n\r\n                                // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else{\r\n                                    finalvalue=0\r\n                                }\r\n                                // finalvalue=0\r\n\r\n\r\n                            }\r\n\r\n                            // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                            //     finalvalue=0\r\n                            // }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                //if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                //    this.catEnergyField[k].finalField[y][x]=10000\r\n                //}\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    calFinalEnergeField_Part(){\r\n\r\n        this.updateIdx = new Set(this.updateIdx)\r\n        //console.log(\"calFinalEnergeField_Part:\")\r\n        //console.log(this.updateIdx)\r\n        for (var k in this.catEnergyField){\r\n            //this.catEnergyField[k].finalField = clone(this.catEnergyField[k].field)\r\n            for(let updateidx of this.updateIdx){\r\n\r\n\r\n                    let realx=parseInt(updateidx[1])\r\n                    let realy=parseInt(updateidx[0])\r\n\r\n\r\n                    //console.log(\"(\" + realx + \", \" + realy + \")\")\r\n\r\n                    let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup)\r\n                    let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup)\r\n\r\n                    x = Math.min(x, this.catEnergyField[k].width - 1)\r\n                    y = Math.min(y, this.catEnergyField[k].height - 1)\r\n                    x = Math.max(x, 0)\r\n                    y = Math.max(y, 0)\r\n\r\n                    //d3.select('g').append('circle')\r\n                    //    .attr('id','final')\r\n                    //    .attr('cx',realx)\r\n                    //    .attr('cy',realy)\r\n                    //    .attr('r',1)\r\n                    //    .attr('fill','red')\r\n\r\n                    //console.log(\"(\" + this.catEnergyField[k].width + \", \" + this.catEnergyField[k].height + \")\")\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    //if(value == 0){\r\n                    //    continue\r\n                    //}\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside && this.catEnergyField[k].field[y][x] <= 0.015 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        value=1\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>this.catEnergyField[k2].boundingX&&realy<this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    continue\r\n                                }\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4 && this.catEnergyField[k].subUpdate[y][x] != 1){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n    calFinalEnergeField(){\r\n\r\n        //let multiCatDict=[]\r\n        //for(let i=0;i<this.pointData.length;i++){\r\n        //    if(this.pointData[i].multicat){\r\n        //        let catarr=this.pointData[i].catArray\r\n        //        multiCatDict.push(catarr)\r\n        //    }\r\n        //}\r\n        for (var k in this.catEnergyField){\r\n            let startY = parseInt((this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let startX = parseInt((this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            let endY = parseInt((this.catEnergyField[k].boundingHeight * pixelGroup + this.catEnergyField[k].boundingY - this.catEnergyField[k].y)/pixelGroup)\r\n            let endX = parseInt((this.catEnergyField[k].boundingWidth * pixelGroup + this.catEnergyField[k].boundingX - this.catEnergyField[k].x)/pixelGroup)\r\n            for(let y=startY;y<endY;y++){\r\n                for(let x=startX;x<endX;x++){\r\n                    let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                    let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                    let value=this.catEnergyField[k].field[y][x]\r\n\r\n                    // let aim=false\r\n                    // if(Math.floor(realx)==601&&Math.floor(realy)==519){\r\n                    //     console.log(k,value,realx,realy,x,y)\r\n                    //     aim=true\r\n                    // }\r\n\r\n                    let finalvalue=value\r\n                    let isInside=false\r\n\r\n                    let thisPointID=this.catEnergyField[k].pointIndexMap[y][x]\r\n                    let thisEdgeID=this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                    let thiscat\r\n\r\n                    if(thisEdgeID==-1&&thisPointID==-1){\r\n                        continue\r\n                    }\r\n\r\n                    if(thisEdgeID>-1){\r\n                        if(this.pointData[thisEdgeID].multicat){\r\n                            thiscat=this.pointData[thisEdgeID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisEdgeID].cat]\r\n                        }\r\n                    }\r\n\r\n                    if(thisPointID>-1){\r\n                        if(this.pointData[thisPointID].multicat){\r\n                            thiscat=this.pointData[thisPointID].catArray\r\n                        }\r\n                        else{\r\n                            thiscat=[this.pointData[thisPointID].cat]\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]>0 && this.catEnergyField[k].barrierMap[y][x]!=5&& this.catEnergyField[k].barrierMap[y][x]!=6){\r\n                    // if(this.catEnergyField[k].barrierMap[y][x]==1||this.catEnergyField[k].barrierMap[y][x]==2||this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        isInside=true\r\n                    }\r\n\r\n                    if(isInside&&this.catEnergyField[k].field[y][x]==0){\r\n                        this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                        this.catEnergyField[k].edgeIndexMap2[y][x].push({start:this.edges[thisEdgeID].start,end:this.edges[thisEdgeID].end})\r\n                        value=1\r\n                        this.catEnergyField[k].field[y][x]=1\r\n                    }\r\n\r\n                    if (value==0){\r\n                        continue\r\n                    }\r\n\r\n                    for (var k2 in this.catEnergyField){\r\n                        if(k2==k)\r\n                            continue\r\n\r\n                        // let isContain=false\r\n                        //\r\n                        // for (let i=0;i<this.catPointDict[k2].length;i++){\r\n                        //     if(this.catPointDict[k2][i].multicat){\r\n                        //         let catarr=this.catPointDict[k2][i].catArray\r\n                        //         for (let c=0;c<catarr.length;c++){\r\n                        //             if(catarr[c]==k){\r\n                        //                 isContain=true\r\n                        //                 break\r\n                        //             }\r\n                        //         }\r\n                        //         if(isContain){\r\n                        //             break\r\n                        //         }\r\n                        //     }\r\n                        // }\r\n                        // if(isContain){\r\n                        //     continue\r\n                        // }\r\n\r\n                        if(k2!=k){\r\n                            if(realx<=this.catEnergyField[k2].boundingX+this.catEnergyField[k2].boundingWidth*pixelGroup&&realx>=this.catEnergyField[k2].boundingX&&realy<=this.catEnergyField[k2].boundingY+this.catEnergyField[k2].boundingHeight*pixelGroup&&realy>=this.catEnergyField[k2].boundingY){\r\n                                let relativex=Math.floor((realx-this.catEnergyField[k2].x)/pixelGroup)\r\n                                let relativey=Math.floor((realy-this.catEnergyField[k2].y)/pixelGroup)\r\n\r\n                                let othervalue=this.catEnergyField[k2].field[relativey][relativex]\r\n                                let otherinside=false\r\n                                let otherPointID=this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                                let otherEdgeID=this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                                let othercat\r\n\r\n                                if(otherPointID==-1&&otherEdgeID==-1){\r\n                                    continue\r\n                                }\r\n\r\n                                if(otherEdgeID>-1){\r\n                                    if(this.pointData[otherEdgeID].multicat){\r\n                                        othercat=this.pointData[otherEdgeID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherEdgeID].cat]\r\n                                    }\r\n                                }\r\n\r\n                                if(otherPointID>-1){\r\n                                    if(this.pointData[otherPointID].multicat){\r\n                                        othercat=this.pointData[otherPointID].catArray\r\n                                    }\r\n                                    else{\r\n                                        othercat=[this.pointData[otherPointID].cat]\r\n                                    }\r\n                                }\r\n\r\n\r\n                                // if(aim){\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                // if(k==\"11\"&&k2==\"0\"){\r\n                                //         drawRect(realx,realy,1,1,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n\r\n                                if(this.isContained(othercat,k)){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // if(k==\"11\"&&k2==\"0\"){\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    // }\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n                                }\r\n\r\n\r\n                                if(this.isContained(thiscat,k2)&&this.catEnergyField[k2].pointBarrierMap[relativey][relativex]!=3){\r\n                                    //contained cat to main cat\r\n                                    //     drawRect(realx,realy,1,1,\"red\")\r\n                                    //this.catEnergyField[k].finalField[y][x]=value\r\n                                    continue\r\n\r\n                                }\r\n\r\n\r\n                                if(this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                    // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==1 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==2||this.catEnergyField[k2].barrierMap[relativey][relativex]==3 ||this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n\r\n                                    otherinside=true\r\n                                }\r\n\r\n\r\n\r\n                                /*                                    if (!otherinside&&othervalue==0){\r\n                                                                        // drawRect(realx,realy,1,1,\"black\")\r\n                                                                        continue\r\n                                                                    }*/\r\n\r\n                                if (othervalue==0){\r\n                                    // drawRect(realx,realy,1,1,\"black\")\r\n\r\n                                    continue\r\n                                }\r\n\r\n                                // drawRect(realx,realy,1,1,\"blue\")\r\n                                if(!isInside&&!otherinside){\r\n                                    if(othervalue>value){\r\n                                        finalvalue=0\r\n                                        // drawRect(realx,realy,1,1,\"blue\")\r\n\r\n                                        break\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=value\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n                                }\r\n                                else if(isInside&&!otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"yellow\")\r\n\r\n                                    //pass\r\n\r\n                                    finalvalue=value\r\n                                }\r\n                                else if(!isInside&&otherinside){\r\n                                    // drawRect(realx,realy,1,1,\"orange\")\r\n\r\n                                    finalvalue=0\r\n                                    break\r\n                                }\r\n                                else if(isInside&&otherinside){\r\n\r\n                                    // if(this.catEnergyField[k].barrierMap[y][x]==3||this.catEnergyField[k].barrierMap[y][x]==4){\r\n                                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n\r\n                                        finalvalue=value\r\n                                    }\r\n                                    else{\r\n                                        finalvalue=0\r\n                                    }\r\n                                    // finalvalue=0\r\n\r\n\r\n                                }\r\n\r\n                                // if(this.catEnergyField[k2].barrierMap[relativey][relativex]==4){\r\n                                //     finalvalue=0\r\n                                // }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.catEnergyField[k].finalField[y][x]=finalvalue\r\n                    if(this.catEnergyField[k].barrierMap[y][x]==4){\r\n                        this.catEnergyField[k].finalField[y][x]=10000\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    recalFinalEnergeField(preK){\r\n\r\n        let bounding = {}\r\n        for(let k in this.catEnergyField){\r\n            bounding[k] = {\r\n                minX : Number.MAX_VALUE,\r\n                minY : Number.MAX_VALUE,\r\n                maxX : Number.MIN_VALUE,\r\n                maxY : Number.MIN_VALUE\r\n            }\r\n        }\r\n\r\n        for (var k in this.catEnergyField){\r\n            if(k == preK){\r\n                continue\r\n            }\r\n            for(let p=0;p<this.updatedEnergyPoints[preK].length;p++) {\r\n\r\n                let realx = this.updatedEnergyPoints[preK][p][0] * pixelGroup + this.catEnergyField[preK].x\r\n                let realy = this.updatedEnergyPoints[preK][p][1] * pixelGroup + this.catEnergyField[preK].y\r\n\r\n                let x = parseInt((realx - this.catEnergyField[k].x) / pixelGroup);\r\n                let y = parseInt((realy - this.catEnergyField[k].y) / pixelGroup);\r\n\r\n\r\n                bounding[k].minX = Math.min(bounding[k].minX, x)\r\n                bounding[k].minY = Math.min(bounding[k].minY, y)\r\n                bounding[k].maxX = Math.max(bounding[k].maxX, x)\r\n                bounding[k].maxY = Math.max(bounding[k].maxY, y)\r\n\r\n                let value = this.catEnergyField[k].field[y][x]\r\n                let finalvalue = value\r\n                let isInside = false\r\n\r\n                let thisPointID = this.catEnergyField[k].pointIndexMap[y][x]\r\n                let thisEdgeID = this.catEnergyField[k].edgeIndexMap[y][x]\r\n\r\n                let thiscat\r\n\r\n                if (thisEdgeID == -1 && thisPointID == -1) {\r\n                    continue\r\n                }\r\n\r\n                if (thisEdgeID > -1) {\r\n                    if (this.pointData[thisEdgeID].multicat) {\r\n                        thiscat = this.pointData[thisEdgeID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisEdgeID].cat]\r\n                    }\r\n                }\r\n\r\n                if (thisPointID > -1) {\r\n                    if (this.pointData[thisPointID].multicat) {\r\n                        thiscat = this.pointData[thisPointID].catArray\r\n                    } else {\r\n                        thiscat = [this.pointData[thisPointID].cat]\r\n                    }\r\n                }\r\n\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 3 || this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    isInside = true\r\n                }\r\n\r\n                if (isInside && this.catEnergyField[k].field[y][x] == 0) {\r\n                    this.catEnergyField[k].edgeIndexMap[y][x] = this.edges[thisEdgeID].start\r\n                    this.catEnergyField[k].edgeIndexMap2[y][x].push({\r\n                        start: this.edges[thisEdgeID].start,\r\n                        end: this.edges[thisEdgeID].end\r\n                    })\r\n                    value = 1\r\n                    this.catEnergyField[k].field[y][x] = 1\r\n                }\r\n\r\n                if (value == 0) {\r\n                    continue\r\n                }\r\n\r\n                for (var k2 in this.catEnergyField) {\r\n\r\n                    if (k2 == k)\r\n                        continue\r\n\r\n                    if(k2 == preK){\r\n                        // TODO : compare final value\r\n\r\n\r\n                        continue\r\n                    }\r\n\r\n                    if (realx <= this.catEnergyField[k2].boundingX + this.catEnergyField[k2].boundingWidth * pixelGroup && realx >= this.catEnergyField[k2].boundingX && realy <= this.catEnergyField[k2].boundingY + this.catEnergyField[k2].boundingHeight * pixelGroup && realy >= this.catEnergyField[k2].boundingY) {\r\n                        let relativex = Math.floor((realx - this.catEnergyField[k2].x) / pixelGroup)\r\n                        let relativey = Math.floor((realy - this.catEnergyField[k2].y) / pixelGroup)\r\n\r\n                        let othervalue = this.catEnergyField[k2].field[relativey][relativex]\r\n                        let otherinside = false\r\n                        let otherPointID = this.catEnergyField[k2].pointIndexMap[relativey][relativex]\r\n                        let otherEdgeID = this.catEnergyField[k2].edgeIndexMap[relativey][relativex]\r\n                        let othercat\r\n\r\n                        if (otherPointID == -1 && otherEdgeID == -1) {\r\n                            continue\r\n                        }\r\n\r\n                        if (otherEdgeID > -1) {\r\n                            if (this.pointData[otherEdgeID].multicat) {\r\n                                othercat = this.pointData[otherEdgeID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherEdgeID].cat]\r\n                            }\r\n                        }\r\n\r\n                        if (otherPointID > -1) {\r\n                            if (this.pointData[otherPointID].multicat) {\r\n                                othercat = this.pointData[otherPointID].catArray\r\n                            } else {\r\n                                othercat = [this.pointData[otherPointID].cat]\r\n                            }\r\n                        }\r\n\r\n\r\n                        // if(aim){\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        // if(k==\"11\"&&k2==\"0\"){\r\n                        //         drawRect(realx,realy,1,1,\"red\")\r\n                        //     console.log()\r\n                        // }\r\n\r\n                        if (this.isContained(othercat, k)) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // if(k==\"11\"&&k2==\"0\"){\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            // }\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n                        }\r\n\r\n\r\n                        if (this.isContained(thiscat, k2) && this.catEnergyField[k2].pointBarrierMap[relativey][relativex] != 3) {\r\n                            //contained cat to main cat\r\n                            //     drawRect(realx,realy,1,1,\"red\")\r\n                            //this.catEnergyField[k].finalField[y][x]=value\r\n                            continue\r\n\r\n                        }\r\n\r\n                        if (this.catEnergyField[k2].barrierMap[relativey][relativex] == 3 || this.catEnergyField[k2].barrierMap[relativey][relativex] == 4) {\r\n                            otherinside = true\r\n                        }\r\n\r\n                        if (othervalue == 0) {\r\n                            continue\r\n                        }\r\n\r\n                        if (!isInside && !otherinside) {\r\n                            if (othervalue > value) {\r\n                                finalvalue = 0\r\n                                break\r\n                            } else {\r\n                                finalvalue = value\r\n                            }\r\n                        } else if (isInside && !otherinside) {\r\n                            finalvalue = value\r\n                        } else if (!isInside && otherinside) {\r\n                            finalvalue = 0\r\n                            break\r\n                        } else if (isInside && otherinside) {\r\n                           if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                                finalvalue = value\r\n                            } else {\r\n                                finalvalue = 0\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n                this.catEnergyField[k].finalField[y][x] = finalvalue\r\n                if (this.catEnergyField[k].barrierMap[y][x] == 4) {\r\n                    this.catEnergyField[k].finalField[y][x] = 10000\r\n                }\r\n            }\r\n        }\r\n\r\n        this.smoothEnergyField(bounding)\r\n\r\n    }\r\n\r\n    updateFinalField(idx,k,val){\r\n\r\n        let id = parseInt(idx);\r\n        let sz = control_points[k].length;\r\n        //console.log([id,sz]);\r\n        let points = []\r\n        let miny = Number.MAX_VALUE\r\n        let maxy = Number.MIN_VALUE\r\n        for(let j = -1;j <= 1;j ++ ){\r\n            points.push({\r\n                x:control_points[k][(id + j) % sz][0],\r\n                y:control_points[k][(id + j) % sz][1]\r\n            })\r\n            miny = Math.min(miny,control_points[k][(id + j) % sz][1]);\r\n            maxy = Math.max(maxy,control_points[k][(id + j) % sz][1]);\r\n        }\r\n//\r\n        let lines = []\r\n//\r\n        for(let j = 0;j < 3;j ++){\r\n            let p1 = points[j]\r\n            let p2 = points[(j+1)%3]\r\n            let tmp = {}\r\n            tmp.y1 = Math.min(p1.y,p2.y);\r\n            tmp.y2 = Math.max(p1.y,p2.y);\r\n            if(p1.y == p2.y){\r\n                tmp.flag = true;\r\n                tmp.val1 = Math.min(p1.x,p2.x);\r\n                tmp.val2 = Math.max(p1.x,p2.x);\r\n            }\r\n            else{\r\n                tmp.flag = false;\r\n                tmp.val1 = (p2.x - p1.x) / (p2.y - p1.y);\r\n                tmp.val2 = (p1.x * p2.y - p2.x * p1.y) / (p2.y - p1.y);\r\n            }\r\n            lines.push(tmp);\r\n        }\r\n//\r\n        for(let y = miny;y < maxy;y ++){\r\n//\r\n            let x1 = Number.MAX_VALUE;\r\n            let x2 = Number.MIN_VALUE;\r\n            let flag = false;\r\n//\r\n            for(let j = 0; j < 3;j ++){\r\n                if(y >= lines[j].y1 && y <= lines[j].y2){\r\n                    if(lines[j].flag == true){\r\n                        x1 = lines[j].val1;\r\n                        x2 = lines[j].val2;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                    else{\r\n                        let tmpx = lines[j].val1 * y + lines[j].val2;\r\n                        x1 = Math.min(x1, tmpx);\r\n                        x2 = Math.max(x2,tmpx);\r\n                    }\r\n                }\r\n            }\r\n//\r\n            if(flag==true && val == 0){\r\n                continue;\r\n            }\r\n            else{\r\n                x1 = parseInt(x1)\r\n                x2 = parseInt(x2)\r\n                for(let x = x1;x <= x2;x ++){\r\n                    //console.log(\"(\" + this.catEnergyField[k].x + \", \" + this.catEnergyField[k].y + \", \"+ pixelGroup + \")\");\r\n                    //console.log(\"(\" + this.catEnergyField[k].height + \", \" + this.catEnergyField[k].width + \")\")\r\n                    let uy = Math.min(parseInt((y - this.catEnergyField[k].y) / pixelGroup),this.catEnergyField[k].height);\r\n                    let ux = Math.min(parseInt((x - this.catEnergyField[k].x) / pixelGroup),this.catEnergyField[k].width);\r\n                    uy = Math.max(uy,0)\r\n                    ux = Math.max(ux,0)\r\n                    //alert(\"(\" + x + \", \" + y + \")\");\r\n                    // this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].field[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.catEnergyField[k].finalField[parseInt(uy)][parseInt(ux)] = val;\r\n                    this.updatedEnergyPoints[k].push([parseInt(ux),parseInt(uy)])\r\n                }\r\n            }\r\n//\r\n        }\r\n        //console.log(this.catEnergyField[k].finalField)\r\n    }\r\n\r\n    drawEnergyField(k){\r\n        colors = this.props.colorArray\r\n\r\n        let field=this.catEnergyField[k].finalField\r\n        //let field = this.catEnergyField[k].field\r\n        for(let y=0;y<field.length;y++){\r\n            for (let x=0;x<field[y].length;x++){\r\n                if(field[y][x]<0.0001)\r\n                    continue\r\n                let that=this\r\n                let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                let realy=y*pixelGroup+this.catEnergyField[k].y\r\n                let value=field[y][x]\r\n\r\n                g.append(\"rect\")\r\n                    .attr(\"x\",realx-0.5)\r\n                    .attr(\"y\",realy-0.5)\r\n                    .attr(\"width\",1)\r\n                    .attr(\"height\",1)\r\n                    .attr(\"class\",\"energyfieldrect\")\r\n                    .attr(\"fill\", function(){\r\n                        // if(value==-1){\r\n                        //     return \"red\"\r\n                        // }\r\n                        // if(value==-2){\r\n                        //     return \"green\"\r\n                        // }\r\n                        return colors[parseInt(k)]\r\n                    })\r\n                    .attr(\"opacity\",1)\r\n                    .attr(\"fieldvalue\",value)\r\n                    .on(\"mouseover\",function(d){\r\n\r\n                    })\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    drawBarrierMap(){\r\n        for(var k in this.catEnergyField){\r\n\r\n\r\n            let map=this.catEnergyField[k].barrierMap\r\n            for(let i=0;i<this.catEnergyField[k].height;i++){\r\n                for(let j=0;j<this.catEnergyField[k].width;j++){\r\n                    let realy=i+this.catEnergyField[k].y\r\n                    let realx=j+this.catEnergyField[k].x\r\n                    if(map[i][j]==3){\r\n                        drawRect(realx,realy,1,1,\"red\")\r\n                    }\r\n                    if(map[i][j]==4){\r\n                        drawRect(realx,realy,1,1,\"green\")\r\n                    }\r\n                    if(map[i][j]==1){\r\n                        drawRect(realx,realy,1,1,\"yellow\")\r\n                    }\r\n                    if(map[i][j]==2){\r\n                        drawRect(realx,realy,1,1,\"orange\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    drawBSpline(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            g.append(\"path\")\r\n                .style(\"fill\", color)\r\n                .style(\"stroke\",\"none\")\r\n                // .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 0.5)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0];\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1];\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', color)\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n    }\r\n\r\n    drawBSplineV2(lines,color){\r\n        var svg = d3.select(\"svg\")\r\n\r\n        g.append(\"path\")\r\n            .style(\"fill\", color)\r\n            .style(\"stroke\",\"none\")\r\n            // .style(\"stroke-width\", 0.5)\r\n            .style('opacity', 0.5)\r\n            .attr(\"d\", function () {\r\n                var p = \"\";\r\n                p += (d3.line()\r\n                        .x(function (dat) {\r\n                            return dat[0];\r\n                        })\r\n                        .y(function (dat) {\r\n                            return dat[1];\r\n                        })\r\n                )(lines)+ \"\";\r\n                return p;\r\n            })\r\n            .on('mouseover', function () {\r\n                d3.select(this)\r\n                    .style('stroke', \"red\")\r\n                    .style(\"stroke-width\", 3);\r\n            })\r\n            .on('mouseout', function () {\r\n                d3.select(this)\r\n                    .style('stroke', color)\r\n                    .style(\"stroke-width\", 0.5);\r\n            });\r\n\r\n    }\r\n\r\n    fillPolygonForEdge(Polygon, k, field, othercat){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n\r\n                //......\r\n                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                //d3.select('g').append('circle')\r\n                //    .attr('cx',realx)\r\n                //    .attr('cy',realy)\r\n                //    .attr('r',1)\r\n                //    .attr('fill','green')\r\n\r\n                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n\r\n                                let realx = fx * pixelGroup + this.catEnergyField[k].x\r\n                                let realy = fy * pixelGroup + this.catEnergyField[k].y\r\n\r\n                                //d3.select('g').append('circle')\r\n                                //    .attr('cx',realx)\r\n                                //    .attr('cy',realy)\r\n                                //    .attr('r',1)\r\n                                //    .attr('fill','green')\r\n\r\n                                let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                                if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                    // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    if(this.catEnergyField[k].finalField[fy][fx]==0&&this.catEnergyField[k].edgeBarrierMap[fy][fx]>0){\r\n                                        field[k][fy][fx]=this.catEnergyField[k].field[fy][fx]\r\n                                        //d3.select('g').append('circle')\r\n                                        //    .attr('cx',realx)\r\n                                        //    .attr('cy',realy)\r\n                                        //    .attr('r',1)\r\n                                        //    .attr('fill','blue')\r\n                                    }\r\n                                }\r\n\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    fillPolygon(Polygon,k,val,cut = false){\r\n\r\n        let n = Polygon.length;\r\n        let max_y = Number.MIN_VALUE;\r\n        let min_y = Number.MAX_VALUE;\r\n        let max_x = Number.MIN_VALUE;\r\n        let min_x = Number.MAX_VALUE;\r\n\r\n        //Node: x; dx; ymax;\r\n        let NET = {};\r\n        for(let i = 0; i < n; i ++){\r\n            let x1 = Polygon[i][0];\r\n            let y1 = Polygon[i][1];\r\n            let x2 = Polygon[(i + 1) % n][0];\r\n            let y2 = Polygon[(i + 1) % n][1];\r\n            max_y = Math.max(max_y,y1);\r\n            min_y = Math.min(min_y,y1);\r\n            max_x = Math.max(max_x,x1);\r\n            min_x = Math.min(min_x,x1);\r\n            if(parseInt(y1) == parseInt(y2)){\r\n                continue;\r\n            }\r\n            let tmpx;\r\n            if(y1 > y2){\r\n                tmpx = x2;\r\n            }\r\n            else{\r\n                tmpx = x1;\r\n            }\r\n            //tmpx = parseInt(tmpx);\r\n            let idx = parseInt(Math.min(y1, y2));\r\n            if(!NET.hasOwnProperty(idx)){\r\n                NET[idx] = []\r\n            }\r\n            NET[idx].push({x:tmpx, dx:(x2 - x1) / (y2 - y1), ymax:Math.max(y1,y2)});\r\n        }\r\n\r\n        //console.log(NET)\r\n        //for(var key in NET){\r\n        //    for(let j = 0; j < NET[key].length; j ++){\r\n        //        console.log(NET[key][j]);\r\n        //    }\r\n        //}\r\n\r\n        let AET = [];\r\n        for(let i = min_y; i < max_y; i ++){\r\n            let curi = parseInt(i);\r\n            if(NET.hasOwnProperty(curi)){\r\n                for(let j = 0; j < NET[curi].length; j ++){\r\n                    AET.push(NET[curi][j]);\r\n                }\r\n            }\r\n            AET.sort(function (a,b) {\r\n                if(Math.abs(a.x - b.x) > eps) return a.x < b.x;\r\n                if(Math.abs(a.dx - b.dx) > eps) return a.dx < b.dx;\r\n                return a.ymax < b.ymax;\r\n            })\r\n\r\n            let CurSize = AET.length;\r\n\r\n            //console.log(i)\r\n            //for(let j = 0; j < CurSize; j ++){\r\n            //    console.log(AET[j])\r\n            //}\r\n            //console.log(CurSize)\r\n            //console.log(\"AET\")\r\n            //for(let k = 0; k < CurSize; k ++){\r\n            //    console.log(AET[k].x)\r\n            //}\r\n\r\n            if(CurSize == 0){\r\n\r\n            }\r\n            else if(CurSize <= 1){\r\n                let fx = Math.ceil((AET[0].x - this.catEnergyField[k].x) / pixelGroup)\r\n                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                fx = Math.max(fx, 0);\r\n                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                fy = Math.max(fy, 0);\r\n                fx = parseInt(fx)\r\n                fy = parseInt(fy)\r\n                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                if(!cut){\r\n                    this.catEnergyField[k].field[fy][fx] = val;\r\n                }\r\n                this.updatedEnergyPoints[k].push([fx,fy])\r\n            }\r\n            else{\r\n\r\n                let p = [];\r\n                //document.write('before<br>')\r\n                for(let j = 0; j < CurSize; j ++){\r\n                    let P_1 = {};\r\n                    P_1.x = AET[j].x;\r\n                    P_1.y = AET[j].ymax;\r\n\r\n                    if(parseInt(P_1.y) == parseInt(i)){\r\n                        continue;\r\n                    }\r\n\r\n                    if(p.length == 0){\r\n                        p.push(P_1)\r\n                        //document.write(P_1.x + '<br>')\r\n                    }\r\n                    else if(p.length == 1){\r\n\r\n                        let P_2 = p[0];\r\n                        if(Math.abs(P_1.x - P_2.x) < eps){\r\n                            if(P_1.y > i && P_2.y > i){\r\n                                p.push(P_1);\r\n                                //document.write(P_1.x + '<br>')\r\n                            }\r\n                        }\r\n                        else{\r\n                            p.push(P_1);\r\n                            //document.write(P_1.x + '<br>')\r\n                        }\r\n\r\n                        if(p.length == 2){\r\n                            //document.write('start<br>')\r\n                            //console.log(\"before\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    document.write(p[k].x+ '<br>')\r\n                            //}\r\n                            let p_x1 = p.shift().x;\r\n                            let p_x2 = p.shift().x;\r\n                            let x_begin = Math.min(p_x1, p_x2);\r\n                            let x_end = Math.max(p_x1, p_x2);\r\n                            //console.log(\"after\")\r\n                            //for(let k = 0; k < p.length; k ++){\r\n                            //    console.log(p[k])\r\n                            //}\r\n                            x_begin = Math.max(x_begin, min_x)\r\n                            x_end = Math.min(x_end, max_x)\r\n                            while(x_begin < x_end){\r\n                                let fx = Math.ceil((x_begin - this.catEnergyField[k].x) / pixelGroup)\r\n                                let fy = Math.ceil((i - this.catEnergyField[k].y) / pixelGroup)\r\n                                fx = Math.min(fx, this.catEnergyField[k].width - 2);\r\n                                fx = Math.max(fx, 0);\r\n                                fy = Math.min(fy, this.catEnergyField[k].height - 2);\r\n                                fy = Math.max(fy, 0);\r\n                                fx = parseInt(fx);\r\n                                fy = parseInt(fy);\r\n                                //console.log((x_begin,i));\r\n                                //canvas[parseInt(x_begin)][parseInt(i)] = val;\r\n                                this.catEnergyField[k].finalField[fy][fx] = val;\r\n                                if(!cut){\r\n                                    this.catEnergyField[k].field[fy][fx] = val;\r\n                                }\r\n                                this.updatedEnergyPoints[k].push([fx,fy])\r\n                                x_begin ++;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let j = CurSize - 1; j >= 0; j --){\r\n                AET[j].x += AET[j].dx;\r\n                if(AET[j].ymax <= i){\r\n                    AET.splice(j,1);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /*\r\n        let newval = []\r\n        let bx1 = Number.MAX_VALUE\r\n        let bx2 = Number.MIN_VALUE\r\n        let by1 = Number.MAX_VALUE\r\n        let by2 = Number.MIN_VALUE\r\n\r\n\r\n        // smooth\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            bx1 = Math.min(bx1, sx)\r\n            bx2 = Math.max(bx2, sx)\r\n            by1 = Math.min(by1, sy)\r\n            by2 = Math.max(by2, sy)\r\n\r\n            let kernelsize = 3\r\n            let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n            let anchor = parseInt(kernelsize / 2)\r\n\r\n            let newvalue = 0\r\n\r\n            for (let i = 0; i < kernelsize; i ++){\r\n                for (let j = 0; j < kernelsize; j ++){\r\n                    let dy = i - anchor\r\n                    let dx = j - anchor\r\n                    let ny = sy + dy\r\n                    let nx = sx + dx\r\n                    if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                        newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                    }\r\n                }\r\n            }\r\n\r\n            newval.push(newvalue)\r\n\r\n        }\r\n\r\n        for(let i = 0; i < this.updatedEnergyPoints[k].length; i ++){\r\n            let sx = this.updatedEnergyPoints[k][i][0];\r\n            let sy = this.updatedEnergyPoints[k][i][1];\r\n            this.catEnergyField[k].finalField[sy][sx] = newval[i];\r\n        }\r\n        */\r\n\r\n        // remove unused inner outline\r\n\r\n        //for(let i = bx1; i <= bx2; i += 2){\r\n        //    for(let j = by1; j <= by2; j += 2){\r\n        //        //let meanval = 0;\r\n        //        let tmpidx = []\r\n        //        for(let nx = i; nx <= Math.min(i + 1, bx2); nx ++){\r\n        //            for(let ny = j; ny <= Math.min(j + 1, by2); ny ++){\r\n        //                nx = parseInt(nx);\r\n        //                ny = parseInt(ny);\r\n        //                this.catEnergyField[k].finalField[ny][nx] = val\r\n        //                //meanval += this.catEnergyField[k].finalField[ny][nx];\r\n        //                //tmpidx.push([nx, ny])\r\n        //            }\r\n        //        }\r\n        //        //if(tmpidx.length == 0){\r\n        //        //    continue;\r\n        //        //}\r\n        //        //meanval /= tmpidx.length\r\n        //        //for(let idx = 0; idx < tmpidx.length; idx ++){\r\n        //        //    this.catEnergyField[k].finalField[tmpidx[idx][1]][tmpidx[idx][0]] = meanval;\r\n        //        //}\r\n        //    }\r\n        //}\r\n\r\n\r\n        //this.drawEnergyField(k);\r\n\r\n    }\r\n\r\n    drawISOLinesV2(k,that,curdata){\r\n\r\n\r\n        for(let i = 0;i < 4;i ++){\r\n            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n        }\r\n        for(let i = 0;i < control_points[k].length; i ++){\r\n            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n            }\r\n        }\r\n        for(let i in control_points){\r\n            if(i == k){\r\n                continue;\r\n            }\r\n            d3.select(\"#path\"+i)\r\n                .attr('fill-opacity', 0.5)\r\n        }\r\n        is_selected[k]=false\r\n        that.editMode=false\r\n\r\n\r\n        colors = this.props.colorArray\r\n\r\n        editSeg[k] = []\r\n\r\n        let len;\r\n\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                            //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                       // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][0], control_points[k][j][(cur_idx - 1 + cur_len) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 3) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                let p1 = [ control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1] ]\r\n                                let p2 = [ control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1] ]\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                let r1_idx = 0\r\n                                let dis1 = Number.MAX_VALUE\r\n                                let r2_idx = totLen / 5\r\n                                let dis2 = Number.MAX_VALUE\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n\r\n                                    let tmpdis1 = calDistance(p1[0], p1[1], tmp_p.x, tmp_p.y)\r\n                                    let tmpdis2 = calDistance(p2[0], p2[1], tmp_p.x, tmp_p.y)\r\n\r\n                                    if(tmpdis1 < dis1){\r\n                                        r1_idx = p\r\n                                        dis1 = tmpdis1\r\n                                    }\r\n\r\n                                    if(tmpdis2 < dis2){\r\n                                        r2_idx = p\r\n                                        dis2 = tmpdis2\r\n                                    }\r\n\r\n                                    //tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                for(let p = r1_idx; p <= r2_idx; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                    //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n                //    .remove()\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        g.append(\"path\")\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                }\r\n                // .style(\"stroke-width\", 0.5);\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    reDraw(k,that,curdata){\r\n\r\n        colors = this.props.colorArray\r\n\r\n        let len = control_points[k].length;\r\n        let bounding = []\r\n\r\n        let bx1 = that.catEnergyField[k].boundingX;\r\n        let by1 = that.catEnergyField[k].boundingY;\r\n        let bx2 = that.catEnergyField[k].boundingX + that.catEnergyField[k].boundingWidth * pixelGroup - 5 * pixelGroup;\r\n        let by2 = that.catEnergyField[k].boundingY + that.catEnergyField[k].boundingHeight * pixelGroup - 5 * pixelGroup;\r\n\r\n        bounding.push({x:bx1, y:by1})\r\n        bounding.push({x:bx2, y:by1})\r\n        bounding.push({x:bx2, y:by2})\r\n        bounding.push({x:bx1, y:by2})\r\n\r\n        function dragstarted() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            //console.log(tmp_idx)\r\n            let isnum = parseInt(tmp_idx[6])\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                len = control_points[k][iidx].length;\r\n                //console.log(\"(\" + iidx + \", \" + jidx + \")\");\r\n\r\n                prepoints = [];\r\n                for(let i = 0; i < control_points[k].length; i ++){\r\n                    prepoints[i] = []\r\n                    for(let j = 0; j < control_points[k][i].length; j ++){\r\n                        prepoints[i].push([control_points[k][i][j][0],control_points[k][i][j][1]]);\r\n                    }\r\n                }\r\n\r\n                move_points = [];\r\n                move_points.push(jidx);\r\n                mid_point = 0\r\n\r\n                let v1 = [];\r\n                v1[0] = control_points[k][iidx][jidx][0];\r\n                v1[1] = control_points[k][iidx][jidx][1];\r\n\r\n                let v2 = [];\r\n                v2[0] = control_points[k][iidx][(jidx + 1) % len][0];\r\n                v2[1] = control_points[k][iidx][(jidx + 1) % len][1];\r\n\r\n                nearpts = [];\r\n                nearpts.push(v1);\r\n                nearpts.push(v2);\r\n\r\n                //console.log(\"before\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                /*\r\n                //multi points\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((jidx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n\r\n                if(calDistance(control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1],\r\n                    control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((jidx + 1) % len);\r\n                }\r\n\r\n                 */\r\n\r\n\r\n                //that.updateFinalField(idx,k,0)\r\n            }\r\n\r\n        }\r\n\r\n        function dragged(e) {\r\n\r\n            let execflag = false;\r\n            if(e.sourceEvent.target.attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            //console.log(e.sourceEvent.target.attributes.id)\r\n            let tmp_idx = e.sourceEvent.target.attributes.id.value.toString()\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            let ex = e.x;\r\n            let ey = e.y;\r\n\r\n            ex = Math.min(ex, bx2)\r\n            ex = Math.max(ex, bx1)\r\n            ey = Math.min(ey, by2)\r\n            ey = Math.max(ey, by1)\r\n\r\n            d3.select(this)\r\n                .attr('cx', ex)\r\n                .attr('cy', ey)\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                if(!control_points[k].hasOwnProperty(iidx)){\r\n                    return\r\n                }\r\n\r\n                len = control_points[k][iidx].length;\r\n                control_points[k][iidx][jidx][0] = ex;\r\n                control_points[k][iidx][jidx][1] = ey;\r\n\r\n                /*\r\n                //multi points\r\n                let dx = ex - control_points[k][iidx][jidx][0];\r\n                let dy = ey - control_points[k][iidx][jidx][1];\r\n                let w = 1;\r\n                for(let j = mid_point;j >= 0;j --){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n                w = 0.4;\r\n                for(let j = mid_point + 1;j < move_points.length; j ++){\r\n                    control_points[k][iidx][move_points[j]][0] += w * dx;\r\n                    control_points[k][iidx][move_points[j]][1] += w * dy;\r\n                    if(control_points[k][iidx][move_points[j]][0] > bx2){\r\n                        control_points[k][iidx][move_points[j]][0] = bx2;\r\n                    }\r\n                    if(control_points[k][iidx][move_points[j]][1] > by2){\r\n                        control_points[k][iidx][move_points[j]][1] = by2;\r\n                    }\r\n                    w *= 0.4;\r\n                }\r\n\r\n\r\n                for(let j = 0; j < move_points.length; j ++){\r\n                    if(j == mid_point){\r\n                        continue;\r\n                    }\r\n                    d3.select(\"#circle\" + k.toString() + \"i\" + iidx.toString() + \"i\" + move_points[j].toString())\r\n                        .attr('cx', control_points[k][iidx][move_points[j]][0])\r\n                        .attr('cy', control_points[k][iidx][move_points[j]][1])\r\n                }\r\n\r\n                let idx = move_points[0];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + len - 1) % len][0],control_points[k][iidx][(idx + len - 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.unshift((idx + len - 1) % len);\r\n                    mid_point ++\r\n                }\r\n                idx = move_points[move_points.length - 1];\r\n                if(calDistance(control_points[k][iidx][idx][0],control_points[k][iidx][idx][1],\r\n                    control_points[k][iidx][(idx + 1) % len][0],control_points[k][iidx][(idx + 1) % len][1]) > control_points[k][iidx].meandis){\r\n                    move_points.push((idx + 1) % len);\r\n                }\r\n                 */\r\n\r\n                //let drawPathData=\"\";\r\n//\r\n                //for(let j = 0;j < control_points[k].length; j ++){\r\n                //    drawPathData += lineFunction(control_points[k][j]);\r\n                //}\r\n//\r\n                //g.append(\"path\")\r\n                //    .attr('id', \"temp_path\")\r\n                //    .attr('d', drawPathData)\r\n                //    .attr(\"fill\", \"none\")\r\n//\r\n                //let tmpPath = d3.select(\"#temp_path\").node()\r\n                //let totLen = tmpPath.getTotalLength()\r\n//\r\n                //let reDrawData = []\r\n                //let pointsnum = totLen\r\n//\r\n                //for(let idx = 0;idx < pointsnum;idx ++){\r\n                //    let p = tmpPath.getPointAtLength(idx)\r\n                //    reDrawData.push([p.x, p.y])\r\n                //}\r\n//\r\n                //console.log(\"reDrawData:\")\r\n                //console.log(reDrawData)\r\n                let reDrawData = \"\"\r\n                for(let j = 0;j < control_points[k].length; j ++){\r\n\r\n                    if(j == iidx){\r\n\r\n                        let cur_len = control_points[k][j].length\r\n                        let tmp_pts = []\r\n                        //let s_pts = []\r\n\r\n                        // select one or more point for interpolation\r\n                        //for(let p = 1; p >= 1; p --){\r\n                        let q = (jidx - 1 + cur_len) % cur_len\r\n                        editSeg[k].push(q)\r\n                        //s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        // }\r\n                        //editSeg[k].push(jidx)\r\n                        //s_pts.push([control_points[k][j][jidx][0], control_points[k][j][jidx][1]])\r\n                        //for(let p = 1; p <= 1; p ++){\r\n                        //    let q = (jidx + p) % cur_len\r\n                        //    s_pts.push([control_points[k][j][q][0], control_points[k][j][q][1]])\r\n                        //}\r\n\r\n                        //let spline1 = new BSpline(s_pts, 3)\r\n                        //for(let t = 0; t < 1; t += 0.01){\r\n                        //    // TODO : re-locate neighbor control points around the dragged point\r\n                        //    tmp_pts.push(spline1.calcAt(t))\r\n                        //}\r\n\r\n                        /*\r\n                        let ra = 0.1\r\n                        for(let idx = -2;idx <= 2;idx ++){\r\n                            if(idx == 0){\r\n                                continue\r\n                            }\r\n                            let p = tmpPath.getPointAtLength( ra * totLen )\r\n                            let q = (jidx + idx + cur_len) % cur_len\r\n                            ra += 0.2\r\n                            //control_points[k][j][q][0] = p.x\r\n                            //control_points[k][j][q][1] = p.y\r\n                            //d3.select(\"#circle\"+ k.toString() + \"i\" + j.toString() + \"i\" + q.toString())\r\n                            //    .attr(\"cx\",control_points[k][j][q][0])\r\n                            //    .attr(\"cy\",control_points[k][j][q][1])\r\n                        }\r\n                        */\r\n\r\n                        //let new_points = []\r\n\r\n                        //console.log(\"modify points\")\r\n                        //console.log(new_points.length)\r\n\r\n                        editSeg[k].sort(function(a,b){\r\n                            return a - b\r\n                        })\r\n\r\n                        let tmpDict = {}\r\n                        for(let e = 0; e < editSeg[k].length; e ++){\r\n                            tmpDict[editSeg[k][e]] = 1\r\n                        }\r\n\r\n                        let sid\r\n                        if(editSeg[k].length > 0){\r\n                            sid = editSeg[k][0]\r\n                        }\r\n                        else{\r\n                            sid = 0\r\n                        }\r\n\r\n                        for(let p = 0; p < cur_len; p ++){\r\n                            // start from sid\r\n                            let cur_idx = (sid + p) % cur_len\r\n                            if(tmpDict.hasOwnProperty(cur_idx)){\r\n\r\n                                let s_pts = []\r\n                                s_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 1) % cur_len][0], control_points[k][j][(cur_idx + 1) % cur_len][1]])\r\n                                s_pts.push([control_points[k][j][(cur_idx + 2) % cur_len][0], control_points[k][j][(cur_idx + 2) % cur_len][1]])\r\n\r\n                                d3.select(\"svg\").append(\"path\")\r\n                                    .attr(\"id\",\"temp_path\")\r\n                                    .attr(\"d\",lineFunction_reDraw(s_pts))\r\n                                    .attr(\"fill\",\"none\")\r\n\r\n                                let tmpPath = d3.select(\"#temp_path\").node()\r\n                                let totLen = tmpPath.getTotalLength()\r\n\r\n                                for(let p = 0; p <= totLen / 5 ; p ++){\r\n                                    let tmp_p = tmpPath.getPointAtLength(5 * p)\r\n                                    tmp_pts.push([tmp_p.x, tmp_p.y])\r\n                                }\r\n\r\n                                d3.select(\"#temp_path\").remove()\r\n\r\n                                p ++\r\n                            }\r\n                            else{\r\n                                tmp_pts.push([control_points[k][j][cur_idx][0], control_points[k][j][cur_idx][1]])\r\n                            }\r\n                        }\r\n\r\n                        //console.log(tmp_pts)\r\n                        reDrawData += lineFunction(tmp_pts)\r\n\r\n                    }\r\n                    else{\r\n                        //console.log(control_points[k][j])\r\n                        reDrawData += lineFunction(control_points[k][j]);\r\n                    }\r\n\r\n                }\r\n\r\n                that.reDraw(k, that, reDrawData)\r\n\r\n                //d3.select(\"#temp_path\").remove()\r\n\r\n            }\r\n\r\n        }\r\n\r\n        function dragended() {\r\n\r\n            let execflag = false;\r\n            if(d3.select(this)._groups[0][0].attributes.hasOwnProperty(\"id\")){\r\n                execflag = true;\r\n            }\r\n            if(execflag == false){\r\n                return;\r\n            }\r\n\r\n            let tmp_idx = d3.select(this)._groups[0][0].attributes.id.value;\r\n            let isnum = parseInt(tmp_idx[6])\r\n\r\n            if(isnum >= 0 && isnum <= 9){\r\n\r\n                let iidx = \"\"\r\n                let jidx = \"\"\r\n\r\n                for(let i = 7;i < tmp_idx.length;i ++){\r\n                    if(tmp_idx[i] == \"i\"){\r\n                        i ++;\r\n                        while(tmp_idx[i] != \"i\"){\r\n                            iidx += tmp_idx[i++];\r\n                        }\r\n                        i ++;\r\n                        while(i < tmp_idx.length){\r\n                            jidx += tmp_idx[i++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                iidx = parseInt(iidx);\r\n                jidx = parseInt(jidx);\r\n\r\n                let Polygon = []\r\n                let len = control_points[k][iidx].length;\r\n\r\n                Polygon.push([control_points[k][iidx][(jidx + len - 1) % len][0],control_points[k][iidx][(jidx + len - 1) % len][1]])\r\n                Polygon.push([prepoints[iidx][jidx][0],prepoints[iidx][jidx][1]])\r\n                Polygon.push([control_points[k][iidx][(jidx + 1) % len][0],control_points[k][iidx][(jidx + 1) % len][1]])\r\n                Polygon.push([control_points[k][iidx][jidx][0],control_points[k][iidx][jidx][1]])\r\n\r\n                //for(let j = 0 ; j < move_points.length; j ++){\r\n                //    Polygon.push([control_points[k][iidx][move_points[j]][0],control_points[k][iidx][move_points[j]][1]]);\r\n                //}\r\n                //for(let j = move_points.length - 1; j >= 0; j --){\r\n                //    Polygon.push([prepoints[iidx][move_points[j]][0],prepoints[iidx][move_points[j]][1]]);\r\n                //}\r\n\r\n                let v3 = control_points[k][iidx][jidx];\r\n                nearpts.push(v3);\r\n\r\n                //console.log(\"after\")\r\n                //for(let j = 0;j < nearpts.length; j ++){\r\n                //    console.log(nearpts[j])\r\n                //}\r\n\r\n                let vec1 = [nearpts[1][0] - nearpts[0][0],nearpts[1][1] - nearpts[0][1]];\r\n                let vec2 = [nearpts[2][0] - nearpts[0][0],nearpts[2][1] - nearpts[0][1]];\r\n                let is_outer = vec1[0] * vec2[1] - vec2[0] * vec1[1];\r\n                let val = 0;\r\n                if(is_outer <= 0){\r\n                    //console.log(\"move out\")\r\n                    if(iidx == 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                else{\r\n                    //console.log(\"move in\")\r\n                    if(iidx > 0){\r\n                        val = 10;\r\n                    }\r\n                }\r\n                // drawPolygon(Polygon,0,0,\"red\")\r\n                that.fillPolygon(Polygon, k, val)\r\n\r\n                //that.drawEnergyField(k);\r\n                //\r\n                //that.updateFinalField(idx,k,1)\r\n            }\r\n\r\n        }\r\n\r\n        d3.select(\"#path\"+k)\r\n            .attr('id',\"path\"+k)\r\n            .attr('d',curdata)\r\n            .attr(\"fill\", colors[k])\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill-rule',\"evenodd\")\r\n            .style('stroke', colors[k])\r\n            .style(\"stroke-width\", 1)\r\n            .on('mouseover', function () {\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                }\r\n            })\r\n            .on('mouseout', function () {\r\n\r\n                if(!that.editMode){\r\n                    d3.select(this)\r\n                        .style('stroke', colors[k])\r\n                        .style(\"stroke-width\", 1)\r\n                    // .style(\"stroke-width\", 0.5);\r\n                }\r\n\r\n\r\n            })\r\n            .on('mousedown',function (e){\r\n                if(e.button==2){\r\n                    if(is_selected[k]==false&&!that.editMode){\r\n                        that.editMode=true\r\n\r\n                        for(let i = 0;i < 4;i ++){\r\n                            g.append(\"line\")\r\n                                .attr('id',\"bounding\"+ k.toString() + i.toString())\r\n                                .attr(\"x1\", bounding[i].x)\r\n                                .attr(\"y1\", bounding[i].y)\r\n                                .attr(\"x2\", bounding[(i+1)%4].x)\r\n                                .attr(\"y2\", bounding[(i+1)%4].y)\r\n                                .attr(\"stroke\", \"red\")\r\n                                .attr(\"stroke-width\", \"1px\");\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.2)\r\n                        }\r\n\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                g.append(\"circle\")\r\n                                    .attr(\"id\",\"circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString())\r\n                                    .attr(\"cx\",control_points[k][i][j][0])\r\n                                    .attr(\"cy\",control_points[k][i][j][1])\r\n                                    .attr(\"r\",3)\r\n                                    .attr(\"fill\",'red')\r\n                                    .attr('fill-opacity', 0.5)\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"red\")\r\n                                            .attr(\"stroke-width\",2)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"stroke\",\"none\")\r\n                                            .attr(\"stroke-width\",1)\r\n                                    })\r\n                                    .call(d3.drag()\r\n                                        .on(\"start\", dragstarted)\r\n                                        .on(\"drag\", dragged)\r\n                                        .on(\"end\", dragended))\r\n                            }\r\n                        }\r\n                        is_selected[k]=true;\r\n                    }\r\n\r\n                    else if(that.editMode&&is_selected[k]){\r\n                        for(let i = 0;i < 4;i ++){\r\n                            d3.select(\"#bounding\"+ k.toString() + i.toString()).remove();\r\n                        }\r\n                        for(let i = 0;i < control_points[k].length; i ++){\r\n                            for(let j = 0;j < control_points[k][i].length; j ++){\r\n                                d3.select(\"#circle\" + k.toString() + \"i\" + i.toString() + \"i\" + j.toString()).remove();\r\n                            }\r\n                        }\r\n                        for(let i in control_points){\r\n                            if(i == k){\r\n                                continue;\r\n                            }\r\n                            d3.select(\"#path\"+i)\r\n                                .attr('fill-opacity', 0.5)\r\n                        }\r\n                        is_selected[k]=false;\r\n                        that.editMode=false\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n    drawOutline(points,color){\r\n\r\n        let SetAreas = new Array();\r\n\r\n        var lineFunction = d3.line()\r\n            .x(function(d) { return d[0]; })\r\n            .y(function(d) { return d[1]; })\r\n            .curve(d3.curveCardinalClosed);\r\n\r\n        let pointpath=lineFunction(points);\r\n\r\n        g.append('path')\r\n            .attr('d', pointpath)\r\n            .attr('fill-opacity', 0.5)\r\n            .attr('fill',color)\r\n            .attr('fill-rule',\"evenodd\");\r\n    }\r\n\r\n    drawISOLines(lines, intervals,dx,dy,color) {\r\n\r\n        var marginBottomLabel = 0;\r\n\r\n\r\n\r\n        var svg = d3.select(\"svg\")\r\n\r\n        for (let i=0;i<lines.length;i++){\r\n            g.append(\"path\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\",color)\r\n                .style(\"stroke-width\", 0.5)\r\n                .style('opacity', 1.0)\r\n                .attr(\"d\", function () {\r\n                    var p = \"\";\r\n                    p += (d3.line()\r\n                            .x(function (dat) {\r\n                                return dat[0]+dx;\r\n                            })\r\n                            .y(function (dat) {\r\n                                return dat[1]+dy;\r\n                            })\r\n                    )(lines[i])+ \"\";\r\n                    return p;\r\n                })\r\n                .on('mouseover', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"red\")\r\n                        .style(\"stroke-width\", 3);\r\n                })\r\n                .on('mouseout', function () {\r\n                    d3.select(this)\r\n                        .style('stroke', \"black\")\r\n                        .style(\"stroke-width\", 0.5);\r\n                });\r\n        }\r\n\r\n\r\n    }\r\n\r\n    calOneISOLine(intervals,k){\r\n\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n            let data=this.catEnergyField[k].finalField\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n        return isoLines[0]\r\n    }\r\n\r\n    calISOLine(intervals, fieldData){\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n\r\n            // if(k!=\"1\"){\r\n            //     continue\r\n            // }\r\n\r\n\r\n            let data=fieldData[k]\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(data,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            // this.drawISOLines(isoLines,intervals,dx,dy)\r\n\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n        return isoLineDict\r\n    }\r\n\r\n    BSplineInterpolate(points){\r\n        let tpoints=[]\r\n        let splinePoints=[]\r\n        let gap=5\r\n        for (let i=0;i<points.length;i++){\r\n            let remainLength=points.length-i\r\n\r\n            if(remainLength>gap){\r\n                if(i%gap==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n                if(i>0&&i%(3*gap)==0){\r\n                    var spline = new BSpline(tpoints,3)\r\n                    for(var t = 0.01;t<=1;t+=0.01){\r\n                        var p = spline.calcAt(t);\r\n                        splinePoints.push(p)\r\n                    }\r\n                    tpoints=[]\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n            else{\r\n                if(i%3==0){\r\n                    tpoints.push(points[i])\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        var spline = new BSpline(tpoints,3)\r\n        for(var t = 0.01;t<=1;t+=0.01){\r\n            var p = spline.calcAt(t);\r\n            splinePoints.push(p)\r\n        }\r\n\r\n\r\n        return splinePoints\r\n    }\r\n\r\n    normalizeKernel(kernel){\r\n        let sum=0\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                sum+=kernel[i][j]\r\n            }\r\n        }\r\n\r\n        for(let i=0;i<kernel.length;i++){\r\n            for(let j=0;j<kernel.length;j++){\r\n                kernel[i][j]=kernel[i][j]/sum\r\n            }\r\n        }\r\n        return kernel\r\n    }\r\n\r\n    getGaussianKernel(theta,kernelsize){\r\n        let scale=1\r\n        let kernel=[]\r\n        for (let i=0;i<kernelsize;i++){\r\n            kernel.push([])\r\n            for (let j=0;j<kernelsize;j++){\r\n                kernel[i].push(0)\r\n            }\r\n        }\r\n        let anchor=parseInt(kernelsize/2)/scale\r\n        let C=1/(Math.PI*2*theta*theta)\r\n\r\n        for (let i=0;i<kernelsize;i++){\r\n            for (let j=0;j<kernelsize;j++){\r\n                let ny=i/scale\r\n                let nx=j/scale\r\n                let y=Math.pow(ny-anchor,2)\r\n                let x=Math.pow(nx-anchor,2)\r\n                kernel[i][j]=C*Math.exp(-(x*x+y*y)/(2*theta*theta))\r\n            }\r\n        }\r\n\r\n        kernel=this.normalizeKernel(kernel)\r\n        return kernel\r\n    }\r\n\r\n    checkSingularPoint(k,x,y){\r\n        let delta=1\r\n        let field=this.catEnergyField[k].finalField\r\n        let isSingular=true\r\n        //right\r\n        if(x+delta<this.catEnergyField[k].width){\r\n            if(field[y][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left\r\n        if(x-delta>0){\r\n            if(field[y][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //up\r\n        if(y-delta>0){\r\n            if(field[y-delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //down\r\n        if(y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-top\r\n        if(x+delta<this.catEnergyField[k].width&&y-delta>0){\r\n            if(field[y-delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //right-bottom\r\n        if(x+delta<this.catEnergyField[k].width&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x+delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-top\r\n        if(x-delta>0&&y-delta>0){\r\n            if(field[y-delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n        //left-bottom\r\n        if(x-delta>0&&y+delta<this.catEnergyField[k].height){\r\n            if(field[y+delta][x-delta]>0){\r\n                isSingular=false\r\n            }\r\n        }\r\n\r\n        return isSingular\r\n    }\r\n\r\n    fillCrossingEdge_Part(edges){\r\n\r\n\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<edges.length;i++){\r\n            let cat1=edges[i].cat\r\n            let start1=this.pointData[edges[i].start]\r\n            let end1=this.pointData[edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual && edges[i].virtrualNodes.length > 0){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:edges[i].virtrualNodes[0][0],y:edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:edges[i].virtrualNodes[v][0],y:edges[i].virtrualNodes[v][1]},{x:edges[i].virtrualNodes[v+1][0],y:edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:edges[i].virtrualNodes[vlength-1][0],y:edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=0;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual && this.edges[j].virtrualNodes.length > 0){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    rightstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                            let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                            // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                            if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                    leftstop=true\r\n                                    break\r\n                                }\r\n                            }\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    fillCrossingEdge(){\r\n\r\n        //return\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].edgeCrossingList=[]\r\n        }\r\n\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let cat1=this.edges[i].cat\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            let linesToCheck1=[]\r\n            if(this.edges[i].virtrual){\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:this.edges[i].virtrualNodes[0][0],y:this.edges[i].virtrualNodes[0][1]}])\r\n                for (let v=0;v<this.edges[i].virtrualNodes.length;v++){\r\n                    if(v+1<this.edges[i].virtrualNodes.length){\r\n                        linesToCheck1.push([{x:this.edges[i].virtrualNodes[v][0],y:this.edges[i].virtrualNodes[v][1]},{x:this.edges[i].virtrualNodes[v+1][0],y:this.edges[i].virtrualNodes[v+1][1]}])\r\n                    }\r\n                }\r\n                let vlength=this.edges[i].virtrualNodes.length\r\n                linesToCheck1.push([{x:this.edges[i].virtrualNodes[vlength-1][0],y:this.edges[i].virtrualNodes[vlength-1][1]},{x:end1.x,y:end1.y}])\r\n            }\r\n            else{\r\n                linesToCheck1.push([{x:start1.x,y:start1.y},{x:end1.x,y:end1.y}])\r\n            }\r\n            for(let j=i+1;j<this.edges.length;j++){\r\n                let cat2=this.edges[j].cat\r\n                if(cat1==cat2){\r\n                    continue\r\n                }\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                let linesToCheck2=[]\r\n                if(this.edges[j].virtrual){\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:this.edges[j].virtrualNodes[0][0],y:this.edges[j].virtrualNodes[0][1]}])\r\n                    for (let v=0;v<this.edges[j].virtrualNodes.length;v++){\r\n                        if(v+1<this.edges[j].virtrualNodes.length){\r\n                            linesToCheck2.push([{x:this.edges[j].virtrualNodes[v][0],y:this.edges[j].virtrualNodes[v][1]},{x:this.edges[j].virtrualNodes[v+1][0],y:this.edges[j].virtrualNodes[v+1][1]}])\r\n                        }\r\n                    }\r\n                    let vlength=this.edges[j].virtrualNodes.length\r\n                    linesToCheck2.push([{x:this.edges[j].virtrualNodes[vlength-1][0],y:this.edges[j].virtrualNodes[vlength-1][1]},{x:end2.x,y:end2.y}])\r\n                }\r\n                else{\r\n                    linesToCheck2.push([{x:start2.x,y:start2.y},{x:end2.x,y:end2.y}])\r\n                }\r\n\r\n                for(let l1=0;l1<linesToCheck1.length;l1++){\r\n                    let start1=linesToCheck1[l1][0]\r\n                    let end1=linesToCheck1[l1][1]\r\n                    for (let l2=0;l2<linesToCheck2.length;l2++){\r\n                        let start2=linesToCheck2[l2][0]\r\n                        let end2=linesToCheck2[l2][1]\r\n                        let crossInfo=this.checkEdgeCrossing(start1,end1,start2,end2)\r\n                        if(crossInfo[0]){\r\n                            this.catEnergyField[cat1].edgeCrossingList.push([crossInfo[1],i,j,linesToCheck1[l1],linesToCheck2[l2]])\r\n                            this.catEnergyField[cat2].edgeCrossingList.push([crossInfo[1],j,i,linesToCheck2[l2],linesToCheck1[l1]])\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let newFieldDict={}\r\n\r\n        for(var k in this.catEnergyField){\r\n\r\n            newFieldDict[k]=this.catEnergyField[k].finalField\r\n            let crossingPoints=this.catEnergyField[k].edgeCrossingList\r\n            let fillPoints=[]\r\n            let fillArea=[]\r\n            let stopGap=5\r\n            //var beginTime1 = +new Date()\r\n            for(let i=0;i<crossingPoints.length;i++){\r\n                fillArea.push([])\r\n                let crosspoint=crossingPoints[i][0]\r\n                let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                let line=crossingPoints[i][3]\r\n                let crossline=crossingPoints[i][4]\r\n                let thiscat=k\r\n                // let othercat=this.edges[otherid].cat\r\n                let flag=false\r\n                let newpoints=[]\r\n\r\n                // if(k==\"2\"&&othercat==\"0\"&&i==4){\r\n                //     flag=true\r\n                // }\r\n\r\n                //if(k==\"0\"){\r\n                    // drawLine([line[0].x,line[0].y],[line[1].x,line[1].y],\"black\")\r\n                    // drawLine([crossline[0].x,crossline[0].y],[crossline[1].x,crossline[1].y],\"black\")\r\n\r\n                //}\r\n\r\n\r\n                let dl=0\r\n                let lineLength=calDistance(line[0].x,line[0].y,line[1].x,line[1].y)\r\n                let vec1=[line[1].x-line[0].x,line[1].y-line[0].y]\r\n\r\n                let vec2=[vec1[1],-1*vec1[0]]\r\n                let vec3=[crossline[1].x-crossline[0].x,crossline[1].y-crossline[0].y]\r\n\r\n                let linedirvec=normalizeVec(vec1)\r\n                let normdirvec=normalizeVec(vec3)\r\n                let step=0.5\r\n                // console.log(lineLength)\r\n\r\n\r\n                let topBoundPoints=[]\r\n                let bottomBoundPoints=[]\r\n                let lastTop=[]\r\n                let lastBottom=[]\r\n                let rightstop=false\r\n                let topstop=false\r\n                let bottomstop=false\r\n\r\n                //right\r\n                while(dl<edgeR1){\r\n\r\n                    if(rightstop){\r\n                        break\r\n                    }\r\n                    let newanchor1=[crosspoint.x+dl*normdirvec[0],crosspoint.y+dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!rightstop&&!topstop){\r\n                            let newpointtop=[newanchor1[0]+linedirvec[0]*disalongline,newanchor1[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // if(flag){\r\n                                //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                //     console.log()\r\n                                // }\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!rightstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!rightstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor1[0]-linedirvec[0]*disalongline,newanchor1[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n\r\n                            for (var k2 in this.catEdgeDict) {\r\n                                let othercat = k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        rightstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n\r\n                            }\r\n                            /*                            if(!bottomstop&&!rightstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n                let fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n                topBoundPoints=[]\r\n                bottomBoundPoints=[]\r\n                lastTop=[]\r\n                lastBottom=[]\r\n                let leftstop=false\r\n                topstop=false\r\n                bottomstop=false\r\n                dl=0\r\n                //left\r\n                while(dl<edgeR1){\r\n\r\n                    if(leftstop){\r\n                        break\r\n                    }\r\n                    let newanchor2=[crosspoint.x-dl*normdirvec[0],crosspoint.y-dl*normdirvec[1]]\r\n\r\n                    let disalongline=0\r\n\r\n                    let topfind=false\r\n                    let bottomfind=false\r\n\r\n                    let topFindPoints=[]\r\n                    let bottomFindPoints=[]\r\n\r\n\r\n                    while(disalongline<lineLength/2){\r\n                        //top\r\n                        if(!topfind&&!leftstop&&!topstop){\r\n                            let newpointtop=[newanchor2[0]+linedirvec[0]*disalongline,newanchor2[1]+linedirvec[1]*disalongline]\r\n                            let newxtop=Math.floor((newpointtop[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newytop=Math.floor((newpointtop[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            for(var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointtop[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointtop[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxtop>0&&newxtop<this.catEnergyField[k].width&&newytop>0&&newytop<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newytop][newxtop]>0){\r\n                                // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                topfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newytop][newxtop]!=4){\r\n                                    if(lastTop.length==0){\r\n                                        topBoundPoints.push([newxtop,newytop])\r\n                                        lastTop=[newxtop,newytop]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastTop[0]-newxtop)<=stopGap&&Math.abs(lastTop[1]-newytop)<=stopGap){\r\n\r\n                                            lastTop=[newxtop,newytop]\r\n                                            topBoundPoints.push([newxtop,newytop])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastTop[0]+this.catEnergyField[k].x,lastTop[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            topstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    topBoundPoints.push([newxtop,newytop])\r\n                                    // lastTop=[newxtop,newytop]\r\n                                }\r\n                            }\r\n\r\n                            /*                            if(!topstop&&!leftstop){\r\n                                                            topFindPoints.push([newpointtop[0],newpointtop[1],othercat])\r\n                                                            if(topfind){\r\n                                                                fillPoints=fillPoints.concat(topFindPoints)\r\n                                                                topFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        //bottom\r\n                        if(!bottomfind&&!leftstop&&!bottomstop){\r\n                            let newpointbottom=[newanchor2[0]-linedirvec[0]*disalongline,newanchor2[1]-linedirvec[1]*disalongline]\r\n                            let newxbottom=Math.floor((newpointbottom[0]-this.catEnergyField[k].x)/pixelGroup)\r\n                            let newybottom=Math.floor((newpointbottom[1]-this.catEnergyField[k].y)/pixelGroup)\r\n\r\n                            // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                            for (var k2 in this.catEdgeDict){\r\n                                let othercat=k2\r\n                                let otherx=Math.floor((newpointbottom[0]-this.catEnergyField[othercat].x)/pixelGroup)\r\n                                let othery=Math.floor((newpointbottom[1]-this.catEnergyField[othercat].y)/pixelGroup)\r\n                                // drawRect(newpointtop[0],newpointtop[1],1,1,\"red\")\r\n                                if(otherx>0&&otherx<this.catEnergyField[othercat].width&&othery>0&&othery<this.catEnergyField[othercat].height){\r\n                                    if(this.catEnergyField[othercat].pointBarrierMap[othery][otherx]==3){\r\n                                        leftstop=true\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if(newxbottom>0&&newxbottom<this.catEnergyField[k].width&&newybottom>0&&newybottom<this.catEnergyField[k].height&&this.catEnergyField[k].finalField[newybottom][newxbottom]>0){\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],1,1,\"red\")\r\n                                // drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n\r\n                                bottomfind=true\r\n                                if(this.catEnergyField[k].edgeBarrierMap[newybottom][newxbottom]!=4){\r\n                                    if(lastBottom.length==0){\r\n                                        bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        lastBottom=[newxbottom,newybottom]\r\n                                    }\r\n                                    else{\r\n                                        if(Math.abs(lastBottom[0]-newxbottom)<=stopGap&&Math.abs(lastBottom[1]-newybottom)<=stopGap){\r\n\r\n                                            lastBottom=[newxbottom,newybottom]\r\n                                            bottomBoundPoints.push([newxbottom,newybottom])\r\n                                        }\r\n                                        else{\r\n                                            // if(flag){\r\n                                            //     drawRect(newpointbottom[0],newpointbottom[1],0.2,0.2,\"red\")\r\n                                            //     drawRect(lastBottom[0]+this.catEnergyField[k].x,lastBottom[1]+this.catEnergyField[k].y,0.2,0.2,\"blue\")\r\n                                            //     console.log()\r\n                                            // }\r\n\r\n                                            // drawRect(newpointtop[0],newpointtop[1],0.2,0.2,\"blue\")\r\n                                            // console.log(\"1\")\r\n                                            bottomstop=true\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else{\r\n                                    bottomBoundPoints.push([newxbottom,newybottom])\r\n                                    // lastBottom=[newxbottom,newybottom]\r\n                                }\r\n                            }\r\n                            /*                            if(!bottomstop&&!leftstop){\r\n                                                            bottomFindPoints.push([newpointbottom[0],newpointbottom[1],othercat])\r\n                                                            if(bottomfind){\r\n                                                                fillPoints=fillPoints.concat(bottomFindPoints)\r\n                                                                bottomFindPoints=[]\r\n                                                            }\r\n                                                        }*/\r\n                        }\r\n\r\n                        if(topfind&&bottomfind||topstop&&bottomstop){\r\n                            break\r\n                        }\r\n\r\n                        disalongline+=step\r\n\r\n                    }\r\n\r\n                    dl+=step\r\n                }\r\n\r\n\r\n                fillPolyPoints=[[Math.floor((crosspoint.x-this.catEnergyField[k].x)/pixelGroup),Math.floor((crosspoint.y-this.catEnergyField[k].y)/pixelGroup)]]\r\n                for(let p=0;p<topBoundPoints.length;p++){\r\n                    fillPolyPoints.push(topBoundPoints[p])\r\n                }\r\n\r\n                for(let p=bottomBoundPoints.length-1;p>=0;p--){\r\n                    fillPolyPoints.push(bottomBoundPoints[p])\r\n                }\r\n\r\n                fillArea[i].push(fillPolyPoints)\r\n\r\n\r\n                // drawRect(crosspoint.x,crosspoint.y,1,1,\"red\")\r\n            }\r\n            //var endTime1 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop1 \" + (endTime1 - beginTime1) + \" ms\")\r\n            // console.log(fillArea)\r\n\r\n            /*            for(let i=0;i<fillPoints.length;i++){\r\n                            let realx=fillPoints[i][0]\r\n                            let realy=fillPoints[i][1]\r\n                            let othercat=fillPoints[i][2]\r\n                            let relativex=Math.floor(realx-this.catEnergyField[k].x)\r\n                            let relativey=Math.floor(realy-this.catEnergyField[k].y)\r\n                            let relativeotherx=Math.floor(realx-this.catEnergyField[othercat].x)\r\n                            let relativeothery=Math.floor(realy-this.catEnergyField[othercat].y)\r\n                            if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                                if(this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                                    // drawRect(realx,realy,0.2,0.2,\"red\")\r\n                                    newFieldDict[k][relativey][relativex]=this.catEnergyField[k].field[relativey][relativex]\r\n                                }\r\n                            }\r\n                        }*/\r\n\r\n            //var beginTime2 = +new Date()\r\n\r\n            //console.log(\"fill area: \")\r\n            //console.log(fillArea)\r\n\r\n            for (let i=0;i<fillArea.length;i++){\r\n                //let thisid=crossingPoints[i][1]\r\n                let otherid=crossingPoints[i][2]\r\n                //let thiscat=this.edges[thisid].cat\r\n                let othercat=this.edges[otherid].cat\r\n                let dx=this.catEnergyField[k].x\r\n                let dy=this.catEnergyField[k].y\r\n\r\n                //let startx=Math.floor((this.edges[thisid].x-edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let endx=Math.ceil((this.edges[thisid].x+this.edges[thisid].width+edgeR1-this.catEnergyField[k].x)/pixelGroup)\r\n                //let starty=Math.floor((this.edges[thisid].y-edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n                //let endy=Math.ceil((this.edges[thisid].y+this.edges[thisid].height+edgeR1-this.catEnergyField[k].y)/pixelGroup)\r\n//\r\n                //startx = Math.max(0, startx)\r\n                //endx = Math.min(this.catEnergyField[k].width, endx)\r\n                //starty = Math.max(0, starty)\r\n                //endy = Math.min(this.catEnergyField[k].height, endy)\r\n\r\n                for(let a = 0; a < fillArea[i].length; a ++){\r\n                    //if(a==0){\r\n                    for(let b = 0; b < fillArea[i][a].length; b ++){\r\n                        fillArea[i][a][b][0] = fillArea[i][a][b][0] * pixelGroup + dx\r\n                        fillArea[i][a][b][1] = fillArea[i][a][b][1] * pixelGroup + dy\r\n                    }\r\n                    //    d3.select('g').append(\"path\")\r\n                    //        .attr('d',lineFunction(fillArea[i][a]))\r\n                    //        .attr(\"fill\", 'none')\r\n                    //        .style('stroke', \"black\")\r\n                    //        .style(\"stroke-width\", 1)\r\n                    //        .on('mouseover', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"red\")\r\n                    //                .style(\"stroke-width\", 2);\r\n                    //        })\r\n                    //        .on('mouseout', function () {\r\n                    //            d3.select(this)\r\n                    //                .style('stroke', \"black\")\r\n                    //                .style(\"stroke-width\", 1);\r\n                    //        });\r\n\r\n                    //}\r\n\r\n                    this.fillPolygonForEdge(fillArea[i][a], k, newFieldDict, othercat)\r\n                }\r\n\r\n\r\n                /*\r\n                for(let y=starty;y<endy;y++){\r\n                    for (let x=startx;x<endx;x++){\r\n                        let realx=x*pixelGroup+this.catEnergyField[k].x\r\n                        let realy=y*pixelGroup+this.catEnergyField[k].y\r\n\r\n                        let relativeotherx=Math.floor((realx-this.catEnergyField[othercat].x)/pixelGroup)\r\n                        let relativeothery=Math.floor((realy-this.catEnergyField[othercat].y)/pixelGroup)\r\n\r\n                        if(relativeotherx>0&&relativeotherx<this.catEnergyField[othercat].width&&relativeothery>0&&relativeothery<this.catEnergyField[othercat].height){\r\n                            // if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0&&this.catEnergyField[othercat].finalField[relativeothery][relativeotherx]>0){\r\n                            if(this.catEnergyField[k].finalField[y][x]==0&&this.catEnergyField[k].edgeBarrierMap[y][x]>0){\r\n                                for(let a=0;a<fillArea[i].length;a++){\r\n                                    //let fillPolygon=fillArea[i][a].map((val)=>{return {x:val[0],y:val[1]}})\r\n                                    //for(let b=0;b < fillPolygon.length; b ++){\r\n                                    //    d3.select('g').append('circle')\r\n                                    //        .attr('cx', fillPolygon[i].x)\r\n                                    //        .attr('cy', fillPolygon[i].y)\r\n                                    //        .attr('r',1)\r\n                                    //        .attr('fill','red')\r\n                                    //}\r\n                                    let intersect=IsoInsideTest([x, y],fillArea[i][a])\r\n                                    //let intersect=IntersectionQuery.pointInPolygon({x:x,y:y},fillPolygon)\r\n                                    if(intersect){\r\n                                        newFieldDict[k][y][x]=this.catEnergyField[k].field[y][x]\r\n\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //for(let a=0;a<fillArea[i].length;a++){\r\n//\r\n                //    // if(k==\"0\"){\r\n                //    // drawPolygon(fillArea[i][a],dx,dy,\"red\")\r\n                //    // }\r\n                //}\r\n\r\n\r\n\r\n\r\n            }\r\n            //var endTime2 = +new Date()\r\n            //console.log(\"cat \" + k + \" loop2 \" + (endTime2 - beginTime2) + \" ms\")\r\n            //var endTime = +new Date()\r\n            //console.log(\"cat \" + k + \" fill one edge mean: \" + (endTime - beginTime) / crossingPoints.length + \"ms\")\r\n        }\r\n\r\n\r\n\r\n        for(var k in this.catEnergyField){\r\n            this.catEnergyField[k].finalField=newFieldDict[k]\r\n        }\r\n    }\r\n\r\n    smoothEnergyField(bounding){\r\n        let kernelsize = 3\r\n        let kernel = this.getGaussianKernel(1.5, kernelsize)\r\n        let anchor = parseInt(kernelsize/2)\r\n        // console.log(kernel)\r\n        for (var k in this.catEnergyField){\r\n\r\n            let sx = bounding[k].minX;\r\n            let ex = bounding[k].maxX;\r\n            let sy = bounding[k].minY;\r\n            let ey = bounding[k].maxY;\r\n\r\n            let cur_width = ex - sx + 1;\r\n            let cur_height = ey - sy + 1;\r\n\r\n            let newField=[]\r\n            for (let y = 0;y < cur_height + 10;y ++){\r\n                newField.push(new Array(cur_width + 10).fill(0))\r\n            }\r\n\r\n            for (let y = sy; y <= ey; y ++){\r\n                for (let x = sx; x <= ex; x ++){\r\n\r\n                    let newvalue = 0\r\n                    for (let i = 0;i < kernelsize;i ++){\r\n                        for (let j = 0;j < kernelsize;j ++){\r\n                            let dy = i - anchor\r\n                            let dx = j - anchor\r\n                            let ny = y + dy\r\n                            let nx = x + dx\r\n                            if(ny > 0 && ny < this.catEnergyField[k].height && nx > 0 && nx < this.catEnergyField[k].width){\r\n                                newvalue += kernel[i][j] * this.catEnergyField[k].finalField[ny][nx]\r\n                            }\r\n                        }\r\n                    }\r\n                    if(newvalue > 0){\r\n                        newField[y - sy][x - sx] = newvalue\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            for(let y = sy; y <= ey; y ++){\r\n                for(let x = sx; x <= ex; x ++){\r\n                    //console.log(\"(\" + y + \", \" + x + \")\")\r\n                    //console.log(this.catEnergyField[k].finalField)\r\n                    this.catEnergyField[k].finalField[y][x] = newField[y - sy][x - sx]\r\n                }\r\n            }\r\n\r\n            //this.catEnergyField[k].finalField=newField\r\n        }\r\n    }\r\n\r\n    saveOutline(isoLineDict){\r\n        let res=[]\r\n        for (var k in isoLineDict){\r\n            for (let i=0;i<isoLineDict[k].length;i++){\r\n                let formatpoints=[]\r\n                for(let p=0;p<isoLineDict[k][i].length;p++){\r\n                    formatpoints.push({x:isoLineDict[k][i][p][0],y:isoLineDict[k][i][p][1]})\r\n                }\r\n                res.push({\r\n                    cat:k,\r\n                    id:i,\r\n                    isInterior:false,\r\n                    parentID:-1,\r\n                    points:formatpoints\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    removeOverlaps(){\r\n\r\n        this.updateEnergyPoints()\r\n\r\n        //for(var k in this.catEnergyField){\r\n        //    this.drawEnergyField(k);\r\n        //}\r\n\r\n\r\n        //this.smoothEnergyField()\r\n\r\n        d3.select(\"svg\")\r\n            .selectAll(\"path\")\r\n            .remove()\r\n\r\n\r\n        recal = false\r\n        recalNum = 0\r\n        this.firstFlag = true\r\n        this.findOutLine()\r\n        this.calOutLine()\r\n\r\n        this.calEdgeControlPoints()\r\n\r\n        /*\r\n        intervals=[0.01]\r\n        let isoDict=this.calISOLine(intervals)\r\n\r\n        //for (var k in isoDict){\r\n        //    this.drawEnergyField(k)\r\n        //}\r\n\r\n        let polygontest = {};\r\n\r\n        control_points = {};\r\n\r\n        let tmp_polygon = {}\r\n\r\n        for (var k in isoDict){\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                if(!tmp_polygon.hasOwnProperty(k)){\r\n                    tmp_polygon[k] = []\r\n                }\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                tmp_polygon[k].push(polygon)\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    tmp_polygon[k].selectidx = tmp_polygon[k].length - 1;\r\n                    polygontest[k] = [];\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        polygontest[k].push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        //console.log(tmp_polygon)\r\n        for(var k in isoDict){\r\n            let sidx = tmp_polygon[k].selectidx;\r\n            for(let i = 0; i < tmp_polygon[k].length; i ++){\r\n                if(i == sidx){\r\n                    continue;\r\n                }\r\n                let flag = true;\r\n                for(let j = 0; j < tmp_polygon[k][i].length; j ++){\r\n                    flag = IsoInsideTest([ tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1] ], tmp_polygon[k][sidx]);\r\n                    if(flag == false){\r\n                        break;\r\n                    }\r\n                }\r\n                if(flag){\r\n                    if(tmp_polygon[k][i].length < 30){\r\n                        continue;\r\n                    }\r\n                    let curlen = control_points[k].length;\r\n                    control_points[k][curlen] = [];\r\n                    for(let j = 0; j < tmp_polygon[k][i].length; j += 10){\r\n                        control_points[k][curlen].push( [tmp_polygon[k][i][j][0], tmp_polygon[k][i][j][1]] )\r\n                    }\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][curlen].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                            control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][curlen].meandis = meandis;\r\n                }\r\n            }\r\n        }\r\n\r\n        //console.log(\"hhhh\")\r\n        //console.log(isoDict)\r\n        /*\r\n        for (var k in isoDict){\r\n\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoDict[k].length; i ++ ){\r\n                let polygon = [];\r\n                for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                    polygon.push([isoDict[k][i][j][0]*pixelGroup + dx,isoDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let flag = false;\r\n                for(let p = 0;p < this.catPointDict[k].length; p ++){\r\n                    flag = IsoInsideTest([ this.catPointDict[k][p].x, this.catPointDict[k][p].y ], polygon);\r\n                    if(flag) break;\r\n                }\r\n                if(flag){\r\n                    //console.log(isoDict[k][i])\r\n                    if(!polygontest.hasOwnProperty(k)){\r\n                        polygontest[k] = [];\r\n                    }\r\n                    let tmppolygon = []\r\n                    for(let j = 0; j < isoDict[k][i].length; j += 10){\r\n                        tmppolygon.push([isoDict[k][i][j][0],isoDict[k][i][j][1]]);\r\n                    }\r\n                    polygontest[k].push(tmppolygon)\r\n                    is_selected[k] = false\r\n                    control_points[k] = []\r\n                    control_points[k][0] = []\r\n                    control_points[k][0] = polygon;\r\n                    let meandis = 0;\r\n                    let sz = control_points[k][0].length;\r\n                    for(let j = 0; j < sz; j ++){\r\n                        meandis += calDistance(control_points[k][0][j][0], control_points[k][0][j][1],\r\n                            control_points[k][0][(j + 1) % sz][0],control_points[k][0][(j + 1) % sz][1])\r\n                    }\r\n                    meandis /= sz\r\n                    control_points[k][0].meandis = meandis;\r\n                    //this.drawISOLinesV2(k,this)\r\n                }\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n\r\n        // re-cal the energy field for inner outline\r\n        for (var k in this.catEnergyField){\r\n            this.catEnergyField[k].tfinalField = []\r\n            for(let y=0;y<this.catEnergyField[k].height;y++){\r\n                this.catEnergyField[k].tfinalField.push(new Array(this.catEnergyField[k].width).fill(0));\r\n                for(let x=0;x<this.catEnergyField[k].width;x++){\r\n                    let val = this.catEnergyField[k].finalField[y][x];\r\n                    let flag = false;\r\n                    for(let idx = 0; idx < polygontest[k].length; idx ++){\r\n                        flag = IsoInsideTest([x, y], polygontest[k][idx])\r\n                        if(flag){\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(flag){\r\n                        //console.log(\"test!!\")\r\n                        if(val > 0){\r\n                            this.catEnergyField[k].tfinalField[y][x] = 0;\r\n                        }\r\n                        else{\r\n                            this.catEnergyField[k].tfinalField[y][x] = 10;\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.catEnergyField[k].finalField[y][x] = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        let isoLineDict={}\r\n        for (var k in this.catEnergyField){\r\n            var isoLines = [];\r\n            isoLines=MarchingSquaresJS\r\n                .isoLines(this.catEnergyField[k].tfinalField,\r\n                    intervals,\r\n                    {\r\n                        polygons: false,\r\n                        linearRing: false,\r\n                        noFrame:true\r\n                    }\r\n                )\r\n            isoLineDict[k]=isoLines[0]\r\n        }\r\n\r\n        for (var k in isoLineDict){\r\n            //console.log(isoLineDict[k])\r\n            let dx=this.catEnergyField[k].x\r\n            let dy=this.catEnergyField[k].y\r\n            for(let i = 0; i < isoLineDict[k].length; i ++ ){\r\n                if(isoLineDict[k][i].length < 30){\r\n                    continue;\r\n                }\r\n                let curlen = control_points[k].length;\r\n                control_points[k][curlen] = [];\r\n                for(let j = 0; j < isoLineDict[k][i].length; j += 10){\r\n                    control_points[k][curlen].push([isoLineDict[k][i][j][0]*pixelGroup + dx,isoLineDict[k][i][j][1]*pixelGroup + dy])\r\n                }\r\n                let meandis = 0;\r\n                let sz = control_points[k][curlen].length;\r\n                for(let j = 0; j < sz; j ++){\r\n                    meandis += calDistance(control_points[k][curlen][j][0], control_points[k][curlen][j][1],\r\n                        control_points[k][curlen][(j + 1) % sz][0],control_points[k][curlen][(j + 1) % sz][1])\r\n                }\r\n                meandis /= sz\r\n                control_points[k][curlen].meandis = meandis;\r\n            }\r\n            //this.drawEnergyField(k);\r\n        }\r\n\r\n        */\r\n\r\n        /*\r\n        for(var k in this.catEnergyField){\r\n            let curdata=\"\"\r\n            for(let i = 0; i < control_points[k].length; i ++){\r\n                curdata += lineFunction(control_points[k][i])\r\n            }\r\n            //this.drawEnergyField(k);\r\n            this.drawISOLinesV2(k, this, curdata);\r\n        }\r\n        */\r\n\r\n        //d3.select(\"svg\").selectAll(\".energyfieldrect\")\r\n        //    .remove()\r\n\r\n        for(var k in this.catEnergyField){\r\n            // this.drawEnergyField(k);\r\n            this.updatedEnergyPoints[k]=[]\r\n        }\r\n\r\n\r\n    }\r\n\r\n    onChangeEdgeWidth = value => {\r\n        edgeWidth = value\r\n        this.setState({\r\n            edgeWidth:value\r\n        })\r\n        this.changeEdgeWidth(this.selectedEdge,value)\r\n    };\r\n\r\n\r\n    onChangeNodeR0 = value => {\r\n        nodeR0 = value\r\n        this.setState({\r\n            nodeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeNodeR1 = value => {\r\n        nodeR1 = value\r\n        nodeR0=nodeR1-5\r\n        this.setState({\r\n            nodeR1: value,\r\n            nodeR0:nodeR1-5\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR0 = value => {\r\n        edgeR0 = value\r\n        this.setState({\r\n            edgeR0: value,\r\n        });\r\n    };\r\n\r\n    onChangeEdgeR1 = value => {\r\n        edgeR1 = value\r\n        edgeR0=edgeR1-5\r\n        this.setState({\r\n            edgeR1: value,\r\n            edgeR0:edgeR0\r\n        });\r\n    };\r\n\r\n    onChangePixelGroup = value => {\r\n        pixelGroup = value\r\n        this.setState({\r\n            pixelGroup: value,\r\n        });\r\n    };\r\n\r\n    onChangeGap = value => {\r\n        gapBetween = value\r\n        this.setState({\r\n            gapBetween: value,\r\n        });\r\n    };\r\n\r\n    render(){\r\n        return(\r\n\r\n            <div id={\"Sliders\"}>\r\n                <br/>\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>nodeR0</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR0}\r\n                        value={typeof nodeR0 === 'number' ? nodeR0 : 10}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR0}\r\n                        onChange={this.onChangeNodeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Node Radius</h4>\r\n                    <Slider\r\n                        min={1}\r\n                        max={50}\r\n                        onChange={this.onChangeNodeR1}\r\n                        value={typeof nodeR1 === 'number' ? nodeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={1}\r\n                        max={50}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={nodeR1}\r\n                        onChange={this.onChangeNodeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n{/*            <Row>\r\n                <Col span={12}>\r\n                    <h4>edgeR0</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR0}\r\n                        value={typeof edgeR0 === 'number' ? edgeR0 : 15}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR0}\r\n                        onChange={this.onChangeEdgeR0}\r\n                    />\r\n                </Col>\r\n            </Row>*/}\r\n\r\n            <Row>\r\n                <Col span={12}>\r\n                    <h4>Global Edge Width</h4>\r\n                    <Slider\r\n                        min={10}\r\n                        max={100}\r\n                        onChange={this.onChangeEdgeR1}\r\n                        value={typeof edgeR1 === 'number' ? edgeR1 : 20}\r\n                    />\r\n                </Col>\r\n                <Col span={4}>\r\n                    <InputNumber\r\n                        min={10}\r\n                        max={100}\r\n                        style={{ margin: '0 16px' }}\r\n                        value={edgeR1}\r\n                        onChange={this.onChangeEdgeR1}\r\n                    />\r\n                </Col>\r\n            </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Pixel Group</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangePixelGroup}\r\n                            value={typeof pixelGroup === 'number' ? pixelGroup : 2}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={pixelGroup}\r\n                            onChange={this.onChangePixelGroup}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Gap Between Different Groups</h4>\r\n                        <Slider\r\n                            min={0}\r\n                            max={5}\r\n                            onChange={this.onChangeGap}\r\n                            value={typeof gapBetween === 'number' ? gapBetween : 1}\r\n                        />\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={0}\r\n                            max={5}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={gapBetween}\r\n                            onChange={this.onChangeGap}\r\n                        />\r\n                    </Col>\r\n                </Row>\r\n\r\n                <Row>\r\n                    <Col span={12}>\r\n                        <h4>Edge Width</h4>\r\n                        <Slider\r\n                            min={1}\r\n                            max={10}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            value={this.state.edgeWidth}\r\n                        disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                    <Col span={4}>\r\n                        <InputNumber\r\n                            min={1}\r\n                            max={10}\r\n                            style={{ margin: '0 16px' }}\r\n                            value={this.state.edgeWidth}\r\n                            onChange={this.onChangeEdgeWidth}\r\n                            disabled={this.state.hasSelectEdge?false:true}/>\r\n                    </Col>\r\n                </Row>\r\n\r\n                <br/>\r\n                <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Draw Bubbles\r\n                </Button>\r\n\r\n                <Button onClick = {this.removeOverlaps.bind(this)} disabled={this.props.hasLoadData?false:true}>\r\n                    Remove Overlaps\r\n                </Button>\r\n\r\n        </div>)\r\n\r\n    }\r\n}\r\n\r\nexport default AdaptiveIsovalue","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport * as d3 from \"d3\"\r\nimport AdaptiveIsovalue from \"./AdaptiveIsovalue\";\r\nimport {Button, Switch} from 'antd';\r\nimport {PointToSegDist} from \"./util\"\r\n\r\nvar FileSaver = require('file-saver');\r\n//import Quadtree from '@timohausmann/quadtree-js'\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\n// var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n\r\n// var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#d35d6d','#0885c2','#4aa15f','#6950a1','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //drawFig\r\n//var colors=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\n// var colors=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colors=['#f16b22','#7e519f','#713e3a'] //fig1\r\n\r\nvar jsgraphs = require('js-graph-algorithms');\r\nvar POINT_EDGE_EPS=10\r\nvar DBSCAN_EPS=40\r\nvar VirtrualNodeBuffer=50\r\n\r\n\r\nvar clustering = require('density-clustering');\r\nvar weightCross=1\r\nvar weightDistance=1\r\nvar weightMess=1\r\n\r\nvar maxCross=Number.MIN_VALUE\r\nvar DISTANCE_THRESHHOLD=Number.MAX_VALUE\r\n\r\nvar priority_queue = require('./priority_queue.js');\r\nvar svgid = \"#mainsvg\"\r\nvar opsvgid = \"#leftsvg\"\r\nvar svg;\r\nvar g;\r\nvar offsetX,offsetY,viewWidth,viewHeight;\r\n\r\nvar subOldPoints = []\r\nvar addNewPoints = []\r\nvar subOldEdges = []\r\nvar addNewEdges = []\r\nvar editPoints = []\r\nvar editEdges = []\r\nvar preEdges = []\r\nvar tmpEditEdges = []\r\nvar prePoint\r\nvar preEdgeDict\r\nvar curEdgeDict\r\nvar editView = false\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nfunction clone(obj) {\r\n    // Handle the 3 simple types, and null or undefined or function\r\n    if (null == obj || \"object\" != typeof obj) return obj;\r\n\r\n    // Handle Date\r\n    if (obj instanceof Date) {\r\n        var copy = new Date();\r\n        copy.setTime(obj.getTime());\r\n        return copy;\r\n    }\r\n    // Handle Array or Object\r\n    if (obj instanceof Array | obj instanceof Object) {\r\n        var copy = (obj instanceof Array)?[]:{};\r\n        for (var attr in obj) {\r\n            if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n        }\r\n        return copy;\r\n    }\r\n    throw new Error(\"Unable to clone obj! Its type isn't supported.\");\r\n}\r\n\r\n//var Quadtree = require('./quadtree.js');\r\n\r\nclass HierarchicalCluster extends Component{\r\n    static propTypes = {\r\n        pointData: PropTypes.array,\r\n    }\r\n\r\n    static defaultProps = {\r\n        pointData:[]\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false,\r\n            editV:false,\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.issplit=false\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedIndex=-1\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n    }\r\n\r\n    init(){\r\n\r\n        colors=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n\r\n        POINT_EDGE_EPS = 10\r\n        DBSCAN_EPS = 40\r\n        VirtrualNodeBuffer = 50\r\n\r\n        weightCross = 1\r\n        weightDistance = 1\r\n        weightMess = 1\r\n\r\n        maxCross = Number.MIN_VALUE\r\n        DISTANCE_THRESHHOLD = Number.MAX_VALUE\r\n\r\n        svgid = \"#mainsvg\"\r\n        opsvgid = \"#leftsvg\"\r\n\r\n        subOldPoints = []\r\n        addNewPoints = []\r\n        subOldEdges = []\r\n        addNewEdges = []\r\n        editPoints = []\r\n        editEdges = []\r\n        preEdges = []\r\n        tmpEditEdges = []\r\n        editView = false\r\n\r\n        this.setState({\r\n            read: false,\r\n            pointData:[],\r\n            edges:[],\r\n            hasinit:false,\r\n            hasEdit:false,\r\n            hascreated:false,\r\n            editV:false,\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        })\r\n        this.pointData=[]\r\n        this.canvasWidth=-1\r\n        this.canvasHeight=-1\r\n        this.maxX=-1\r\n        this.maxY=-1\r\n        this.minX=-1\r\n        this.minY=-1\r\n        this.maxDis=Number.MIN_VALUE\r\n        this.catPointDict={}\r\n        this.edges=[]\r\n        this.graph=null\r\n        this.clustergraph=null\r\n        this.maxDistance=-1\r\n        this.itemShape=\"\"\r\n        this.isSelect=false\r\n        this.selectItem=null\r\n        this.clusterDict={}\r\n        this.clustergraphInfo={}\r\n        this.clusterArr=[]\r\n        this.noiseDict={}\r\n        this.itemBBox=[]\r\n        this.intersecEdges=[]\r\n        this.vis = []\r\n        this.heap1 = {}\r\n        this.heap2 = {}\r\n        this.QTree = null;\r\n        this.f = []\r\n        this.edgesdict = []\r\n        this.idx = 0\r\n        this.draggedEdgeIndex=-1\r\n        this.draggedEdgeSeg=-1\r\n        this.nodeStartDict=[]\r\n        this.nodeEndDict=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n        this.tempEdges=[]\r\n\r\n        this.componentWillMount()\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n        this.child.init_all()\r\n\r\n    }\r\n\r\n    searchFather(x){\r\n        while(x!=this.f[x]){\r\n            this.f[x] = this.f[this.f[x]];\r\n            x = this.f[x];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    unionFather(x,y){\r\n        this.f[this.searchFather(y)] = this.searchFather(x);\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.props.onRef(this)\r\n        this.canvasWidth=document.getElementById(\"mainsvg\").getBoundingClientRect().width\r\n        this.canvasHeight=document.getElementById(\"mainsvg\").getBoundingClientRect().height\r\n        // this.setState({\r\n        //     hasLoadData:this.props.hasLoadData\r\n        // })\r\n        //V1\r\n        //this.QTree = new Quadtree({\r\n        //    x: 0,\r\n        //    y: 0,\r\n        //    width: this.canvasWidth,\r\n        //    height: this.canvasHeight\r\n        //});\r\n        //this.getData()\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        /*        let centerx=minx+(maxx-minx)/2\r\n                let centery=miny+(maxy-miny)/2\r\n                let move=[this.canvasWidth/2-centerx,this.canvasHeight/2-centery]\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x+=move[0]\r\n                    this.pointData[i].y+=move[1]\r\n                }*/\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n        //console.log(this.minX,this.maxX,this.minY,this.maxY)\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n\r\n        d3.select(\"#leftsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        /*        for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x-=this.minX-20\r\n                    this.pointData[i].y-=this.minY-20\r\n                }*/\r\n\r\n        offsetX = minx-20;\r\n        offsetY = miny-20;\r\n        viewWidth = maxx-minx+40;\r\n        viewHeight = maxy-miny+40\r\n\r\n    }\r\n\r\n    calEPS(){\r\n        // POINT_EDGE_EPS=Math.max(this.maxX-this.minX,this.maxY-this.minY)*0.03\r\n        let dissum=0\r\n        let disnum=0\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            for (let j=i+1;j<this.pointData.length;j++){\r\n                let dis=this.calDistance(this.pointData[i],this.pointData[j])\r\n                dissum+=dis\r\n                disnum+=1\r\n                if(dis>maxDis){\r\n                    maxDis=dis\r\n                }\r\n            }\r\n        }\r\n        POINT_EDGE_EPS=maxDis*0.035\r\n        // DBSCAN_EPS=POINT_EDGE_EPS\r\n        this.maxDis=maxDis\r\n        /*                d3.select(svgid)\r\n                    .append(\"circle\")\r\n                    .attr(\"cx\",POINT_EDGE_EPS)\r\n                    .attr(\"cy\",POINT_EDGE_EPS)\r\n                    .attr(\"r\",POINT_EDGE_EPS)\r\n                    .attr(\"fill\",\"black\")*/\r\n\r\n        DISTANCE_THRESHHOLD=dissum/disnum-10\r\n        //console.log(POINT_EDGE_EPS)\r\n        //console.log(\"avreage distance: \"+dissum/disnum)\r\n        //console.log(\"max distance: \"+this.maxDis)\r\n\r\n\r\n    }\r\n\r\n    addNewPoints(point){\r\n        point.x=parseFloat(point.x)\r\n        point.y=parseFloat(point.y)\r\n        point.id=this.pointData.length\r\n        point.cat=point.cat.toString()\r\n        let cats=point.cat.split(\",\")\r\n        let catarray=[]\r\n        if (cats.length>1){\r\n            point.multicat=true\r\n            for (let c=0;c<cats.length;c++){\r\n                catarray.push(cats[c])\r\n            }\r\n        }\r\n        else{\r\n            point.multicat=false\r\n            catarray.push(point.cat)\r\n        }\r\n        point.catArray=catarray\r\n\r\n        for (let c=0;c<point.catArray.length;c++){\r\n            let nowcat=point.catArray[c]\r\n            if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                this.catPointDict[nowcat]=[]\r\n            }\r\n            this.catPointDict[nowcat].push(point)\r\n        }\r\n\r\n        this.pointData.push(point)\r\n\r\n        let tmpp1 = clone(this.pointData[this.pointData.length - 1])\r\n        tmpp1.flag = true\r\n        tmpp1.id = this.pointData.length - 1\r\n        editPoints.push(tmpp1)\r\n\r\n        //this.centralizeData()\r\n\r\n        this.calEPS()\r\n\r\n        this.drawPointData()\r\n\r\n        this.optimizeMST(true)\r\n\r\n        this.setState({\r\n            pointData: this.pointData\r\n        })\r\n        this.setState({\r\n            edges: this.edges\r\n        })\r\n\r\n\r\n    }\r\n\r\n    getData(){\r\n\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        //let that=this\r\n        //fetch('/data/BubbleSetExample1.txt',{\r\n        //    method:'GET',\r\n        //    headers:{\r\n        //        'Content-Type':'application/json;charset=UTF-8'\r\n        //    },\r\n        //    mode:'cors',\r\n        //    cache:'default'\r\n        //})\r\n        //    .then(res=>res.json())\r\n        //    .then(data=>{\r\n        //console.log(data)\r\n\r\n        // if(!this.props.hasLoadData){\r\n        //     return\r\n        // }\r\n\r\n        if(this.state.hasinit){\r\n            this.applyEdit()\r\n        }\r\n        else{\r\n            if(this.props.pointData){\r\n                this.init();\r\n\r\n                if(this.props.edges){\r\n                    this.edges=this.props.edges\r\n                }\r\n\r\n                // alert(\"Finish input and start creating spanning tree!\");\r\n                this.pointData=this.props.pointData\r\n                //this.pointData=data\r\n                this.itemShape=this.pointData[0].shape\r\n                //console.log(this.itemShape)\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    this.pointData[i].x=parseFloat(this.pointData[i].x)\r\n                    this.pointData[i].y=parseFloat(this.pointData[i].y)\r\n                    this.pointData[i].id=i\r\n                    this.pointData[i].cat=this.pointData[i].cat.toString()\r\n                    let cats=this.pointData[i].cat.split(\",\")\r\n                    let catarray=[]\r\n                    if (cats.length>1){\r\n                        this.pointData[i].multicat=true\r\n                        for (let c=0;c<cats.length;c++){\r\n                            catarray.push(cats[c])\r\n                        }\r\n                    }\r\n                    else{\r\n                        this.pointData[i].multicat=false\r\n                        catarray.push(this.pointData[i].cat)\r\n                    }\r\n                    this.pointData[i].catArray=catarray\r\n                    for (let c=0;c<this.pointData[i].catArray.length;c++){\r\n                        let nowcat=this.pointData[i].catArray[c]\r\n                        if(!this.catPointDict.hasOwnProperty(nowcat)){\r\n                            this.catPointDict[nowcat]=[]\r\n                        }\r\n                        this.catPointDict[nowcat].push(this.pointData[i])\r\n                    }\r\n                }\r\n\r\n                //console.log(this.pointData)\r\n                //console.log(this.catPointDict)\r\n                this.centralizeData()\r\n                this.calEPS()\r\n                d3.select(svgid).selectAll(\"*\").remove();\r\n                this.drawPointData()\r\n\r\n                this.generateTreeWithHierarchical()\r\n\r\n\r\n\r\n                // console.log(this.edges)\r\n                this.drawEdges()\r\n\r\n                this.props.hasCreate();\r\n\r\n                this.setState({\r\n                    pointData: this.pointData\r\n                })\r\n                this.setState({\r\n                    edges: this.edges\r\n                })\r\n                this.setState({\r\n                    hasinit:true\r\n                })\r\n                //})\r\n            }\r\n\r\n        }\r\n        //console.log(this.pointData)\r\n\r\n        return [this.pointData, this.edges, colors]\r\n\r\n    }\r\n\r\n    createGraph(){\r\n        var g = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g\r\n    }\r\n\r\n    sortEdgesGlobal(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis*(mess+1)\r\n            // let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesGlobalWithMinDis(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.catPointDict){\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                for (let j=i+1;j<this.catPointDict[k].length;j++){\r\n                    let dis=this.calDistance(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    let mess=this.calEdgeMess(this.catPointDict[k][i],this.catPointDict[k][j])\r\n                    disArray.push(dis)\r\n                    messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            let mess=tempedges[i][3]\r\n            let weight=dis\r\n            edges.push([start,end,weight,dis,mess])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    sortEdgesInCategory(cat){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n        let edges=[]\r\n        for (let i=0;i<this.catPointDict[cat].length;i++){\r\n            for (let j=i+1;j<this.catPointDict[cat].length;j++){\r\n                let score=this.calEdgeWeight(this.catPointDict[cat][i],this.catPointDict[cat][j])\r\n                edges.push([this.catPointDict[cat][i].id,this.catPointDict[cat][j].id,score])\r\n            }\r\n        }\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    checkEdgeCrossing(P1,P2,Q1,Q2){\r\n        if(Math.min(P1.x,P2.x) <= Math.max(Q1.x,Q2.x) &&\r\n            Math.min(Q1.x,Q2.x) <= Math.max(P1.x,P2.x) &&\r\n            Math.min(P1.y,P2.y) <= Math.max(Q1.y,Q2.y) &&\r\n            Math.min(Q1.y,Q2.y) <= Math.max(P1.y,P2.y)){\r\n            if(\r\n                ((Q1.x-P1.x)*(Q1.y-Q2.y)-(Q1.y-P1.y)*( Q1.x-Q2.x)) * ((Q1.x-P2.x)*(Q1.y-Q2.y)-(Q1.y-P2.y)*(Q1.x-Q2.x)) < 0 &&\r\n                ((P1.x-Q1.x)*(P1.y-P2.y)-(P1.y-Q1.y)*(P1.x-P2.x)) * ((P1.x-Q2.x)*(P1.y-P2.y)-(P1.y-Q2.y)*( P1.x-P2.x)) < 0\r\n            ){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n    checkNewEdge(node1,node2){\r\n        if(node1.cat!=node2.cat)\r\n            return true\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            if(start.cat!=node1.cat&&start.cat!=node2.cat&&end.cat!=node1.cat&&end.cat!=node2.cat&&this.checkEdgeCrossing(start,end,node1,node2)){\r\n                // d3.selectAll(\"line\").remove()\r\n                // this.drawLine(start.x,start.y,end.x,end.y,\"red\")\r\n                // this.drawLine(node1.x,node1.y,node2.x,node2.y,\"red\")\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    calBackbone(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobal()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(!this.checkNewEdge(this.pointData[start],this.pointData[end])){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnect()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n                let cat=this.pointData[start].cat\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                    removeEdggeList[i].weight=scores[0]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push(removeEdggeList[i])\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                dis:tempEdgeList[maxindex].dis,\r\n                mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n    }\r\n\r\n    calBackboneWithMinDis(){\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithMinDis()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            let mess=sortedEdges[i][4]\r\n\r\n            if(this.pointData[start].cat!=this.pointData[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n                if(true){\r\n                    this.graph.addEdge(start,end)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n\r\n        /*        while(!this.checkConnect()){\r\n                    let tempEdgeList=[]\r\n                    for(let i=0;i<removeEdggeList.length;i++){\r\n                        let start=removeEdggeList[i].start\r\n                        let end=removeEdggeList[i].end\r\n                        let cat=this.pointData[start].cat\r\n\r\n                        var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n                        if(!dfs.hasPathTo(end)){\r\n                            let scores=this.calEdgeWeightWithCrossing(this.pointData[start],this.pointData[end])\r\n                            removeEdggeList[i].weight=scores[0]\r\n                            removeEdggeList[i].crossnum=scores[3]\r\n                            tempEdgeList.push(removeEdggeList[i])\r\n                            // filteredRemoveList.push(removeEdggeList[i])\r\n                        }\r\n                    }\r\n                    let minCost=Number.MAX_VALUE\r\n                    let maxindex=-1\r\n                    for (let i=0;i<tempEdgeList.length;i++){\r\n                        if(minCost>tempEdgeList[i].weight){\r\n                            minCost=tempEdgeList[i].weight\r\n                            maxindex=i\r\n                        }\r\n                    }\r\n\r\n                    let start=tempEdgeList[maxindex].start\r\n                    let end=tempEdgeList[maxindex].end\r\n                    this.graph.addEdge(start,end)\r\n                    this.edges.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:tempEdgeList[maxindex].weight,\r\n                        dis:tempEdgeList[maxindex].dis,\r\n                        mess:tempEdgeList[maxindex].mess,\r\n                        crossnum:tempEdgeList[maxindex].crossnum\r\n                    })\r\n\r\n                    // tempEdgeList.splice(maxindex,1)\r\n\r\n                }*/\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n\r\n//TODO: dynamic calculate the cost of each removelist\r\n\r\n    }\r\n\r\n    checkConnectBetweenAllClusterV2(){\r\n        for(let k in this.clusterDict){\r\n            let m = this.clustergraphInfo[k].edgesnum;\r\n            let n = this.clustergraphInfo[k].nodesnum;\r\n            if (m != n - 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    checkConnectBetweenAllCluster(){\r\n        for(let k in this.clusterDict){\r\n            let start=this.clusterDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n            for (let i=1;i<this.clusterDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.clusterDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n\r\n    checkConnectBetweenTwoClusterV2(id1,id2){\r\n        return (this.searchFather(id1)==this.searchFather(id2));\r\n    }\r\n\r\n    checkConnectBetweenTwoCluster(id1,id2){\r\n        var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, id1);\r\n        if (!dfs.hasPathTo(id2)){\r\n            return false\r\n        }\r\n        else{\r\n            return true\r\n        }\r\n    }\r\n    checkConnect(){\r\n        // this.drawPointData()\r\n        // this.drawEdges()\r\n        for(let k in this.catPointDict){\r\n            let start=this.catPointDict[k][0].id\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.graph, start);\r\n            for (let i=1;i<this.catPointDict[k].length;i++){\r\n                if (!dfs.hasPathTo(this.catPointDict[k][i].id)){\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    sortRemoveEdges(removelist){\r\n        function sortRemove(a,b){\r\n            return a.weight-b.weight\r\n        }\r\n\r\n        removelist.sort(sortRemove())\r\n        return removelist\r\n    }\r\n\r\n    calEdgeWeightWithCrossing(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calEdgeWeightWithCrossing2(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n\r\n        let crossnum=0\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let edgecat=this.pointData[start].cat\r\n            if(node1.cat!=edgecat&&this.checkEdgeCrossing(node1,node2,this.pointData[start],this.pointData[end])){\r\n                crossnum+=1\r\n            }\r\n        }\r\n\r\n        return [dis*(mess+1)*(crossnum+1)/this.maxDistance,dis/this.maxDistance,mess,crossnum]\r\n\r\n    }\r\n\r\n    calDistance(node1,node2){\r\n        return Math.sqrt(Math.pow(node1.x-node2.x,2)+Math.pow(node1.y-node2.y,2))\r\n    }\r\n\r\n    calEdgeMess(node1,node2){\r\n        let num=0\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if(this.pointData[i].cat!=node1.cat&&this.pointData[i].cat!=node2.cat){\r\n                if(this.isPointInEdgeRange(node1,node2,this.pointData[i])){\r\n                    let pointedgedis=this.calPointEdgeDistance(node1,node2,this.pointData[i])\r\n                    // console.log(pointedgedis)\r\n                    if(pointedgedis<POINT_EDGE_EPS){\r\n                        num+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // console.log(num)\r\n        return num\r\n    }\r\n\r\n    calEdgeWeight(node1,node2){\r\n        let dis=this.calDistance(node1,node2)\r\n        let mess=this.calEdgeMess(node1,node2)\r\n        return [dis,mess]\r\n    }\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    calVecCosine(vec1,vec2){\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let norm1=this.getVecNorm(vec1)\r\n        let norm2=this.getVecNorm(vec2)\r\n        return dot/(norm1*norm2)\r\n\r\n    }\r\n    isPointInEdgeRange(start,end,point){\r\n        let vec1=[point.x-start.x,point.y-start.y]\r\n        let vec2=[end.x-start.x,end.y-start.y]\r\n        let cos1=this.calVecCosine(vec1,vec2)\r\n        if(cos1<0){\r\n            return false\r\n        }\r\n\r\n        let vec3=[point.x-end.x,point.y-end.y]\r\n        let vec4=[start.x-end.x,start.y-end.y]\r\n        let cos2=this.calVecCosine(vec3,vec4)\r\n\r\n        if(cos2<0){\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    calPointEdgeDistance(start,end,point){\r\n        //must check if the point is in the range of the edge before calling this function\r\n        let vec1=[end.x-start.x,end.y-start.y]\r\n        let vec2=[point.x-start.x,point.y-start.y]\r\n\r\n        let dot=vec1[0]*vec2[0]+vec1[1]*vec2[1]\r\n        let seg1=dot/this.getVecNorm(vec1)\r\n        let norm=this.getVecNorm(vec2)\r\n\r\n        return Math.sqrt(Math.pow(norm,2)-Math.pow(seg1,2))\r\n    }\r\n\r\n    calCrossingCost(){\r\n\r\n    }\r\n\r\n    drawLine(x1,y1,x2,y2,color){\r\n        d3.select(svgid).append(\"line\")\r\n            .attr(\"x1\",x1)\r\n            .attr(\"y1\",y1)\r\n            .attr(\"x2\",x2)\r\n            .attr(\"y2\",y2)\r\n            .attr(\"stroke-width\",2)\r\n            .attr(\"stroke\",color)\r\n    }\r\n    drawEdges(){\r\n        let that=this\r\n        for(let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n            that.edges[i].SVGElement=[]\r\n        }\r\n\r\n        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        if(d3.select(opsvgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(opsvgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }\r\n\r\n        /*        function dragstartControlpoint(){\r\n                }\r\n                function draggedControlPoint(event){\r\n                    let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n                    that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n                    d3.select(this)\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                        })\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n                    d3.select(svgid).select(\"#edgeGroup\").selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                        })\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n                }\r\n\r\n                var dragControlPoint = d3.drag()\r\n                    .on(\"start\",dragstartControlpoint)\r\n                    .on(\"drag\",draggedControlPoint)\r\n\r\n                function dragstartEdge(event){\r\n                    // console.log(\"start!\")\r\n                    let index=parseInt(d3.select(this).attr(\"index\"))\r\n                    let start=that.pointData[that.edges[index].start]\r\n                    let end=that.pointData[that.edges[index].end]\r\n\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n\r\n                    if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                        let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                        that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=segindex\r\n                    }\r\n                    else{\r\n                        that.edges[index].virtrual=true\r\n                        that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                        that.draggedEdgeIndex=index\r\n                        that.draggedEdgeSeg=0\r\n                    }\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                        })\r\n                        .remove()\r\n\r\n                    let vpoints=that.edges[index].virtrualNodes\r\n                    let nowp=[start.x,start.y]\r\n                    let nextp=[]\r\n                    for(let i=0;i<vpoints.length;i++){\r\n                        nextp=vpoints[i]\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .append(\"line\")\r\n                            .attr(\"x1\",nowp[0])\r\n                            .attr(\"y1\",nowp[1])\r\n                            .attr(\"x2\",nextp[0])\r\n                            .attr(\"y2\",nextp[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"index\",index)\r\n                            .attr(\"isvirtrual\",true)\r\n                            .attr(\"segindex\",i)\r\n                            .on(\"mouseover\",function(d,i){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"red\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                let thisindex=d3.select(this).attr(\"index\")\r\n                                d3.selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return d3.select(this).attr(\"index\")==thisindex\r\n                                    })\r\n                                    .attr(\"stroke\",\"black\")\r\n                                console.log(that.edges[thisindex])\r\n                            })\r\n                            .on(\"mousedown\",handleMouseDown)\r\n                            .call(dragEdge)\r\n\r\n                        nowp=nextp\r\n                    }\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .append(\"line\")\r\n                        .attr(\"x1\",nowp[0])\r\n                        .attr(\"y1\",nowp[1])\r\n                        .attr(\"x2\",end.x)\r\n                        .attr(\"y2\",end.y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",index)\r\n                        .attr(\"isvirtrual\",true)\r\n                        .attr(\"segindex\",vpoints.length)\r\n                        .on(\"mouseover\",function(d,i){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"red\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mouseout\",function(){\r\n                            let thisindex=d3.select(this).attr(\"index\")\r\n                            d3.selectAll(\"line\")\r\n                                .filter(function(){\r\n                                    return d3.select(this).attr(\"index\")==thisindex\r\n                                })\r\n                                .attr(\"stroke\",\"black\")\r\n                            console.log(that.edges[thisindex])\r\n                        })\r\n                        .on(\"mousedown\",handleMouseDown)\r\n\r\n                        .call(dragEdge)\r\n\r\n                    for (let v=0;v<vpoints.length;v++){\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .append(\"circle\")\r\n                            .attr(\"class\",\"controlPoints\")\r\n                            .attr(\"cx\",vpoints[v][0])\r\n                            .attr(\"cy\",vpoints[v][1])\r\n                            .attr(\"r\",5)\r\n                            .attr(\"fill\",\"red\")\r\n                            .attr(\"opacity\",0)\r\n                            .attr(\"edgeindex\",index)\r\n                            .attr(\"segindex\",v)\r\n                            // .attr(\"display\",\"none\")\r\n                            .on(\"mouseover\",function(){\r\n                                d3.select(this).attr(\"opacity\",1)\r\n                            })\r\n                            .on(\"mouseout\",function(){\r\n                                d3.select(this).attr(\"opacity\",0)\r\n                            })\r\n                            .call(dragControlPoint)\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n                function draggedEdge(event){\r\n                    // console.log(\"drag!\")\r\n                    if(that.draggedEdgeIndex==-1)\r\n                        return\r\n                    event.sourceEvent.stopPropagation();\r\n                    let edgeIndex=that.draggedEdgeIndex\r\n                    let segIndex=that.draggedEdgeSeg\r\n\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n                    that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x2\",event.x)\r\n                        .attr(\"y2\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\"line\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"x1\",event.x)\r\n                        .attr(\"y1\",event.y)\r\n\r\n                    d3.select(svgid).selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                            let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                            return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                        })\r\n                        // .attr(\"stroke\",\"blue\")\r\n                        .attr(\"cx\",event.x)\r\n                        .attr(\"cy\",event.y)\r\n\r\n                }\r\n\r\n                function dragendEdge(event){\r\n                    // console.log(\"end!\")\r\n                    that.draggedEdgeSeg=-1\r\n                    that.draggedEdgeIndex=-1\r\n                }\r\n\r\n                var dragEdge = d3.drag()\r\n                    .on(\"start\",dragstartEdge)\r\n                    .on(\"drag\",draggedEdge)\r\n                    .on(\"end\",dragendEdge)\r\n\r\n                function handleMouseDown(event){\r\n                    if(event.button==2){\r\n                        let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n                        d3.select(svgid).select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                            })\r\n                            .remove()\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\".controlPoints\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                            })\r\n                            .attr(\"edgeindex\",function(){\r\n                                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                            })\r\n\r\n                        d3.select(svgid)\r\n                            .select(\"#edgeGroup\")\r\n                            .selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                            })\r\n                            .attr(\"index\",function(){\r\n                                return parseInt(d3.select(this).attr(\"index\"))-1\r\n                            })\r\n                        that.edges.splice(deleteindex,1)\r\n\r\n                        for (let i=0;i<that.edges.length;i++){\r\n                            that.edges[i].id=i\r\n                        }\r\n                    }\r\n                }*/\r\n\r\n        d3.selectAll(\"line\").remove()\r\n\r\n        d3.selectAll(\".controlPoints\").remove()\r\n\r\n\r\n        for (let i=0;i<this.edges.length;i++){\r\n            /*            let start=this.edges[i].start\r\n                        let end=this.edges[i].end\r\n\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        // this.nodeStartDict[start].push(i)\r\n                        // this.nodeEndDict[end].push(i)\r\n                        let index=i\r\n                        if(this.edges[i].virtrual){\r\n                            let vpoints=this.edges[i].virtrualNodes\r\n                            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n                            let vend\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                vend=vpoints[v]\r\n                                let newline=d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"line\")\r\n                                    .attr(\"x1\",vstart[0])\r\n                                    .attr(\"y1\",vstart[1])\r\n                                    .attr(\"x2\",vend[0])\r\n                                    .attr(\"y2\",vend[1])\r\n                                    .attr(\"stroke-width\",2)\r\n                                    .attr(\"stroke\",\"black\")\r\n                                    .attr(\"index\",i)\r\n                                    .attr(\"isvirtrual\",true)\r\n                                    .attr(\"segindex\",v)\r\n                                    .on(\"mouseover\",function(d,i){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"red\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        let thisindex=d3.select(this).attr(\"index\")\r\n                                        d3.selectAll(\"line\")\r\n                                            .filter(function(){\r\n                                                return d3.select(this).attr(\"index\")==thisindex\r\n                                            })\r\n                                            .attr(\"stroke\",\"black\")\r\n                                        console.log(that.edges[thisindex])\r\n                                    })\r\n                                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                                    .call(dragEdge)\r\n                                vstart=vend\r\n                                if(v==0){\r\n                                    this.nodeStartDict[start].push(newline)\r\n                                }\r\n                            }\r\n                            vend=[this.pointData[end].x,this.pointData[end].y]\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",vstart[0])\r\n                                .attr(\"y1\",vstart[1])\r\n                                .attr(\"x2\",vend[0])\r\n                                .attr(\"y2\",vend[1])\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",true)\r\n                                .attr(\"segindex\",vpoints.length)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeEndDict[end].push(newline)\r\n                            // console.log()\r\n                            for (let v=0;v<vpoints.length;v++){\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .append(\"circle\")\r\n                                    .attr(\"class\",\"controlPoints\")\r\n                                    .attr(\"cx\",vpoints[v][0])\r\n                                    .attr(\"cy\",vpoints[v][1])\r\n                                    .attr(\"r\",5)\r\n                                    .attr(\"edgeindex\",i)\r\n                                    .attr(\"segindex\",v)\r\n                                    .attr(\"fill\",\"red\")\r\n                                    .attr(\"opacity\",0)\r\n                                    // .attr(\"display\",\"none\")\r\n                                    .on(\"mouseover\",function(){\r\n                                        d3.select(this).attr(\"opacity\",1)\r\n                                    })\r\n                                    .on(\"mouseout\",function(){\r\n                                        d3.select(this).attr(\"opacity\",0)\r\n                                    })\r\n                                    .call(dragControlPoint)\r\n\r\n                            }\r\n                        }\r\n                        else{\r\n                            let newline=d3.select(svgid)\r\n                                .select(\"#edgeGroup\")\r\n                                .append(\"line\")\r\n                                .attr(\"x1\",this.pointData[start].x)\r\n                                .attr(\"y1\",this.pointData[start].y)\r\n                                .attr(\"x2\",this.pointData[end].x)\r\n                                .attr(\"y2\",this.pointData[end].y)\r\n                                .attr(\"stroke-width\",2)\r\n                                .attr(\"stroke\",\"black\")\r\n                                .attr(\"index\",i)\r\n                                .attr(\"isvirtrual\",false)\r\n                                .on(\"mouseover\",function(d,i){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"red\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mouseout\",function(){\r\n                                    let thisindex=d3.select(this).attr(\"index\")\r\n                                    d3.selectAll(\"line\")\r\n                                        .filter(function(){\r\n                                            return d3.select(this).attr(\"index\")==thisindex\r\n                                        })\r\n                                        .attr(\"stroke\",\"black\")\r\n                                    console.log(that.edges[thisindex])\r\n                                })\r\n                                .on(\"mousedown\",handleMouseDown)\r\n                                .call(dragEdge)\r\n\r\n                            this.nodeStartDict[start].push(newline)\r\n                            this.nodeEndDict[end].push(newline)\r\n                        }*/\r\n\r\n            this.drawOneEdge(i)\r\n\r\n        }\r\n        // console.log(JSON.stringify(this.edges))\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    savePointData(){\r\n        let that=this\r\n        d3.selectAll(\"circle\")\r\n            .each(function(){\r\n                let x=d3.select(this).attr(\"cx\")\r\n                let y=d3.select(this).attr(\"cy\")\r\n                let index=d3.select(this).attr(\"index\")\r\n                that.pointData[index].x=parseFloat(x)\r\n                that.pointData[index].y=parseFloat(y)\r\n                that.pointData[index].cat=that.pointData[index].cat.toString()\r\n            })\r\n    }\r\n\r\n    saveEdgeData(){\r\n        let savedData=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(!this.edges[i].isdelete){\r\n                this.edges[i].index=savedData.length\r\n                savedData.push(this.edges[i])\r\n            }\r\n        }\r\n        this.edges=savedData\r\n        // console.log(this.edges)\r\n        // d3.selectAll(\"line\").remove()\r\n        // let that=this\r\n        // for(let i=0;i<this.edges.length;i++){\r\n        //     let node1=this.edges[i].start\r\n        //     let node2=this.edges[i].end\r\n        //\r\n        //     d3.select(svgid).append(\"line\")\r\n        //         .attr(\"x1\",this.pointData[node1].x)\r\n        //         .attr(\"y1\",this.pointData[node1].y)\r\n        //         .attr(\"x2\",this.pointData[node2].x)\r\n        //         .attr(\"y2\",this.pointData[node2].y)\r\n        //         .attr(\"stroke-width\",2)\r\n        //         .attr(\"stroke\",\"black\")\r\n        //         .attr(\"index\",i)\r\n        //         .on(\"click\",function(){\r\n        //             let removeindex=d3.select(this).attr(\"index\")\r\n        //             that.edges[removeindex].isdelete=true\r\n        //             d3.select(this).remove()\r\n        //             console.log(that.edges)\r\n        //         })\r\n        // }\r\n    }\r\n    loadEdgeData(){\r\n        let that=this\r\n        fetch('/data/manuallyDataEdge.txt',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                console.log(data)\r\n                this.edges=data\r\n                let that=this\r\n                for(let i=0;i<this.edges.length;i++){\r\n                    let node1=this.edges[i].start\r\n                    let node2=this.edges[i].end\r\n\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",i)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                        })\r\n                }\r\n\r\n            })\r\n    }\r\n\r\n    clickItem(event){\r\n        if(!this.isSelect){\r\n            this.isSelect=true\r\n            this.selectItem=d3.select(event.target).attr(\"index\")\r\n        }\r\n        else{\r\n            if(d3.select(event.target).attr(\"index\")!=this.selectItem){\r\n                let node1=this.selectItem\r\n                let node2=d3.select(event.target).attr(\"index\")\r\n                if(this.pointData[node1].cat==this.pointData[node2].cat){\r\n                    this.isSelect=false\r\n                    this.selectItem=null\r\n                    this.edges.push({\r\n                        start:node1,\r\n                        end:node2,\r\n                        index:this.edges.length,\r\n                        isdelete:false\r\n                    })\r\n                    let that=this\r\n                    d3.select(svgid).append(\"line\")\r\n                        .attr(\"x1\",this.pointData[node1].x)\r\n                        .attr(\"y1\",this.pointData[node1].y)\r\n                        .attr(\"x2\",this.pointData[node2].x)\r\n                        .attr(\"y2\",this.pointData[node2].y)\r\n                        .attr(\"stroke-width\",2)\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"index\",this.edges.length-1)\r\n                        .on(\"click\",function(){\r\n                            let removeindex=d3.select(this).attr(\"index\")\r\n                            that.edges[removeindex].isdelete=true\r\n                            d3.select(this).remove()\r\n                        })\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        d3.selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        d3.selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    optimizeMST(isedit){\r\n\r\n        this.clustergraphInfo={}\r\n        let newGraph=new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<newGraph.V;i++){\r\n            newGraph.node(i).label=this.pointData[i].cat\r\n        }\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start=this.edges[i].start\r\n            let end=this.edges[i].end\r\n            let cat=this.edges[i].cat\r\n            newGraph.addEdge(start,end)\r\n            // this.clustergraphInfo[cat].edgesnum+=1\r\n        }\r\n\r\n        this.graph=newGraph\r\n        //find Connected Components\r\n        var cc = new jsgraphs.ConnectedComponents(newGraph);\r\n\r\n        //create new clusterDict with connected components\r\n        let newClusterDict={}\r\n        for (let k in this.catPointDict){\r\n            newClusterDict[k]=[]\r\n        }\r\n        let clusterArr=[]\r\n        for (let i=0;i<cc.componentCount();i++){\r\n            clusterArr.push([])\r\n        }\r\n        for (var v = 0; v < newGraph.V; v++) {\r\n            let point=this.pointData[v]\r\n            let comid=cc.componentId(v)\r\n            clusterArr[comid].push(point)\r\n        }\r\n        for(let i=0;i<clusterArr.length;i++){\r\n            let cat=clusterArr[i][0].cat\r\n            newClusterDict[cat].push(clusterArr[i])\r\n        }\r\n        this.clusterDict=newClusterDict\r\n        // console.log(newClusterDict)\r\n\r\n        for (let k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n        }\r\n\r\n        clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n            }\r\n\r\n        }\r\n\r\n        this.clusterArr=clusterArr\r\n        // console.log(this.clusterArr)\r\n        let g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n\r\n        //update boundingbox of points\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n        if(!isedit){\r\n            let newEdges=this.recalculateSpanningTree()\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n\r\n            // this.drawEdges()\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdge(newEdges[i])\r\n                this.edges[newEdges[i]].new = true\r\n                //let tmpe = clone(this.edges[newEdges[i]])\r\n                //tmpe.id = newEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                //addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            this.draggedIndex=-1\r\n            this.deletedEdge=[]\r\n            this.addedEdge=[]\r\n            this.setState({\r\n                pointData:this.pointData,\r\n                edges:this.edges\r\n            })\r\n        }\r\n        else{\r\n            let tempedges=[]\r\n            for (let i=0;i<this.edges.length;i++){\r\n                /*                tempedges.push(\r\n                                    {\r\n                                        start:this.edges[i].start,\r\n                                        end:this.edges[i].end,\r\n                                        weight:this.edges[i].weight,\r\n                                        cat:this.edges[i].cat,\r\n                                        dis:this.edges[i].dis,\r\n                                        virtrual:this.edges[i].virtrual,\r\n                                        virtrualNodes:this.edges[i].virtrualNodes,\r\n                                        isLocalTree:this.edges[i].isLocalTree\r\n                                    }\r\n                                )*/\r\n                tempedges.push(this.edges[i])\r\n            }\r\n\r\n            let newEdges=this.recalculateSpanningTreeAfterEdit(tempedges)\r\n            // this.hierarchicalMergeV2()\r\n            // console.log(this.clustergraphInfo)\r\n            // this.drawEdges()\r\n            d3.selectAll(\".deleteOpEdge\")\r\n                .remove()\r\n\r\n            tmpEditEdges = []\r\n            for(let i=0;i<newEdges.length;i++){\r\n                this.drawOneEdgeAfterEdit(tempedges,newEdges[i])\r\n                //console.log(\"newEdges:\")\r\n                //console.log(this.edges)\r\n                //console.log(tempedges)\r\n                //console.log(newEdges[i])\r\n                let tmpe = clone(tempedges[newEdges[i]])\r\n                tmpe.id = newEdges[i]\r\n                tmpe.flag = true\r\n                tmpEditEdges.push(tmpe)\r\n            }\r\n            this.tempEdges=tempedges\r\n            // console.log(this.edges.length,this.tempEdges.length)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    sufaceRoutingAll(){\r\n        for (let ei=0;ei<this.edges.length;ei++){\r\n            let thisedge=this.edges[ei]\r\n            let startp=this.pointData[thisedge.start.id]\r\n            let endp=this.pointData[thisedge.end.id]\r\n            let pcat=this.pointData[thisedge.start.id].cat\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[ei].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[ei].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[ei].virtrualNodes=virtrualNodes\r\n        }\r\n\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        if(virtrualNodes.length==0){\r\n            edge.virtrual=false\r\n        }\r\n        return edge\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n\r\n        let crossnum=0\r\n        let start = this.pointData[index1]\r\n        let end = this.pointData[index2]\r\n        for(let e=0;e<this.edges.length;e++){\r\n            let e1=this.pointData[this.edges[e].start]\r\n            let e2=this.pointData[this.edges[e].end]\r\n            if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                crossnum+=1\r\n            }\r\n        }\r\n        //cal distance\r\n        let distance=this.calDistance(start, end)\r\n        //cal num of other points\r\n        let mess=this.calEdgeMess(start, end)\r\n        let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n        newedge.score = score\r\n\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function dragstartControlpoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag start control point!\")\r\n            //console.log(index)\r\n            editEdges = []\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(that.pointData[that.edges[index].start])\r\n            tmpe.endpoint = clone(that.pointData[that.edges[index].end])\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n        }\r\n        function draggedControlPoint(event){\r\n            let edgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n            that.edges[edgeindex].virtrualNodes[segindex][0]=event.x\r\n            that.edges[edgeindex].virtrualNodes[segindex][1]=event.y\r\n            let idx = \"#\" + d3.select(this).attr(\"id\")\r\n            //console.log(\"dragged control point\")\r\n            //console.log(idx)\r\n            d3.selectAll(idx)\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex\r\n                })\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==edgeindex&&parseInt(d3.select(this).attr(\"segindex\"))==segindex+1\r\n                })\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n        }\r\n        function dragendControlPoint(){\r\n            let index=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n            //console.log(\"drag end control point!\")\r\n            //console.log(index)\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.id = index\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var dragControlPoint = d3.drag()\r\n            .on(\"start\",dragstartControlpoint)\r\n            .on(\"drag\",draggedControlPoint)\r\n            .on(\"end\",dragendControlPoint)\r\n\r\n        function dragstartEdge(event){\r\n            // console.log(\"start!\")\r\n            let index=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            let start=that.pointData[that.edges[index].start]\r\n            let end=that.pointData[that.edges[index].end]\r\n\r\n            editEdges = []\r\n//\r\n            let tmpe = clone(that.edges[index])\r\n            tmpe.startpoint = clone(start)\r\n            tmpe.endpoint = clone(end)\r\n            tmpe.flag = false\r\n            editEdges.push(tmpe)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n\r\n            if(d3.select(this).attr(\"isvirtrual\")==\"true\"){\r\n                let segindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                that.edges[index].virtrualNodes.splice(segindex,0,[event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=segindex\r\n            }\r\n            else{\r\n                that.edges[index].virtrual=true\r\n                that.edges[index].virtrualNodes.push([event.x,event.y])\r\n                that.draggedEdgeIndex=index\r\n                that.draggedEdgeSeg=0\r\n            }\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==index\r\n                })\r\n                .remove()\r\n\r\n            /*            for (let j=0;j<that.edges[index].SVGElement.length;j++){\r\n                            that.edges[index].SVGElement[j].remove()\r\n                        }*/\r\n\r\n            that.edges[index].SVGElement=[]\r\n\r\n            let vpoints=that.edges[index].virtrualNodes\r\n            let nowp=[start.x,start.y]\r\n            let nextp=[]\r\n            for(let i=0;i<vpoints.length;i++){\r\n                nextp=vpoints[i]\r\n                let newedge=d3.select(svgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n\r\n                d3.select(opsvgid).select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",nowp[0])\r\n                    .attr(\"y1\",nowp[1])\r\n                    .attr(\"x2\",nextp[0])\r\n                    .attr(\"y2\",nextp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",i)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    .call(dragEdge)\r\n\r\n                that.edges[index].SVGElement.push(newedge)\r\n                nowp=nextp\r\n            }\r\n            let newline=d3.select(svgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid).select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",nowp[0])\r\n                .attr(\"y1\",nowp[1])\r\n                .attr(\"x2\",end.x)\r\n                .attr(\"y2\",end.y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n                .call(dragEdge)\r\n\r\n\r\n            that.edges[index].SVGElement.push(newline)\r\n\r\n\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"id\",\"e\"+index.toString()+\"s\"+v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function draggedEdge(event){\r\n            // console.log(\"drag!\")\r\n            if(that.draggedEdgeIndex==-1)\r\n                return\r\n            event.sourceEvent.stopPropagation();\r\n            let edgeIndex=that.draggedEdgeIndex\r\n            let segIndex=that.draggedEdgeSeg\r\n\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][0]=event.x\r\n            that.edges[edgeIndex].virtrualNodes[segIndex][1]=event.y\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x2\",event.x)\r\n                .attr(\"y2\",event.y)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"index\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg+1\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"x1\",event.x)\r\n                .attr(\"y1\",event.y)\r\n\r\n            d3.selectAll(\".controlPoints\")\r\n                .filter(function(){\r\n                    let thisedgeindex=parseInt(d3.select(this).attr(\"edgeindex\"))\r\n                    let thissegindex=parseInt(d3.select(this).attr(\"segindex\"))\r\n                    return thisedgeindex==that.draggedEdgeIndex&&thissegindex==that.draggedEdgeSeg\r\n                })\r\n                // .attr(\"stroke\",\"blue\")\r\n                .attr(\"cx\",event.x)\r\n                .attr(\"cy\",event.y)\r\n\r\n        }\r\n\r\n        function dragendEdge(event){\r\n            // console.log(\"end!\")\r\n            let i = that.draggedEdgeIndex\r\n            let tmpe = clone(that.edges[i])\r\n            tmpe.id = i\r\n            tmpe.flag = true\r\n            editEdges.push(tmpe)\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n//\r\n//\r\n            editPoints = []\r\n            editEdges = []\r\n\r\n\r\n            that.draggedEdgeSeg=-1\r\n            that.draggedEdgeIndex=-1\r\n            //that.child.getData()\r\n        }\r\n\r\n        var dragEdge = d3.drag()\r\n            .on(\"start\",dragstartEdge)\r\n            .on(\"drag\",draggedEdge)\r\n            .on(\"end\",dragendEdge)\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                that.setState({\r\n                    hasEdit:true\r\n                })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n\r\n                let tmpe = clone(that.edges[deleteindex])\r\n                tmpe.startpoint = clone(that.pointData[start])\r\n                tmpe.endpoint = clone(that.pointData[end])\r\n                tmpe.flag = false\r\n                editEdges.push(tmpe)\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n                if(that.child.bubbleState()){\r\n                    //console.log(\"delete one edge\")\r\n                    //console.log(editEdges)\r\n                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                }\r\n\r\n\r\n                editPoints = []\r\n                editEdges = []\r\n\r\n                that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n\r\n                that.optimizeMST(true)\r\n\r\n                for (var k in that.catPointDict){\r\n                    that.findCircle(k)\r\n                }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n            //else if(event.button == 1){\r\n            //    that.child.handleEdgeWidth(event, this)\r\n            //}\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    .call(dragEdge)\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    .attr(\"id\",\"e\" + index.toString() + \"s\" + v.toString())\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let idx = \"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"opacity\",0)\r\n                    })\r\n                    .call(dragControlPoint)\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n                .call(dragEdge)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    applyEdit(){\r\n        this.edges=this.tempEdges\r\n        this.deletedEdge=[]\r\n        this.addedEdge=[]\r\n\r\n        this.drawEdges()\r\n        this.setState({\r\n            hasEdit:false,\r\n            edges:this.edges,\r\n            pointData:this.pointData\r\n        })\r\n\r\n        //console.log(\"applyEdit\")\r\n        //console.log(tmpEditEdges)\r\n        //console.log(this.edges)\r\n\r\n        //let tmprealEditEdges = []\r\n//\r\n        //for(let i = 0; i < this.edges.length;i ++){\r\n        //    for(let j = 0; j < tmpEditEdges.length; j ++){\r\n        //        if(this.edges[i].start == tmpEditEdges[j].start && this.edges[i].end == tmpEditEdges[j].end){\r\n        //            let tmpe = clone(this.edges[i])\r\n        //            tmpe.flag = true\r\n        //            tmpe.id = i\r\n        //            tmprealEditEdges.push(tmpe)\r\n        //            break;\r\n        //        }\r\n        //    }\r\n        //}\r\n\r\n        if(this.child.bubbleState()){\r\n            this.child.editReDraw([], tmpEditEdges, this.pointData, this.edges)\r\n        }\r\n\r\n        tmpEditEdges = []\r\n    }\r\n\r\n    drawOneEdgeAfterEdit(edges,index){\r\n\r\n        edges[index].SVGElement=[]\r\n        let oneEdge=edges[index]\r\n        let that=this\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                d3.selectAll(\".deleteOpEdge\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                    })\r\n                    .remove()\r\n                let start=edges[deleteindex].start\r\n                let end=edges[deleteindex].end\r\n                that.deletedEdge.push([start,end])\r\n\r\n                // that.deleteEdge(deleteindex)\r\n                that.optimizeMST(true)\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.select(svgid).select(\"#edgeGroup\").selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .append(\"line\")\r\n                    .attr(\"class\",\"deleteOpEdge\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",5)\r\n                    .attr(\"stroke\",\"red\")\r\n                    .attr(\"stroke-dasharray\",\"5,3\")\r\n                    .attr(\"opacity\",0.5)\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\".deleteOpEdge\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"opacity\",0.5)\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,3\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            // console.log()\r\n        }\r\n        else{\r\n            let newline=d3.select(svgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            d3.select(opsvgid)\r\n                .select(\"#edgeGroup\")\r\n                .append(\"line\")\r\n                .attr(\"class\",\"deleteOpEdge\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",5)\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-dasharray\",\"5,2\")\r\n                .attr(\"opacity\",0.5)\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",1)\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\".deleteOpEdge\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"opacity\",0.5)\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n        }\r\n\r\n\r\n    }\r\n\r\n    checkCircle(k){\r\n        let catEdges=[]\r\n        let nodeDegree={}\r\n        for (let i=0;i<this.edges.length;i++){\r\n            if(this.edges[i].cat==k){\r\n                catEdges.push(this.edges[i])\r\n                let start=this.edges[i].start\r\n                let end=this.edges[i].end\r\n                if(!nodeDegree.hasOwnProperty(start)){\r\n                    nodeDegree[start]=[]\r\n                }\r\n                nodeDegree[start].push(i)\r\n                if(!nodeDegree.hasOwnProperty(end)){\r\n                    nodeDegree[end]=[]\r\n                }\r\n                nodeDegree[end].push(i)\r\n            }\r\n        }\r\n        let finish=false\r\n        while(!finish){\r\n            finish=true\r\n            for(var p in nodeDegree){\r\n                if(nodeDegree[p].length==1){\r\n                    finish=false\r\n                    let index=nodeDegree[p][0]\r\n                    let start=this.edges[index].start\r\n                    let end=this.edges[index].end\r\n                    for (let i=0;i<nodeDegree[start].length;i++){\r\n                        if(nodeDegree[start][i]==index){\r\n                            nodeDegree[start].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                    for (let i=0;i<nodeDegree[end].length;i++){\r\n                        if(nodeDegree[end][i]==index){\r\n                            nodeDegree[end].splice(i,1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let circleEdges=[]\r\n        for (var p in nodeDegree){\r\n            if(nodeDegree[p].length>0){\r\n                for (let i=0;i<nodeDegree[p].length;i++){\r\n                    let edgeindex=nodeDegree[p][i]\r\n                    let has=false\r\n                    for (let j=0;j<circleEdges.length;j++){\r\n                        if(circleEdges[j]==edgeindex){\r\n                            has=true\r\n                            break\r\n                        }\r\n                    }\r\n                    if(!has){\r\n                        circleEdges.push(edgeindex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        // console.log(nodeDegree,circleEdges)\r\n        return circleEdges\r\n    }\r\n\r\n    findCircle(lastcat){\r\n        let that=this\r\n        let circleEdges=that.checkCircle(lastcat)\r\n        if(circleEdges.length>0){\r\n            let scores=[]\r\n            for (let i=0;i<circleEdges.length;i++){\r\n                let index=circleEdges[i]\r\n\r\n                let start=that.pointData[that.edges[index].start]\r\n                let end=that.pointData[that.edges[index].end]\r\n                let crossnum=0\r\n                if(that.isAdded(that.edges[index].start,that.edges[index].end)){\r\n                    scores.push(-1)\r\n                }\r\n                else{\r\n                    for (let e=0;e<that.edges.length;e++){\r\n                        let e1=that.pointData[that.edges[e].start]\r\n                        let e2=that.pointData[that.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&that.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //cal distance\r\n                    let distance=that.calDistance(start,end)\r\n                    //cal num of other points\r\n                    let mess=that.calEdgeMess(start,end)\r\n                    let score=weightCross*crossnum+weightDistance*distance/that.maxDis+weightMess*mess\r\n                    scores.push(score)\r\n                }\r\n\r\n                /*                                    d3.select(svgid)\r\n                                                        .select(\"#edgeGroup\")\r\n                                                        .selectAll(\"line\")\r\n                                                        .filter(function(){\r\n                                                            return parseInt(d3.select(this).attr(\"index\"))==index\r\n                                                        })\r\n                                                        .attr(\"stroke\",\"blue\")\r\n                                                        .on(\"mouseover\",function(){\r\n                                                            console.log(scores[i])\r\n                                                        })*/\r\n            }\r\n\r\n            let worstindex=-1\r\n            let worstscore=-100\r\n            for (let i=0;i<scores.length;i++){\r\n                if(scores[i]>worstscore){\r\n                    worstscore=scores[i]\r\n                    worstindex=i\r\n                }\r\n            }\r\n            let worstEdge=that.edges[circleEdges[worstindex]]\r\n\r\n            //let tmpe = clone(worstEdge)\r\n            //tmpe.startpoint = clone(worstEdge.start)\r\n            //tmpe.endpoint = clone(worstEdge.end)\r\n            //tmpe.flag = false\r\n            //tmpEditEdges.push(tmpe)\r\n\r\n\r\n            //console.log(\"WorstEdge: \")\r\n            //console.log(circleEdges)\r\n            //console.log(worstEdge)\r\n            //console.log(that.edges)\r\n\r\n            d3.selectAll(\"line\")\r\n                .filter(function(){\r\n                    return parseInt(d3.select(this).attr(\"index\"))==worstEdge.id\r\n                })\r\n                .attr(\"stroke\",\"red\")\r\n                .attr(\"stroke-width\",5)\r\n            // console.log(weightMess)\r\n\r\n        }\r\n    }\r\n\r\n    drawPointData(){\r\n        colors = this.props.colorArray\r\n        this.setState({\r\n            colorArray:colors\r\n        })\r\n\r\n        d3.selectAll(\"circle\").remove();\r\n        d3.selectAll(\"rect\").remove();\r\n        svg = d3.select(svgid);\r\n        svg.call(d3.zoom()\r\n            .extent([[offsetX, offsetY], [viewWidth, viewHeight]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        var reroutingEPS=80\r\n\r\n        function zoomed({transform}) {\r\n            d3.selectAll('g').attr(\"transform\", transform);\r\n        }\r\n\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            let svg=d3.select(svgid)\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n\r\n            // console.log(POINT_EDGE_EPS,DBSCAN_EPS)\r\n            if(that.itemShape==\"circle\"){\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                let id = \"#\" + d3.select(this).attr(\"id\")\r\n                d3.selectAll(id)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n            //let tmpp1 = clone(that.pointData[nodeindex])\r\n            //tmpp1.flag = false;\r\n            //editPoints.push(tmpp1)\r\n            //subOldPoints.push(tmpp1)\r\n\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n\r\n            //let tmpp = clone(that.pointData[nodeindex])\r\n            //tmpp.id = nodeindex\r\n            //tmpp.flag = true\r\n            //editPoints.push(tmpp)\r\n            //addNewPoints.push(tmpp)\r\n\r\n            let deleteEdges=[]\r\n            let reroutingEdges=[]\r\n            let thiscat=that.pointData[nodeindex].cat\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let startpoint=that.pointData[that.edges[i].start]\r\n                let endpoint=that.pointData[that.edges[i].end]\r\n                let pointedgedis=PointToSegDist(event.x,event.y,startpoint.x,startpoint.y,endpoint.x,endpoint.y)\r\n                if(that.edges[i].start==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(tmpp1)\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(that.edges[i].end==nodeindex){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(tmpp1)\r\n                    //tmpe.flag = false;\r\n                    ////subOldEdges.push(tmpe)\r\n                    //editEdges.push(tmpe)\r\n                }\r\n                else if((thiscat==that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2)){\r\n                    deleteEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n                else if(thiscat!=that.edges[i].cat&&pointedgedis>=0&&pointedgedis<POINT_EDGE_EPS*2){\r\n                    reroutingEdges.push(i)\r\n\r\n                    //let tmpe = clone(that.edges[i])\r\n                    //tmpe.startpoint = clone(that.pointData[tmpe.start]);\r\n                    //tmpe.endpoint = clone(that.pointData[tmpe.end]);\r\n                    //tmpe.flag = false;\r\n                    //editEdges.push(tmpe)\r\n                    ////subOldEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // console.log(deleteEdges)\r\n\r\n            for(let i=0;i<deleteEdges.length;i++){\r\n                that.deleteEdge(deleteEdges[i])\r\n                for(let j=i+1;j<deleteEdges.length;j++){\r\n                    if(deleteEdges[i]<deleteEdges[j]){\r\n                        deleteEdges[j]=deleteEdges[j]-1\r\n                    }\r\n                }\r\n                for(let j=i+1;j<reroutingEdges.length;j++){\r\n                    if(deleteEdges[i]<reroutingEdges[j]){\r\n                        reroutingEdges[j]=reroutingEdges[j]-1\r\n                    }\r\n                }\r\n            }\r\n\r\n            that.optimizeMST(false)\r\n\r\n            for (let i=0;i<reroutingEdges.length;i++){\r\n\r\n\r\n                let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                tmpe.startpoint = clone(that.pointData[tmpe.start])\r\n                tmpe.endpoint = clone(that.pointData[tmpe.end])\r\n                tmpe.flag = false\r\n                that.edges[reroutingEdges[i]].preEdge = clone(tmpe)\r\n                that.edges[reroutingEdges[i]].new = true\r\n                that.edges[reroutingEdges[i]].rerouting = true\r\n\r\n\r\n                that.surfaceRoutingEdge(that.edges[reroutingEdges[i]])\r\n                d3.selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n                d3.selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))==reroutingEdges[i]\r\n                    })\r\n                    .remove()\r\n\r\n                that.drawOneEdge(reroutingEdges[i])\r\n\r\n\r\n\r\n                //let tmpe = clone(that.edges[reroutingEdges[i]])\r\n                //tmpe.id = reroutingEdges[i]\r\n                //tmpe.flag = true\r\n                //editEdges.push(tmpe)\r\n                // addNewEdges.push(tmpe)\r\n\r\n            }\r\n\r\n            //that.child.getData()\r\n            //for(let idx1 = 0; idx1 < addNewPoints.length; idx1 ++){\r\n            //    for(let idx2 = 0; idx2 < that.edges.length; idx2 ++){\r\n            //        if(that.edges[idx2].start == addNewPoints[idx1].id || that.edges[idx2].end == addNewPoints[idx1].id){\r\n            //            let tmpe = clone(that.edges[idx2])\r\n            //            tmpe.id = idx2\r\n            //            addNewEdges.push(tmpe)\r\n            //            //console.log(\"flagflagflag\")\r\n            //        }\r\n            //    }\r\n            //}\r\n\r\n\r\n\r\n\r\n\r\n            // d3.select(this).attr(\"stroke\",\"none\")\r\n\r\n        }\r\n\r\n        function dragstart() {\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            // that.draggedIndex=parseInt(d3.select(this).attr(\"index\"))\r\n            let nodeindex=parseInt(d3.select(this).attr(\"index\"))\r\n            that.draggedIndex=nodeindex\r\n\r\n            preEdgeDict = {}\r\n            preEdges = []\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                that.edges[i].new = false;\r\n                that.edges[i].rerouting = false;\r\n                that.edges[i].startpoint = clone(that.pointData[st])\r\n                that.edges[i].endpoint = clone(that.pointData[en])\r\n\r\n                if(!preEdgeDict.hasOwnProperty(st)){\r\n                    preEdgeDict[st] = {}\r\n                }\r\n                preEdgeDict[st][en] = i\r\n\r\n                preEdges.push(clone(that.edges[i]))\r\n            }\r\n\r\n            // add old point\r\n            let tmpp1 = clone(that.pointData[nodeindex])\r\n            prePoint = tmpp1\r\n            tmpp1.flag = false\r\n            editPoints.push(tmpp1)\r\n\r\n            //preEdges = clone(that.edges)\r\n\r\n            //delete linked edges\r\n            /*            let newedges=[]\r\n            let deleteindex=[]\r\n            for(let i=0;i<that.edges.length;i++){\r\n                let start=that.edges[i].start\r\n                let end=that.edges[i].end\r\n                if(start==nodeindex||end==nodeindex){\r\n                    console.log(i)\r\n                    d3.select(svgid)\r\n                        .select(\"#edgeGroup\")\r\n                        .selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"index\"))==i\r\n                        })\r\n                        // .attr(\"stroke\",\"red\")\r\n                        .remove()\r\n                    deleteindex.push(i)\r\n                    d3.select(svgid).select(\"#edgeGroup\")\r\n                        .selectAll(\".controlPoints\")\r\n                        .filter(function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))==i\r\n                        })\r\n                        // .attr(\"opacity\",1)\r\n                        .remove()\r\n                }\r\n                else{\r\n                    newedges.push(that.edges[i])\r\n                }\r\n            }\r\n            let influencedEdges=[]\r\n            let influencedControlPoints=[]\r\n            for (let i=0;i<deleteindex.length;i++) {\r\n                let idx=deleteindex[i]\r\n                let inflines=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\"line\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))>idx\r\n                    })\r\n                influencedEdges.push(inflines)\r\n\r\n                let infpoints=d3.select(svgid)\r\n                    .select(\"#edgeGroup\")\r\n                    .selectAll(\".controlPoints\")\r\n                    .filter(function(){\r\n                        return parseInt(d3.select(this).attr(\"edgeindex\"))>idx\r\n                    })\r\n                influencedControlPoints.push(infpoints)\r\n            }\r\n                for (let i=0;i<influencedEdges.length;i++){\r\n                    let infedges=influencedEdges[i]\r\n                    infedges.attr(\"index\",function(){\r\n                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                    })\r\n            }\r\n                for(let i=0;i<influencedControlPoints.length;i++){\r\n                    let infcpoints=influencedControlPoints[i]\r\n                    infcpoints.attr(\"edgeindex\",function(){\r\n                            return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                        })\r\n                }\r\n\r\n            that.edges=newedges\r\n            for(let i=0;i<that.edges.length;i++){\r\n                that.edges[i].id=i\r\n            }*/\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        function dragend(){\r\n            let nodeindex = parseInt(d3.select(this).attr(\"index\"))\r\n            let id = \"#\" + d3.select(this).attr(\"id\")\r\n            d3.selectAll(id).attr(\"stroke\",\"none\")\r\n\r\n            // add new point\r\n            let tmpp = clone(that.pointData[nodeindex])\r\n            tmpp.id = nodeindex\r\n            tmpp.flag = true\r\n            editPoints.push(tmpp)\r\n\r\n            /*\r\n            // delete old edges\r\n            let thiscat = that.pointData[nodeindex].cat\r\n            let ex = that.pointData[nodeindex].x\r\n            let ey = that.pointData[nodeindex].y\r\n            //let updateidx = {}\r\n            for(let i = 0;i < preEdges.length; i ++){\r\n                let startpoint=that.pointData[preEdges[i].start]\r\n                let endpoint=that.pointData[preEdges[i].end]\r\n                let pointedgedis=PointToSegDist(ex, ey, startpoint.x, startpoint.y, endpoint.x, endpoint.y)\r\n                if(preEdges[i].start==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = clone(prePoint)\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if(preEdges[i].end==nodeindex){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = clone(prePoint)\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                }\r\n                else if((thiscat == preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2)){\r\n\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.startpoint = that.pointData[tmpe.start]\r\n                    tmpe.endpoint = that.pointData[tmpe.end]\r\n                    tmpe.flag = false;\r\n                    editEdges.push(tmpe)\r\n                    //subOldEdges.push(tmpe)\r\n\r\n                    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                    //    updateidx[preEdges[i].start] = {}\r\n                    //}\r\n//\r\n                    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n\r\n                }\r\n\r\n                //else if(thiscat != preEdges[i].cat && pointedgedis >= 0 && pointedgedis < POINT_EDGE_EPS * 2){\r\n//\r\n                //    let tmpe = clone(preEdges[i])\r\n                //    tmpe.startpoint = that.pointData[tmpe.start]\r\n                //    tmpe.endpoint = that.pointData[tmpe.end]\r\n                //    tmpe.flag = false;\r\n                //    editEdges.push(tmpe)\r\n                //    //subOldEdges.push(tmpe)\r\n//\r\n                //    //if(!updateidx.hasOwnProperty(preEdges[i].start)){\r\n                //    //    updateidx[preEdges[i].start] = {}\r\n                //    //}\r\n////\r\n                //    //updateidx[preEdges[i].start][preEdges[i].end] = 2\r\n//\r\n                //}\r\n\r\n\r\n            }\r\n\r\n            // add new edges and rerouting edges\r\n            for(let i = 0;i < that.edges.length; i ++){\r\n\r\n                //if(that.edges[i].hasOwnProperty(\"new\")){\r\n                if(that.edges[i].new == true){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    if(that.edges[i].rerouting == true){\r\n                        let tmpe = clone(that.edges[i].preEdge)\r\n                        tmpe.flag = false\r\n                        editEdges.push(tmpe)\r\n                    }\r\n                }\r\n                //}\r\n\r\n\r\n                //let s = that.edges[i].start\r\n                //let e = that.edges[i].end\r\n                //let flag = false;\r\n                //if(s == nodeindex || e == nodeindex){\r\n                //    flag = true\r\n                //}\r\n//\r\n                //for(let st in updateidx){\r\n                //    for(let en in updateidx[st]){\r\n                //        if(s == st && e == en){\r\n                //            flag = true\r\n                //            break\r\n                //        }\r\n                //    }\r\n                //}\r\n//\r\n                //if(flag){\r\n                //    let tmpe = clone(that.edges[i])\r\n                //    tmpe.id = i\r\n                //    tmpe.flag = true\r\n                //    editEdges.push(tmpe)\r\n                //}\r\n\r\n\r\n            }\r\n\r\n             */\r\n\r\n            editEdges = []\r\n            curEdgeDict = {}\r\n\r\n            // Add New Edges\r\n            for(let i = 0; i < that.edges.length; i ++){\r\n                let st = that.edges[i].start\r\n                let en = that.edges[i].end\r\n                if(!curEdgeDict.hasOwnProperty(st)){\r\n                    curEdgeDict[st] = {}\r\n                }\r\n                curEdgeDict[st][en] = i\r\n                let vnodes1 = clone(that.edges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                // same flag\r\n                let flag = true\r\n                // exist flag\r\n                let flag1 = true\r\n                // judge st --> en\r\n                if(preEdgeDict.hasOwnProperty(st)){\r\n                    if(preEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag point?\r\n                        // startpoint\\endpoint\\control points\r\n                        let idx = preEdgeDict[st][en]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].startpoint\r\n                        let en2_p = preEdges[idx].endpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                //judge en --> st\r\n                if(preEdgeDict.hasOwnProperty(en)){\r\n                    if(preEdgeDict[en].hasOwnProperty(st)){\r\n                        // has same edge,\r\n                        // then judge has re-routing or drag poing?\r\n                        flag1 = false\r\n                        let idx = preEdgeDict[en][st]\r\n                        let st1_p = that.pointData[st]\r\n                        let en1_p = that.pointData[en]\r\n                        let st2_p = preEdges[idx].endpoint\r\n                        let en2_p = preEdges[idx].startpoint\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(preEdges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(that.edges[i])\r\n                    tmpe.id = i\r\n                    tmpe.flag = true\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n            // Delete Old Edges\r\n            for(let i = 0; i < preEdges.length; i ++){\r\n                let st = preEdges[i].start\r\n                let en = preEdges[i].end\r\n                let vnodes1 = clone(preEdges[i].virtrualNodes)\r\n                if(vnodes1.length > 0){\r\n                    vnodes1.sort(function (a,b){\r\n                        return a[0] - b[0]\r\n                    })\r\n                }\r\n                let flag = true\r\n                let flag1 = true\r\n                if(curEdgeDict.hasOwnProperty(st)){\r\n                    if(curEdgeDict[st].hasOwnProperty(en)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[st][en]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                    continue\r\n                }\r\n                if(curEdgeDict.hasOwnProperty(en)){\r\n                    if(curEdgeDict[en].hasOwnProperty(st)){\r\n                        flag1 = false\r\n                        let idx = curEdgeDict[en][st]\r\n                        let st1_p = preEdges[i].startpoint\r\n                        let en1_p = preEdges[i].endpoint\r\n                        let st2_p = that.pointData[st]\r\n                        let en2_p = that.pointData[en]\r\n                        if( (parseInt(st1_p.x)==parseInt(st2_p.x)) && (parseInt(st1_p.y)==parseInt(st2_p.y)) && (parseInt(en1_p.x)==parseInt(en2_p.x)) && (parseInt(en1_p.y)==parseInt(en2_p.y)) ){\r\n                            // then judge re-routing\r\n                            let vnodes2 = clone(that.edges[idx].virtrualNodes)\r\n                            if(vnodes1.length == vnodes2.length){\r\n                                if(vnodes2.length > 0){\r\n                                    vnodes2.sort(function (a,b){\r\n                                        return a[0] - b[0]\r\n                                    })\r\n                                }\r\n                                for(let j = 0; j < vnodes2.length; j ++){\r\n                                    if((parseInt(vnodes1[j][0])==parseInt(vnodes2[j][0])) && (parseInt(vnodes1[j][1])==parseInt(vnodes2[j][1]))){\r\n                                        continue;\r\n                                    }\r\n                                    else{\r\n                                        flag = false\r\n                                        break\r\n                                    }\r\n                                }\r\n                            }\r\n                            else{\r\n                                flag = false\r\n                            }\r\n                        }\r\n                        else{\r\n                            flag = false\r\n                        }\r\n                    }\r\n                }\r\n                if(!flag || flag1){\r\n                    let tmpe = clone(preEdges[i])\r\n                    tmpe.flag = false\r\n                    editEdges.push(tmpe)\r\n                }\r\n            }\r\n\r\n\r\n            that.setState({\r\n                pointData: that.pointData\r\n            })\r\n\r\n            that.setState({\r\n                edges: that.edges\r\n            })\r\n\r\n            if(that.child.bubbleState()){\r\n                that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n            }\r\n\r\n\r\n            editPoints = []\r\n            editEdges = []\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",dragend)\r\n\r\n\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2 && !that.props.isedit){\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                    let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                    d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                        let idx =\"#\" + d3.select(this).attr(\"id\")\r\n                        d3.selectAll(idx).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n\r\n                                let tmpe = clone(that.edges[that.edges.length - 1])\r\n                                tmpe.id = that.edges.length - 1\r\n                                tmpe.flag = true\r\n                                editEdges.push(tmpe)\r\n                                that.setState({\r\n                                    pointData: that.pointData\r\n                                })\r\n\r\n                                that.setState({\r\n                                    edges: that.edges\r\n                                })\r\n\r\n                                //console.log(that.edges)\r\n\r\n                                if(that.child.bubbleState()){\r\n                                    that.child.editReDraw(editPoints, editEdges, that.pointData, that.edges)\r\n                                }\r\n\r\n                                editPoints = []\r\n                                editEdges = []\r\n\r\n\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n                            let idx = \"#\" + that.lastClickItem.attr(\"id\")\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n\r\n\r\n                            idx = \"#\" + d3.select(this).attr(\"id\")\r\n\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n                                .attr(\"id\",d3.select(this).attr(\"id\"))\r\n\r\n\r\n                            d3.selectAll(idx)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(event.button==2 && that.props.isedit){\r\n\r\n                let idx = parseInt(d3.select(event.path[0]).attr(\"index\"))\r\n\r\n                // delete node and edges\r\n                let catarray = that.pointData[idx].catArray\r\n                for(let c = 0; c < catarray.length; c ++){\r\n                    let nowcat = catarray[c]\r\n                    for(let j = 0; j < that.catPointDict[nowcat].length; j ++){\r\n                        if(that.catPointDict[nowcat][j].id == idx){\r\n                            that.catPointDict[nowcat].splice(j, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                for(let i = that.edges.length - 1; i >= 0; i --){\r\n                    let st = that.edges[i].start\r\n                    let en = that.edges[i].end\r\n                    if(st == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                    else if(en == idx){\r\n                        that.edges.splice(i, 1)\r\n                    }\r\n                }\r\n\r\n                that.pointData.splice(idx, 1);\r\n\r\n                // modify svg index and data index\r\n                d3.selectAll(\"#edgeGroup\").remove()\r\n                d3.selectAll(\"#pointGroup\").remove()\r\n\r\n                for(let i = 0; i < that.pointData.length; i ++){\r\n                    if(that.pointData[i].id > idx){\r\n                        that.pointData[i].id -= 1\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < that.edges.length; i ++){\r\n                    if(that.edges[i].start > idx){\r\n                        that.edges[i].start -= 1\r\n                    }\r\n                    if(that.edges[i].end > idx){\r\n                        that.edges[i].end -= 1\r\n                    }\r\n                }\r\n\r\n                that.drawPointData()\r\n                that.drawEdges()\r\n\r\n                that.setState({\r\n                    pointData: that.pointData\r\n                })\r\n\r\n                that.setState({\r\n                    edges: that.edges\r\n                })\r\n\r\n            }\r\n        }\r\n\r\n        let items=[]\r\n        d3.select(svgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        d3.select(opsvgid)\r\n            .append(\"g\")\r\n            .attr(\"id\",\"pointGroup\")\r\n        // this.itemShape=\"circle\"\r\n        if(this.itemShape==\"circle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"cx\",this.pointData[i].x)\r\n                    .attr(\"cy\",this.pointData[i].y)\r\n                    .attr(\"r\",this.pointData[i].radius)\r\n                    .attr(\"fill\",function(d,i){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n        else if(this.itemShape==\"rectangle\"){\r\n            for (let i=0;i<this.pointData.length;i++){\r\n                let index=i\r\n                d3.select(svgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n\r\n                d3.select(opsvgid)\r\n                    .select(\"#pointGroup\")\r\n                    .append(\"rect\")\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr(\"id\",\"point\"+index)\r\n                    .attr(\"x\",this.pointData[i].x-this.pointData[i].width/2)\r\n                    .attr(\"y\",this.pointData[i].y-this.pointData[i].height/2)\r\n                    .attr(\"width\",this.pointData[i].width)\r\n                    .attr(\"height\",this.pointData[i].height)\r\n                    .attr(\"fill\",function(){\r\n                        return colors[that.pointData[index].catArray[that.pointData[index].catArray.length-1]]\r\n                    })\r\n                    .attr(\"category\",this.pointData[i].cat)\r\n                    .attr(\"index\",index)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                    // .on(\"click\",that.clickItem.bind(that))\r\n                    // .on(\"drag\",function(){\r\n                    //     console.log(\"drag!\")\r\n                    // })\r\n                    .call(drag)\r\n            }\r\n            items=document.getElementsByClassName(\"dataPoint\")\r\n            // console.log(items)\r\n            for (let i=0;i<items.length;i++){\r\n                this.itemBBox.push({\r\n                    id:items[i].getAttribute(\"index\"),\r\n                    bbox:items[i].getBBox()\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    countEdgeCrossingWithRouting(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let lines1=[]\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            if(this.edges[i].virtrual){\r\n                let vnodes=this.edges[i].virtrualNodes\r\n                lines1.push([start1.x,start1.y])\r\n                for (let p=0;p<vnodes.length;p++){\r\n                    lines1.push(vnodes[p])\r\n                }\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            else{\r\n                lines1.push([start1.x,start1.y])\r\n                lines1.push([end1.x,end1.y])\r\n            }\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let lines2=[]\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat==start2.cat){\r\n                    continue\r\n                }\r\n                if(this.edges[j].virtrual){\r\n                    let vnodes=this.edges[j].virtrualNodes\r\n                    lines2.push([start2.x,start2.y])\r\n                    for (let p=0;p<vnodes.length;p++){\r\n                        lines2.push(vnodes[p])\r\n                    }\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                else{\r\n                    lines2.push([start2.x,start2.y])\r\n                    lines2.push([end2.x,end2.y])\r\n                }\r\n                for (let l1=0;l1<lines1.length-1;l1++){\r\n                    let p1={x:lines1[l1][0],y:lines1[l1][1]}\r\n                    let p2={x:lines1[l1+1][0],y:lines1[l1+1][1]}\r\n                    for (let l2=0;l2<lines2.length-1;l2++){\r\n                        let p3={x:lines2[l2][0],y:lines2[l2][1]}\r\n                        let p4={x:lines2[l2+1][0],y:lines2[l2+1][1]}\r\n                        if(this.checkEdgeCrossing(p1,p2,p3,p4)){\r\n                            count+=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    countEdgeCrossing(){\r\n        let count=0\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let start1=this.pointData[this.edges[i].start]\r\n            let end1=this.pointData[this.edges[i].end]\r\n            for (let j=i+1;j<this.edges.length;j++){\r\n                let start2=this.pointData[this.edges[j].start]\r\n                let end2=this.pointData[this.edges[j].end]\r\n                if(start1.cat!=start2.cat){\r\n                    if(this.checkEdgeCrossing(start1,end1,start2,end2)){\r\n                        count+=1\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    createLocalTree(points){\r\n\r\n        //1. find center point\r\n        //2. generate tree\r\n        let midx=0\r\n        let midy=0\r\n        for (let i=0;i<points.length;i++){\r\n            midx+=points[i].x\r\n            midy+=points[i].y\r\n        }\r\n        midx=midx/points.length\r\n        midy=midy/points.length\r\n        let midnode={\r\n            x:midx,\r\n            y:midy\r\n        }\r\n        let minDis=Number.MAX_VALUE\r\n        let minindex=-1\r\n        for (let i=0;i<points.length;i++){\r\n            let dis=this.calDistance(midnode,points[i])\r\n            if(dis<minDis){\r\n                minDis=dis\r\n                minindex=i\r\n            }\r\n        }\r\n\r\n\r\n\r\n        for (let i=0;i<points.length;i++){\r\n            if(i!=minindex){\r\n                this.edges.push({\r\n                    start:points[minindex].id,\r\n                    end:points[i].id,\r\n                    virtrual:false,\r\n                    virtrualNodes:[],\r\n                    cat:points[i].cat,\r\n                    isLocalTree:true\r\n                })\r\n                this.graph.addEdge(points[minindex].id,points[i].id)\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // console.log(this.edges)\r\n        /*        var g = new jsgraphs.Graph(this.pointData.length);\r\n                for (let i=0;i<g.V;i++){\r\n                    g.node(i).label=this.pointData[i].cat\r\n                }*/\r\n\r\n    }\r\n\r\n    initWithNoCluster(){\r\n        for(var k in this.catPointDict){\r\n            this.clusterDict[k]=[]\r\n            for (let i=0;i<this.catPointDict[k].length;i++){\r\n                this.clusterDict[k].push([this.catPointDict[k][i]])\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    generateTreeWithHierarchical(){\r\n        // this.findCluster()\r\n        this.initWithNoCluster()\r\n        //merging clusters according to this.edges\r\n\r\n        let preAddedClusters=[]\r\n        for (let i=0;i<this.edges.length;i++){\r\n            let start=this.pointData[this.edges[i].start]\r\n            let end=this.pointData[this.edges[i].end]\r\n            let cat=start.cat\r\n            let catclusters=this.clusterDict[cat]\r\n            let startclusterid=-1\r\n            let endclusterid=-1\r\n            for(let c=0;c<catclusters.length;c++){\r\n                for (let p=0;p<catclusters[c].length;p++){\r\n                    if(catclusters[c][p].id==start.id){\r\n                        startclusterid=c\r\n                    }\r\n                    if(catclusters[c][p].id==end.id){\r\n                        endclusterid=c\r\n                    }\r\n                    if(startclusterid!=-1&&endclusterid!=-1){\r\n                        break\r\n                    }\r\n                }\r\n                if(startclusterid!=-1&&endclusterid!=-1){\r\n                    break\r\n                }\r\n\r\n            }\r\n            if(startclusterid!=-1&&endclusterid!=-1&&startclusterid!=endclusterid){\r\n                // console.log(this.clusterDict[cat].length)\r\n\r\n                //merge two cluster\r\n                let merged=catclusters[startclusterid]\r\n                for(let p=0;p<catclusters[endclusterid].length;p++){\r\n                    merged.push(catclusters[endclusterid][p])\r\n                }\r\n                let newclusterdict=[]\r\n                for (let c=0;c<catclusters.length;c++){\r\n                    if(c!=startclusterid&&c!=endclusterid){\r\n                        newclusterdict.push(catclusters[c])\r\n                    }\r\n                }\r\n                newclusterdict.push(merged)\r\n                this.clusterDict[cat]=newclusterdict\r\n                preAddedClusters.push([cat,newclusterdict.length-1])\r\n            }\r\n\r\n        }\r\n\r\n        this.createGraphWithCluster()\r\n\r\n        for (var k in this.clusterDict){\r\n            this.clustergraphInfo[k] = {edgesnum:0,nodesnum:this.clusterDict[k].length};\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let iscontinue=false\r\n                for (let c=0;c<preAddedClusters.length;c++){\r\n                    let cat=preAddedClusters[c][0]\r\n                    let id=preAddedClusters[c][1]\r\n                    if(k==cat&&id==i){\r\n                        iscontinue=true\r\n                    }\r\n                }\r\n                if(iscontinue){\r\n                    continue\r\n                }\r\n                else{\r\n                    this.createLocalTree(this.clusterDict[k][i])\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.clusterDict)\r\n        // console.log(this.edges.length)\r\n\r\n        this.drawEdges()\r\n        this.hierarchicalMergeV2()\r\n        // console.log(this.edges.length)\r\n    }\r\n\r\n    findCluster(){\r\n\r\n        for (var k in this.catPointDict){\r\n            // console.log(k)\r\n\r\n            var dbscan = new clustering.DBSCAN();\r\n            let dataset=[]\r\n            let pointDataSet=[]\r\n// parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster\r\n\r\n            for(let i=0;i<this.catPointDict[k].length;i++){\r\n                // if(this.pointData[this.catPointDict[k][i].id].multicat){\r\n                //     let catarr=this.pointData[this.catPointDict[k][i].id].catArray\r\n                //     catarr=catarr.map((val)=> parseInt(val) )\r\n                //     let minCatIndex=Math.min.apply(null,catarr)\r\n                //     if(parseInt(k)==minCatIndex){\r\n                //         dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                //         pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                //     }\r\n                // }\r\n                // else{\r\n                dataset.push([this.catPointDict[k][i].x,this.catPointDict[k][i].y])\r\n                pointDataSet.push(this.pointData[this.catPointDict[k][i].id])\r\n                // }\r\n\r\n            }\r\n            // console.log(dataset)\r\n            // console.log(pointDataSet)\r\n\r\n            if(dataset.length>0){\r\n                this.clusterDict[k]=[]\r\n                this.noiseDict[k]=[]\r\n                var clusters = dbscan.run(dataset, DBSCAN_EPS, 2);\r\n                // console.log(clusters, dbscan.noise);\r\n                let point\r\n                for(let i=0;i<clusters.length;i++){\r\n                    let clusterPoints=[]\r\n                    for (let j=0;j<clusters[i].length;j++){\r\n                        clusterPoints.push(pointDataSet[clusters[i][j]])\r\n                        // console.log(point)\r\n                        /*                    let point=dataset[clusters[i][j]]\r\n                                            d3.select(svgid)\r\n                                                .append(\"circle\")\r\n                                                .attr(\"cx\",point[0])\r\n                                                .attr(\"cy\",point[1])\r\n                                                .attr(\"r\",10)\r\n                                                .attr(\"fill\",\"none\")\r\n                                                .attr(\"stroke\",\"red\")\r\n                                                .attr(\"stroke-width\",2)*/\r\n                    }\r\n                    // this.createLocalTree(clusterPoints)\r\n                    this.clusterDict[k].push(clusterPoints)\r\n                }\r\n                for (let i=0;i<dbscan.noise.length;i++){\r\n                    this.clusterDict[k].push([pointDataSet[dbscan.noise[i]]])\r\n                }\r\n            }\r\n\r\n        }\r\n        //console.log(this.clusterDict)\r\n        // console.log(this.noiseDict)\r\n    }\r\n\r\n    createGraph(){\r\n\r\n    }\r\n\r\n    createGraphWithCluster(){\r\n        let clusterArr=[]\r\n        let idnum=0\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                clusterArr.push({\r\n                    points:this.clusterDict[k][i],\r\n                    cat:k,\r\n                    id:idnum\r\n                })\r\n                this.clusterDict[k][i].id=idnum\r\n                idnum+=1\r\n\r\n\r\n            }\r\n\r\n        }\r\n        this.clusterArr=clusterArr\r\n        //console.log(this.clusterDict)\r\n        var g = new jsgraphs.Graph(this.clusterArr.length);\r\n        for (let i=0;i<g.V;i++){\r\n            g.node(i).label=this.clusterArr[i].cat\r\n        }\r\n        // console.log(g.V,this.clusterArr.length)\r\n\r\n        this.clustergraph=g\r\n\r\n        var g2 = new jsgraphs.Graph(this.pointData.length);\r\n        for (let i=0;i<g2.V;i++){\r\n            g2.node(i).label=this.pointData[i].cat\r\n        }\r\n        this.graph=g2\r\n        //console.log(g,g2)\r\n        for (let i=0;i<this.edges.length;i++){\r\n            this.graph.addEdge(this.edges[i].start,this.edges[i].end)\r\n        }\r\n\r\n    }\r\n\r\n    calClusterDistance(cluster1,cluster2){\r\n        let dissum=0\r\n        let num=0\r\n        let mindis=Number.MAX_VALUE\r\n        for(let i=0;i<cluster1.length;i++){\r\n            for (let j=0;j<cluster2.length;j++){\r\n                // dissum+=this.calDistance(cluster1[i],cluster2[j])\r\n                // num+=1\r\n                let dis=this.calDistance(cluster1[i],cluster2[j])\r\n                if(dis<mindis){\r\n                    mindis=dis\r\n                }\r\n            }\r\n        }\r\n        return mindis\r\n    }\r\n\r\n    sortEdgesGlobalWithCluster(){\r\n        function sortEdgesfunc(a,b){\r\n            return a[2]-b[2]\r\n        }\r\n\r\n        let edges=[]\r\n        let disArray=[]\r\n        let messArray=[]\r\n        let tempedges=[]\r\n        let maxDis=Number.MIN_VALUE\r\n        for (let k in this.clusterDict){\r\n            for(let i=0;i<this.clusterDict[k].length;i++){\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let dis=this.calClusterDistance(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    // let mess=this.calEdgeMess(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                    disArray.push(dis)\r\n                    // messArray.push(mess)\r\n                    if(dis>maxDis){\r\n                        maxDis=dis\r\n                    }\r\n                    // tempedges.push([this.catPointDict[k][i].id,this.catPointDict[k][j].id,dis,mess])\r\n                    tempedges.push([this.clusterDict[k][i].id,this.clusterDict[k][j].id,dis])\r\n                }\r\n            }\r\n        }\r\n        this.maxDistance=maxDis\r\n        for (let i=0;i<tempedges.length;i++){\r\n            let start=tempedges[i][0]\r\n            let end=tempedges[i][1]\r\n            let dis=tempedges[i][2]/maxDis\r\n            // let mess=tempedges[i][3]\r\n            // let weight=dis*(mess+1)\r\n            let weight=dis\r\n            // edges.push([start,end,weight,dis,mess])\r\n            edges.push([start,end,weight,dis])\r\n        }\r\n\r\n        edges.sort(sortEdgesfunc)\r\n        return edges\r\n    }\r\n\r\n    findLinkBetweenCluster(cluster1,cluster2){\r\n        let mindis=Number.MAX_VALUE\r\n        let minstart=null\r\n        let minend=null\r\n        let flag=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                if(!this.checkNewEdge(start,end)){\r\n                    flag=true\r\n                    let dis=this.calDistance(start,end)\r\n                    if(dis<mindis){\r\n                        mindis=dis\r\n                        minstart=start\r\n                        minend=end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return [flag,minstart,minend,mindis]\r\n    }\r\n\r\n    /*    findOptimalLink(cluster1,cluster2){\r\n            //let crossedge = []\r\n            let minScore=Number.MAX_VALUE\r\n            let bestStart=null\r\n            let bestEnd=null\r\n\r\n            let minScoreWithDis=Number.MAX_VALUE\r\n            let bestStartWithDis=null\r\n            let bestEndWithDis=null\r\n\r\n            let hasBest=false\r\n            for (let i=0;i<cluster1.length;i++){\r\n                let start=cluster1[i]\r\n                for(let j=0;j<cluster2.length;j++){\r\n                    let end=cluster2[j]\r\n                    //cal cross num\r\n                    let crossnum=0\r\n                    for (let e=0;e<this.edges.length;e++){\r\n                        let e1=this.pointData[this.edges[e].start]\r\n                        let e2=this.pointData[this.edges[e].end]\r\n                        if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                            crossnum+=1\r\n                        }\r\n                    }\r\n                    //let tmpcross = [];\r\n\r\n                    //let elements = this.QTree.retrieve({\r\n                    //    x: Math.min(start.x,end.x),\r\n                    //    y: Math.min(start.y,end.y),\r\n                    //    width: Math.abs(start.x-end.x),\r\n                    //    height: Math.abs(start.y-end.y)\r\n                    //});\r\n\r\n                    //for (let e = 0;e < elements.length;e ++){\r\n                    //    let e1 = this.pointData[elements[e].start];\r\n                    //    let e2 = this.pointData[elements[e].end];\r\n                    //    if(e1.cat != start.cat && e1.cat != end.cat && this.checkEdgeCrossing(start,end,e1,e2)){\r\n                    //        crossnum += 1\r\n                    //        //tmpcross.push({start:this.edges[e].start,end:this.edges[e].end})\r\n                    //        //tmpcross.push({start:this.edges[e].end,end:this.edges[e].start})\r\n                    //    }\r\n                    //}\r\n                    //crossnum = 5;\r\n\r\n                    //cal distance\r\n                    let distance=this.calDistance(start,end)\r\n\r\n\r\n                    //cal num of other points\r\n                    let mess=this.calEdgeMess(start,end)\r\n\r\n                    if(crossnum>maxCross){\r\n                        maxCross=crossnum\r\n                    }\r\n\r\n                    let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                    if(score<minScore){\r\n                        bestStart=start\r\n                        bestEnd=end\r\n                        minScore=score\r\n                        //crossedge = tmpcross\r\n                    }\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        if(score<minScoreWithDis){\r\n                            bestStartWithDis=start\r\n                            bestEndWithDis=end\r\n                            minScoreWithDis=score\r\n                            hasBest=true\r\n                            //crossedge = tmpcross\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            /!*      if(hasBest){\r\n                        // console.log(\"edge under threshhold\")\r\n                        return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                    }\r\n                    else{\r\n                        // console.log(\"no edge under threshhold\")\r\n                        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                    }*!/\r\n            return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n        }*/\r\n\r\n    findOptimalLink(cluster1,cluster2){\r\n        let minScore=Number.MAX_VALUE\r\n        let bestStart=null\r\n        let bestEnd=null\r\n\r\n        let minScoreWithDis=Number.MAX_VALUE\r\n        let bestStartWithDis=null\r\n        let bestEndWithDis=null\r\n\r\n        let hasBest=false\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n\r\n\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n\r\n                if(crossnum>maxCross){\r\n                    maxCross=crossnum\r\n                }\r\n\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                if(score<minScore){\r\n                    bestStart=start\r\n                    bestEnd=end\r\n                    minScore=score\r\n                }\r\n                if(distance<DISTANCE_THRESHHOLD){\r\n                    if(score<minScoreWithDis){\r\n                        bestStartWithDis=start\r\n                        bestEndWithDis=end\r\n                        minScoreWithDis=score\r\n                        hasBest=true\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        /*        if(hasBest){\r\n                    // console.log(\"edge under threshhold\")\r\n                    return [bestStartWithDis,bestEndWithDis,minScoreWithDis,this.calDistance(bestStartWithDis,bestEndWithDis)]\r\n                }\r\n                else{\r\n                    // console.log(\"no edge under threshhold\")\r\n                    return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n                }*/\r\n        return [bestStart,bestEnd,minScore,this.calDistance(bestStart,bestEnd)]\r\n    }\r\n\r\n    /*    findMinScore(links){\r\n            let minScore=Number.MAX_VALUE\r\n            let minIndex=-1\r\n\r\n            let minScoreWithDistance=Number.MAX_VALUE\r\n            let minIndexWithDistance=-1\r\n            let hasBest=false\r\n            for(let i=0;i<links.length;i++){\r\n                if(links[i].score<minScore){\r\n                    minScore=links[i].score\r\n                    minIndex=i\r\n                }\r\n                if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                    minScoreWithDistance=links[i].score\r\n                    minIndexWithDistance=i\r\n                    hasBest=true\r\n                }\r\n            }\r\n            if(hasBest){\r\n                // console.log(\"yes\")\r\n                return links[minIndexWithDistance]\r\n            }\r\n            else{\r\n                // console.log(\"no\")\r\n                return links[minIndex]\r\n\r\n            }\r\n\r\n            // return links[minIndex]\r\n\r\n        }*/\r\n\r\n    findMinScoreTest(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=links.length-1;i>=0;i--) {\r\n            let id1 = links[i].clusterid1\r\n            let id2 = links[i].clusterid2\r\n            if(this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                continue;\r\n            }\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findMinScore(links){\r\n        let minScore=Number.MAX_VALUE\r\n        let minIndex=-1\r\n\r\n        let minScoreWithDistance=Number.MAX_VALUE\r\n        let minIndexWithDistance=-1\r\n        let hasBest=false\r\n        for(let i=0;i<links.length;i++){\r\n            if(links[i].score<minScore){\r\n                minScore=links[i].score\r\n                minIndex=i\r\n            }\r\n            if(links[i].distance<DISTANCE_THRESHHOLD&&links[i].score<minScoreWithDistance){\r\n                minScoreWithDistance=links[i].score\r\n                minIndexWithDistance=i\r\n                hasBest=true\r\n            }\r\n        }\r\n        if(hasBest){\r\n            // console.log(\"yes\")\r\n            return links[minIndexWithDistance]\r\n        }\r\n        else{\r\n            // console.log(\"no\")\r\n            return links[minIndex]\r\n\r\n        }\r\n\r\n        // return links[minIndex]\r\n\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isAdded(start,end){\r\n        for (let i=0;i<this.addedEdge.length;i++){\r\n            if(this.addedEdge[i][0]==start&&this.addedEdge[i][1]==end||this.addedEdge[i][0]==end&&this.addedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    isDeleted(start,end){\r\n        for (let i=0;i<this.deletedEdge.length;i++){\r\n            if(this.deletedEdge[i][0]==start&&this.deletedEdge[i][1]==end||this.deletedEdge[i][0]==end&&this.deletedEdge[i][1]==start){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    addLinksTest(id1,id2,k,cluster1,cluster2,e){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                let crossnum=0\r\n                let distance=this.calDistance(start,end)\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n                e.push(tmp)\r\n                this.idx++;\r\n            }\r\n        }\r\n    }\r\n\r\n    addLinks(id1,id2,k,cluster1,cluster2,e1,e2){\r\n        for (let i=0;i<cluster1.length;i++){\r\n            let start=cluster1[i]\r\n            for(let j=0;j<cluster2.length;j++){\r\n                let end=cluster2[j]\r\n                //cal cross num\r\n                let crossnum=0\r\n                for (let e=0;e<this.edges.length;e++){\r\n                    let e1=this.pointData[this.edges[e].start]\r\n                    let e2=this.pointData[this.edges[e].end]\r\n                    if(e1.cat!=start.cat&&e1.cat!=end.cat&&this.checkEdgeCrossing(start,end,e1,e2)){\r\n                        crossnum+=1\r\n                    }\r\n                }\r\n                //cal distance\r\n                let distance=this.calDistance(start,end)\r\n                //cal num of other points\r\n                let mess=this.calEdgeMess(start,end)\r\n                let score=weightCross*crossnum+weightDistance*distance/this.maxDis+weightMess*mess\r\n                let tmp = {\r\n                    clusterid1:id1,\r\n                    clusterid2:id2,\r\n                    start:start,\r\n                    end:end,\r\n                    score:score,\r\n                    distance:distance,\r\n                    cat:k,\r\n                    idx:this.idx,\r\n                    pid:-1\r\n                }\r\n\r\n                if(this.isDeleted(start.id,end.id)){\r\n                    tmp.score=Number.MAX_VALUE\r\n                    e2._d[this.idx] = tmp;\r\n                    e2.enq(this.idx);\r\n                    this.idx++;\r\n\r\n                }\r\n                else if(this.isAdded(start.id,end.id)){\r\n                    tmp.score=-1\r\n                    e1._d[this.idx] = tmp;\r\n                    e1.enq(this.idx);\r\n                    this.idx++;\r\n                }\r\n                else{\r\n                    if(distance<DISTANCE_THRESHHOLD){\r\n                        //V1\r\n                        //tmp.pid = e1._elements.length;\r\n\r\n                        e1._d[this.idx] = tmp;\r\n                        e1.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                    else{\r\n                        //V1\r\n                        //tmp.pid = e2._elements.length;\r\n\r\n                        e2._d[this.idx] = tmp;\r\n                        e2.enq(this.idx);\r\n                        this.idx++;\r\n                    }\r\n                }\r\n                //let nodetmp = {\r\n                //    x:Math.min(start.x,end.x),\r\n                //    y:Math.min(start.y,end.y),\r\n                //    width:Math.abs(start.x - end.x),\r\n                //    height:Math.abs(start.y - end.y),\r\n                //    idx:this.idx\r\n                //}\r\n                //this.edgesdict.push(nodetmp);\r\n                //this.QTree.insert(this.edgesdict[this.idx]);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    findBestLink(e){\r\n        let minScore = Number.MAX_VALUE;\r\n        let tmp;\r\n        for(let i = e.length - 1;i >= 0;i --){\r\n            let id1 = e[i].clusterid1;\r\n            let id2 = e[i].clusterid2;\r\n            if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                if(minScore > e[i].score){\r\n                    tmp = e[i];\r\n                    minScore = e[i].score;\r\n                }\r\n            }\r\n            else{\r\n                e.splice(i, 1);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    recalculateSpanningTreeAfterEdit(edges){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                edges[edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        edges[edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<edges.length;i++){\r\n                                let start1=this.pointData[edges[i].start]\r\n                                let end1=this.pointData[edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            edges[edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    recalculateSpanningTree(){\r\n        let newEdges=[]\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            // this.drawEdges()\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        // // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n            newEdges.push(this.edges.length-1)\r\n        }\r\n        //console.log(maxCross)\r\n        return newEdges\r\n    }\r\n\r\n    hierarchicalMergeV2(){\r\n\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        //start kruskal test\r\n        //init\r\n        this.f=[]\r\n\r\n        let totcluster = 0\r\n        for(let k in this.clusterDict){\r\n            totcluster += this.clusterDict[k].length;\r\n        }\r\n        for(let i = 0;i <= totcluster;i ++){\r\n            this.f.push(i);\r\n        }\r\n\r\n        //add edge set\r\n        let optimalLinks1=new priority_queue({});\r\n        let optimalLinks2=new priority_queue({});\r\n\r\n        //let optimalLinks = [];\r\n\r\n        for (var k in this.clusterDict){\r\n            for (let i=0;i<this.clusterDict[k].length;i++){\r\n                let id1=this.clusterDict[k][i].id\r\n                for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                    let id2=this.clusterDict[k][j].id\r\n                    //this.addLinksTest(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks)\r\n                    //if(!this.checkConnectBetweenTwoClusterV2(id1,id2)){\r\n                    this.addLinks(id1,id2,k,this.clusterDict[k][i],this.clusterDict[k][j],optimalLinks1,optimalLinks2)\r\n                    //}\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllClusterV2()){\r\n            //let bestLink = this.findMinScoreTest(optimalLinks);\r\n            //for(let i = 0;i < optimalLinks.length; i ++){\r\n            //    let s = optimalLinks[i].start\r\n            //    let e = optimalLinks[i].end\r\n            //    if(this.checkEdgeCrossing(s,e,bestLink.start,bestLink.end) && s.cat != bestLink.start.cat && e.cat != bestLink.end.cat){\r\n            //        optimalLinks[i].score += weightCross\r\n            //    }\r\n            //}\r\n\r\n            let bestLink;\r\n            if(!optimalLinks1.isEmpty()){\r\n                bestLink = optimalLinks1._d[optimalLinks1.deq()];\r\n            }\r\n            else if(!optimalLinks2.isEmpty()){\r\n                bestLink = optimalLinks2._d[optimalLinks2.deq()];\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n\r\n            this.unionFather(bestLink.clusterid1,bestLink.clusterid2);\r\n            optimalLinks1.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n            optimalLinks2.modify_Kruskal_V2(bestLink.start,bestLink.end,this.f,weightCross)\r\n\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2);\r\n            this.clustergraphInfo[bestLink.cat].edgesnum += 1;\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n            this.drawEdges()\r\n            console.log()\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",endp[0])\r\n                    .attr(\"y2\",endp[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n/*                        d3.selectAll(\"line\")\r\n                            .remove()\r\n                        // .attr(\"stroke\",\"black\")\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",startp[0])\r\n                            .attr(\"y1\",startp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        d3.select(svgid).append(\"line\")\r\n                            .attr(\"x1\",endp[0])\r\n                            .attr(\"y1\",endp[1])\r\n                            .attr(\"x2\",vnode[0])\r\n                            .attr(\"y2\",vnode[1])\r\n                            .attr(\"stroke-width\",2)\r\n                            .attr(\"stroke\",\"red\")*/\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n/*                d3.selectAll(\"line\")\r\n                    .remove()\r\n                // .attr(\"stroke\",\"black\")\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",startp[0])\r\n                    .attr(\"y1\",startp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")\r\n\r\n                d3.select(svgid).append(\"line\")\r\n                    .attr(\"x1\",endp[0])\r\n                    .attr(\"y1\",endp[1])\r\n                    .attr(\"x2\",vnode[0])\r\n                    .attr(\"y2\",vnode[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"red\")*/\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n            this.drawOneEdge(this.edges.length-1)\r\n            console.log()\r\n        }\r\n        //console.log(maxCross)\r\n    }\r\n\r\n    hierarchicalMerge(){\r\n        // console.log(this.calDistance(this.pointData[120],this.pointData[171]))\r\n        // console.log(this.calDistance(this.pointData[47],this.pointData[188]))\r\n        if(this.pointData.length<150){\r\n            weightMess=0\r\n        }\r\n        else{\r\n            weightMess=1\r\n        }\r\n\r\n        while(!this.checkConnectBetweenAllCluster()){\r\n            let optimalLinks=[]\r\n            for (var k in this.clusterDict){\r\n                for (let i=0;i<this.clusterDict[k].length;i++){\r\n                    let id1=this.clusterDict[k][i].id\r\n                    for (let j=i+1;j<this.clusterDict[k].length;j++){\r\n                        let id2=this.clusterDict[k][j].id\r\n                        if(!this.checkConnectBetweenTwoCluster(id1,id2)){\r\n                            let link=this.findOptimalLink(this.clusterDict[k][i],this.clusterDict[k][j])\r\n                            optimalLinks.push({\r\n                                clusterid1:id1,\r\n                                clusterid2:id2,\r\n                                start:link[0],\r\n                                end:link[1],\r\n                                score:link[2],\r\n                                distance:link[3],\r\n                                cat:k\r\n                            })\r\n                        }\r\n                        else{\r\n                            continue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let bestLink=this.findMinScore(optimalLinks)\r\n            this.clustergraph.addEdge(bestLink.clusterid1,bestLink.clusterid2)\r\n            this.edges.push({\r\n                start:bestLink.start.id,\r\n                end:bestLink.end.id,\r\n                weight:bestLink.score,\r\n                cat:bestLink.cat,\r\n                dis:bestLink.score,\r\n                virtrual:false,\r\n                virtrualNodes:[],\r\n                isLocalTree:false\r\n            })\r\n            this.graph.addEdge(bestLink.start.id,bestLink.end.id)\r\n\r\n            // this.drawEdges()\r\n\r\n\r\n            //surface routing\r\n            let startp=this.pointData[bestLink.start.id]\r\n            let endp=this.pointData[bestLink.end.id]\r\n            let pcat=this.pointData[bestLink.start.id].cat\r\n\r\n            let virtrualNodes=[]\r\n            virtrualNodes.push([startp.x,startp.y])\r\n            virtrualNodes.push([endp.x,endp.y])\r\n            let linesToCheck=[{\r\n                start:[startp.x,startp.y],\r\n                end:[endp.x,endp.y],\r\n                ids:[0,1]\r\n            }]\r\n\r\n            while(linesToCheck.length>0){\r\n\r\n                let buffer=5\r\n                let swap=false\r\n                let checkline=linesToCheck.pop()\r\n\r\n                startp=checkline.start\r\n                endp=checkline.end\r\n                let ids=checkline.ids\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",endp[0])\r\n                //     .attr(\"y2\",endp[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n                let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n                if(intersecInfo.length==0){\r\n                    continue\r\n                }\r\n                this.edges[this.edges.length-1].virtrual=true\r\n                // handle crossing between edge and rect\r\n                let points=intersecInfo[0].points\r\n                let rec=intersecInfo[0].rect\r\n\r\n                let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n                let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n                let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n                let point1=points[0]\r\n                let point2=points[1]\r\n\r\n                let vnode\r\n\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    //parallel edges\r\n                    let cornerpointindex=-1\r\n                    if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                        let x1=point1.x-rec.x\r\n                        let y1=point2.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                        let x1=point2.x-rec.x\r\n                        let y1=point1.x-rec.x\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=2\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=4\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                        let x1=point1.y-rec.y\r\n                        let y1=point2.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n                    else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                        let x1=point2.y-rec.y\r\n                        let y1=point1.y-rec.y\r\n                        if(x1+y1<rec.width){\r\n                            if(x1>y1){\r\n                                cornerpointindex=3\r\n                            }\r\n                            else{\r\n                                cornerpointindex=4\r\n                            }\r\n                        }\r\n                        else{\r\n                            if(x1<y1){\r\n                                cornerpointindex=2\r\n                            }\r\n                            else{\r\n                                cornerpointindex=1\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let cornerpoint=[]\r\n\r\n\r\n                    let iternum=0\r\n                    let vnode1=-1\r\n                    let vnode2=-1\r\n                    while(true) {\r\n                        if (cornerpointindex == 1) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 2) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            }\r\n                        } else if (cornerpointindex == 3) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x, rec.y]\r\n                            }\r\n                        } else if (cornerpointindex == 4) {\r\n                            if (!swap) {\r\n                                cornerpoint = [rec.x, rec.y + rec.height]\r\n                            } else {\r\n                                cornerpoint = [rec.x + rec.width, rec.y]\r\n                            }\r\n                        }\r\n\r\n                        let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                        let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                        let movenorm = this.getVecNorm(movevec)\r\n                        movevec[0] = movevec[0] / movenorm\r\n                        movevec[1] = movevec[1] / movenorm\r\n\r\n                        vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                        // d3.selectAll(\"line\")\r\n                        //     .remove()\r\n                        //     // .attr(\"stroke\",\"black\")\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",startp[0])\r\n                        //     .attr(\"y1\",startp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n                        //\r\n                        // d3.select(svgid).append(\"line\")\r\n                        //     .attr(\"x1\",endp[0])\r\n                        //     .attr(\"y1\",endp[1])\r\n                        //     .attr(\"x2\",vnode[0])\r\n                        //     .attr(\"y2\",vnode[1])\r\n                        //     .attr(\"stroke-width\",2)\r\n                        //     .attr(\"stroke\",\"red\")\r\n\r\n                        if(this.checkVNodeInBound(vnode,pcat)){\r\n                            if(!swap){\r\n                                buffer=buffer/1.5\r\n                            }\r\n                            swap=!swap\r\n                            iternum+=1\r\n                            if(iternum>10){\r\n                                break\r\n                            }\r\n                        }\r\n                        else{\r\n                            //not in obstacle, check if this virtrual edge corssing with other edges\r\n                            if(swap){\r\n                                vnode1=vnode\r\n                            }\r\n                            else{\r\n                                vnode2=vnode\r\n                            }\r\n                            swap=!swap\r\n                            if(vnode1!=-1&&vnode2!=-1){\r\n                                break\r\n                            }\r\n                            // iternum+=1\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(vnode1==-1&&vnode2==-1){\r\n                        //fail to route the edge\r\n                        this.edges[this.edges.length-1].virtrual=false\r\n                        continue\r\n                    }\r\n                    else if(vnode1!=-1&&vnode2!=-1){\r\n                        //use the one with least crossing\r\n                        let minCross=Number.MAX_VALUE\r\n                        let bestVnode=null\r\n                        let potentialNode=[vnode1,vnode2]\r\n                        for (let n=0;n<potentialNode.length;n++){\r\n                            let pnode=potentialNode[n]\r\n                            let count=0\r\n                            for(let i=0;i<this.edges.length;i++){\r\n                                let start1=this.pointData[this.edges[i].start]\r\n                                let end1=this.pointData[this.edges[i].end]\r\n                                if(start1.cat!=pcat){\r\n                                    let node1={\r\n                                        x:startp[0],\r\n                                        y:startp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node2={\r\n                                        x:pnode[0],\r\n                                        y:pnode[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    let node3={\r\n                                        x:endp[0],\r\n                                        y:endp[1],\r\n                                        cat:pcat\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                        count+=1\r\n                                    }\r\n                                    if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                        count+=1\r\n                                    }\r\n                                }\r\n                            }\r\n                            if(count<minCross){\r\n                                minCross=count\r\n                                bestVnode=potentialNode[n]\r\n                            }\r\n\r\n                        }\r\n                        vnode=bestVnode\r\n\r\n                    }\r\n                    else{\r\n                        if(vnode1!=-1){\r\n                            vnode=vnode1\r\n                        }\r\n                        else{\r\n                            vnode=vnode2\r\n                        }\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    //neighbouring edges\r\n                    //find the corner point on the rectangle\r\n                    let temppoint=[point1.x,point2.y]\r\n                    let cornerpoint=[]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                    else{\r\n                        temppoint=[point2.x,point1.y]\r\n                        if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                            cornerpoint=[rec.x+rec.width,rec.y]\r\n                        }\r\n                        else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                        }\r\n                        else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                            cornerpoint=[rec.x,rec.y+rec.height]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                    let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                    let movenorm=this.getVecNorm(movevec)\r\n                    movevec[0]=movevec[0]/movenorm\r\n                    movevec[1]=movevec[1]/movenorm\r\n\r\n                    vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n                }\r\n\r\n\r\n                // d3.selectAll(\"line\")\r\n                //     .remove()\r\n                // // .attr(\"stroke\",\"black\")\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",startp[0])\r\n                //     .attr(\"y1\",startp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n                //\r\n                // d3.select(svgid).append(\"line\")\r\n                //     .attr(\"x1\",endp[0])\r\n                //     .attr(\"y1\",endp[1])\r\n                //     .attr(\"x2\",vnode[0])\r\n                //     .attr(\"y2\",vnode[1])\r\n                //     .attr(\"stroke-width\",2)\r\n                //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n                let samepoiint=false\r\n                for (let m=0;m<virtrualNodes.length;m++){\r\n                    if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                        samepoiint=true\r\n                        break\r\n                    }\r\n                }\r\n                if(samepoiint){\r\n                    continue\r\n                }\r\n\r\n                let newid\r\n\r\n\r\n                newid=ids[0]+1\r\n\r\n\r\n                virtrualNodes.splice(newid,0,vnode)\r\n\r\n                for (let n=0;n<linesToCheck.length;n++){\r\n                    if(linesToCheck[n].ids[0]>=newid){\r\n                        linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                    }\r\n                    if(linesToCheck[n].ids[1]>=newid){\r\n                        linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                    }\r\n                }\r\n                // virtrualNodes.push(vnode)\r\n                linesToCheck.push({\r\n                    start:startp,\r\n                    end:vnode,\r\n                    ids:[ids[0],newid]\r\n                })\r\n                linesToCheck.push({\r\n                    start:vnode,\r\n                    end:endp,\r\n                    ids:[newid,ids[1]+1]\r\n                })\r\n\r\n                // console.log(linesToCheck)\r\n\r\n            }\r\n\r\n            virtrualNodes.pop()\r\n            virtrualNodes.splice(0,1)\r\n            this.edges[this.edges.length-1].virtrualNodes=virtrualNodes\r\n\r\n        }\r\n    }\r\n\r\n    mergeCluster(){\r\n        //average distance as distance between clusters\r\n        //find an optimal link with least crossing\r\n\r\n        let sortEdgeDict={}\r\n        let sortedEdges=[]\r\n        let removeEdggeList=[]\r\n\r\n        sortedEdges=this.sortEdgesGlobalWithCluster()\r\n\r\n        for (let i=0;i<sortedEdges.length;i++){\r\n            let start=sortedEdges[i][0]\r\n            let end=sortedEdges[i][1]\r\n            let weight=sortedEdges[i][2]\r\n            let dis=sortedEdges[i][3]\r\n            // let mess=sortedEdges[i][4]\r\n\r\n\r\n\r\n            if(this.clusterArr[start].cat!=this.clusterArr[end].cat)\r\n                continue\r\n\r\n            var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n\r\n            if(!dfs.hasPathTo(end)){\r\n\r\n                let link=this.findLinkBetweenCluster(this.clusterArr[start].points,this.clusterArr[end].points)\r\n\r\n                if(link[0]){\r\n                    this.clustergraph.addEdge(start,end)\r\n                    this.graph.addEdge(link[1].id,link[2].id)\r\n                    // this.graph.edge(start,end).label=sortedEdges[i][2]\r\n                    this.edges.push({\r\n                        start:link[1].id,\r\n                        end:link[2].id,\r\n                        weight:link[3],\r\n                        dis:link[3],\r\n                        // mess:mess\r\n                    })\r\n                    // this.graph.node(start).label=true\r\n                    // this.graph.node(end).label=true\r\n                }\r\n                else{\r\n                    removeEdggeList.push({\r\n                        start:start,\r\n                        end:end,\r\n                        weight:weight,\r\n                        dis:dis,\r\n                        crossnum:-1,\r\n                        // mess:mess\r\n                    })\r\n                }\r\n                // this.graph.addEdge(new jsgraphs.Edge(start, end, sortedEdges[i][2]))\r\n\r\n                // console.log(this.graph.adj(start))\r\n                // this.drawLine(this.pointData)\r\n            }\r\n        }\r\n        // this.drawEdges()\r\n\r\n        while(!this.checkConnectBetweenCluster()){\r\n            let tempEdgeList=[]\r\n            for(let i=0;i<removeEdggeList.length;i++){\r\n                let start=removeEdggeList[i].start\r\n                let end=removeEdggeList[i].end\r\n\r\n\r\n                var dfs = new jsgraphs.DepthFirstSearch(this.clustergraph, start);\r\n                if(!dfs.hasPathTo(end)){\r\n                    let scores=this.findOptimalLink(this.clusterArr[start].points,this.clusterArr[end].points)\r\n                    removeEdggeList[i].weight=scores[3]\r\n                    removeEdggeList[i].crossnum=scores[3]\r\n                    tempEdgeList.push({\r\n                        clusterstart:start,\r\n                        clusterend:end,\r\n                        start:scores[0].id,\r\n                        end:scores[1].id,\r\n                        weight:scores[2],\r\n                        crossnum:scores[2]\r\n                    })\r\n                    // filteredRemoveList.push(removeEdggeList[i])\r\n                }\r\n            }\r\n            let minCost=Number.MAX_VALUE\r\n            let maxindex=-1\r\n            for (let i=0;i<tempEdgeList.length;i++){\r\n                if(minCost>tempEdgeList[i].weight){\r\n                    minCost=tempEdgeList[i].weight\r\n                    maxindex=i\r\n                }\r\n            }\r\n\r\n            let start=tempEdgeList[maxindex].start\r\n            let end=tempEdgeList[maxindex].end\r\n            this.graph.addEdge(start,end)\r\n            this.clustergraph.addEdge(tempEdgeList[maxindex].clusterstart,tempEdgeList[maxindex].clusterend)\r\n            this.edges.push({\r\n                start:start,\r\n                end:end,\r\n                weight:tempEdgeList[maxindex].weight,\r\n                // dis:tempEdgeList[maxindex].dis,\r\n                // mess:tempEdgeList[maxindex].mess,\r\n                crossnum:tempEdgeList[maxindex].crossnum\r\n            })\r\n\r\n            // this.drawEdges()\r\n            console.log()\r\n\r\n            // tempEdgeList.splice(maxindex,1)\r\n\r\n        }\r\n\r\n        // filteredRemoveList=this.sortRemoveEdges(filteredRemoveList)\r\n        // console.log(filteredRemoveList)\r\n\r\n    }\r\n\r\n    editBackbone(){\r\n\r\n        editView = !editView\r\n        this.setState({\r\n            editV:editView\r\n        })\r\n\r\n        if(editView){\r\n            d3.select(\"svg\")\r\n                .selectAll(\".dataPoint\")\r\n                .remove()\r\n//\r\n            d3.select(\"svg\")\r\n                .selectAll(\"line\")\r\n                .remove()\r\n\r\n            //offsetX = 20;\r\n            //offsetY = 20;\r\n            //viewWidth = 40;\r\n            //viewHeight = 40\r\n//\r\n            //this.child.setViewBox(offsetX, offsetY, viewWidth, viewHeight)\r\n            //d3.select(\"#mainsvg\")\r\n            //    .attr(\"viewBox\",offsetX+\" \"+offsetY+\" \"+viewWidth+\" \"+viewHeight)\r\n\r\n            /*\r\n            let tx,ty,s\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                for(let i = 0; i < infostr.length; i ++){\r\n                    if(infostr[i] == '('){\r\n                        i ++\r\n                        while(infostr[i] != ','){\r\n                            tx += infostr[i ++]\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            ty += infostr[i ++]\r\n                        }\r\n                        while(infostr[i] != '('){\r\n                            i ++\r\n                        }\r\n                        i ++\r\n                        while(infostr[i] != ')'){\r\n                            s += infostr[i ++]\r\n                        }\r\n                        break\r\n                    }\r\n                }\r\n                tx = parseFloat(tx)\r\n                ty = parseFloat(ty)\r\n                s = parseFloat(s)\r\n            }\r\n\r\n             */\r\n\r\n\r\n            // d3.select(svgid).selectAll(\"*\").remove();\r\n            this.drawPointData()\r\n            this.drawEdges()\r\n\r\n            if(document.getElementsByTagName('g')[0].attributes.hasOwnProperty(\"transform\")){\r\n                let infostr = document.getElementsByTagName('g')[0].attributes.transform.value.toString()\r\n                d3.selectAll('g').attr(\"transform\", infostr);\r\n            }\r\n\r\n            this.props.handleManually(false)\r\n            //this.child.getData()\r\n        }\r\n        else{\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n            //d3.selectAll(\"\")\r\n        }\r\n    }\r\n\r\n    editMST(){\r\n\r\n        this.issplit = !this.issplit;\r\n\r\n        if(this.issplit == true){\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",580 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n                .attr(\"style\",\"border:1px solid #000000\")\r\n\r\n            svgid = \"#leftsvg\"\r\n            opsvgid = '#mainsvg'\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n\r\n            this.drawPointData()\r\n\r\n            this.drawEdges()\r\n\r\n            this.props.handleManually(false)\r\n\r\n            //this.setState({\r\n            //    pointData: this.pointData\r\n            //})\r\n            //this.setState({\r\n            //    edges: this.edges\r\n            //})\r\n            //this.setState({\r\n            //    hasinit:true\r\n            //})\r\n//\r\n            //this.child.getData()\r\n\r\n        }\r\n        else{\r\n\r\n            d3.select(svgid).selectAll(\"*\").remove();\r\n            d3.selectAll(\"#edgeGroup\")\r\n                .remove()\r\n            d3.selectAll(\"#pointGroup\")\r\n                .remove()\r\n            this.child.afterEditReDraw()\r\n\r\n            d3.select(\"#mainsvg\")\r\n                .attr(\"width\",1200 * ScreenWidth / BeforeWidth)\r\n                .attr(\"height\",750 * ScreenHeight / BeforeHeight)\r\n\r\n            d3.select(\"#leftsvg\")\r\n                .attr(\"width\",0)\r\n                .attr(\"height\",0)\r\n                .attr(\"style\",\"border:0px solid #000000\")\r\n\r\n\r\n\r\n            svgid = \"#mainsvg\"\r\n            opsvgid = '#leftsvg'\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleCreated(){\r\n        this.setState({\r\n            hascreated:true\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    saveSVG(){\r\n\r\n    }\r\n\r\n    saveData(){\r\n        let data\r\n        if(!this.state.hasinit){\r\n            data=this.props.pointData\r\n        }\r\n        else{\r\n            data=this.pointData\r\n        }\r\n        let content = JSON.stringify(data);\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"data.json\");\r\n\r\n    }\r\n\r\n    render(){\r\n        //return (\r\n        //    <div id={\"svgcontainer\"}>\r\n        //        <svg id={\"mainsvg\"} width={\"1000px\"} height={\"1000px\"}>\r\n        //        </svg>\r\n        //        <button onClick={this.saveEdgeData.bind(this)}> Save </button>\r\n        //        <button onClick={this.loadEdgeData.bind(this)}> Load Edges </button>\r\n        //    </div>)\r\n        return (\r\n            <div>\r\n                <div>\r\n                    {/*<Button onClick={this.saveData.bind(this)}>Save Data</Button>*/}\r\n                    {/*<Button onClick={this.saveSVG}>Save SVG</Button>*/}\r\n\r\n                </div>\r\n                <div style={{marginTop: 20 * ScreenHeight / BeforeHeight}}>\r\n                        <Button onClick = {this.getData.bind(this)} disabled={this.props.hasLoadData&&!this.state.hasinit||this.state.hasEdit? false:true}>\r\n                        {\r\n                            this.state.hasinit? \"Apply Changes\":\"Create Backbone\"\r\n                        }\r\n                    </Button>\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Switch checkedChildren=\"Edit Backbone\" unCheckedChildren=\"Edit Backbone\"  onClick={this.editBackbone.bind(this)} checked={this.state.editV} disabled={this.state.hascreated? false:true}/>\r\n                    </div>\r\n\r\n                <AdaptiveIsovalue pointData={this.state.pointData} hasLoadData={this.props.hasLoadData} edges={this.state.edges} handleCreated={this.handleCreated.bind(this)} createMST={this.getData.bind(this)} onRef={this.onRef} colorArray={this.props.colorArray}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default HierarchicalCluster","import React, {Component, useState} from 'react'\r\nimport * as d3 from 'd3'\r\n\r\nimport './index.css';\r\nimport HierarchicalCluster from \"./HierarchicalCluster\";\r\nimport { Layout } from 'antd';\r\nimport { Button } from 'antd';\r\nimport { Select } from 'antd';\r\nimport { Menu } from 'antd';\r\nimport { Dropdown} from 'antd';\r\nimport { DownOutlined } from '@ant-design/icons';\r\nimport { Table, Radio, Divider } from 'antd';\r\nimport { Tag, Space } from 'antd'\r\nconst svgsaver=require(\"save-svg-as-png\")\r\n\r\nconst {ShapeInfo, Intersection,Point2D,IntersectionQuery} = require(\"kld-intersections\");\r\n\r\n\r\nconst { Option } = Select;\r\nconst { Header, Footer, Sider, Content } = Layout;\r\n\r\n\r\n\r\nconst columns = [\r\n    {\r\n        title: 'Group',\r\n        dataIndex: 'name',\r\n        render: (text) => <a>{text}</a>,\r\n    },\r\n    {\r\n        title: 'Color',\r\n        key: 'tags',\r\n        dataIndex: 'tags',\r\n        render: tags => (\r\n            <>\r\n                {tags.map(tag => {\r\n                    let color = tag\r\n                    return (\r\n                        <Tag color={color} key={tag} >\r\n                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                        </Tag>\r\n                    );\r\n                })}\r\n            </>\r\n        ),\r\n    }\r\n];\r\n\r\nvar keynum = 1\r\nvar GroupDict = {}\r\nGroupDict['Group 0'] = 1\r\nvar cur_set = 0;\r\nvar FileSaver = require('file-saver');\r\n\r\n\r\nvar svgid=\"#mainsvg\"\r\nconst rowSelection = {\r\n    onChange: (selectedRowKeys, selectedRows) => {\r\n        cur_set = selectedRowKeys;\r\n        //console.log(`selectedRowKeys: ${selectedRowKeys}`, 'selectedRows: ', selectedRows);\r\n    },\r\n    getCheckboxProps: (record) => ({\r\n        disabled: record.name === 'Disabled User',\r\n        // Column configuration not to be checked\r\n        name: record.name,\r\n    }),\r\n};\r\n// var colorArray=['#f700ff','#0885c2','#1c8b3c','#ed334e']\r\nvar colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n//var colorArray=['#fbf4a4','#c4da90','#a7bfd9','#f3c4d3','#f5c3a0','#a5c3af','#b9b9b4','#d2c1d5','#e7f1f5','#f9dce2','#e7f1f5','#cdcadb'] //fig3\r\n//var colorArray=['#f16b22','#7e519f','#713e3a'] //fig1\r\nvar is_input = false;\r\nvar g;\r\nvar svg;\r\n\r\nvar BeforeWidth = 1920\r\nvar BeforeHeight = 1040\r\nvar ScreenWidth = 1920\r\nvar ScreenHeight = 1040\r\n\r\nclass IndexUI extends Component{\r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0',tags:[]}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[],\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        }\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveData.bind(this)}>\r\n                        JSON\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n    }\r\n\r\n    init(){\r\n\r\n        d3.select(\"svg\").selectAll(\"*\").remove()\r\n\r\n        this.setState({\r\n            updateview: false,\r\n            is_input:false,\r\n            GroupData:[{key:'0',name:'Group 0',tags:[]}],\r\n            pointData:[],\r\n            edges:[],\r\n            hasLoadData:false,\r\n            dataFile:[],\r\n            colorArray:['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']\r\n        })\r\n\r\n        keynum = 1\r\n        GroupDict = {}\r\n        GroupDict['Group 0'] = 1\r\n        cur_set = 0;\r\n\r\n        svgid=\"#mainsvg\"\r\n        colorArray=['#e1642c','#d35d6d','#cecf7b','#4aa15f','#0885c2','#e2a2be','#ed334e','#6950a1','#1d953f','#ea66a6','#bed742','#2b4490']   //fig2\r\n\r\n        is_input = false;\r\n\r\n        this.shape = \"circle\";\r\n        this.cur_idx = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.offsetY = 0;\r\n        this.offsetX = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.selValue = ''\r\n        this.maxX=0\r\n        this.maxY=0\r\n        this.minX=0\r\n        this.minY=0\r\n        this.pointData = [];\r\n        this.edges=[]\r\n        this.lastClickIndex=-1\r\n        this.lastClickItem=null\r\n        this.itemBBox=[]\r\n        this.hasCreateMST=false\r\n\r\n\r\n        this.menu = (\r\n            <Menu>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.savePNG.bind(this)}>\r\n                        PNG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveSVG.bind(this)}>\r\n                        SVG\r\n                    </a>\r\n                </Menu.Item>\r\n                <Menu.Item>\r\n                    <a target=\"_blank\" rel=\"noopener noreferrer\" onClick={this.saveData.bind(this)}>\r\n                        JSON\r\n                    </a>\r\n                </Menu.Item>\r\n            </Menu>\r\n        );\r\n\r\n        this.child.init()\r\n\r\n\r\n    }\r\n\r\n    componentWillMount() {\r\n        ScreenHeight = window.screen.availHeight\r\n        ScreenWidth = window.screen.availWidth\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        var box=document.getElementById('mainsvg');\r\n        this.width = box.getBoundingClientRect().width;\r\n        this.height = box.getBoundingClientRect().height;\r\n        //console.log([this.width,this.height])\r\n\r\n        svg = d3.select('svg');\r\n\r\n        g = d3.select('svg').append(\"g\")\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        //svg.on('mousedown',this.handleMousedown.bind(this));\r\n        svg.call(d3.zoom()\r\n            .extent([[0, 0], [this.width, this.height]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        fetch('/data/datalist.json',{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    dataFile:data\r\n                })\r\n            })\r\n\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //unable local right click menu\r\n        document.oncontextmenu=function(){\r\n            return false;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    centralizeData(){\r\n        let minx=Number.MAX_VALUE\r\n        let miny=Number.MAX_VALUE\r\n        let maxx=Number.MIN_VALUE\r\n        let maxy=Number.MIN_VALUE\r\n        for (let i=0;i<this.pointData.length;i++){\r\n            if (this.pointData[i].x>maxx)\r\n                maxx=this.pointData[i].x\r\n            if(this.pointData[i].y>maxy)\r\n                maxy=this.pointData[i].y\r\n            if(this.pointData[i].x<minx)\r\n                minx=this.pointData[i].x\r\n            if(this.pointData[i].y<miny)\r\n                miny=this.pointData[i].y\r\n        }\r\n\r\n        this.maxX=maxx\r\n        this.minX=minx\r\n        this.maxY=maxy\r\n        this.minY=miny\r\n\r\n        d3.select(\"#mainsvg\")\r\n            .attr(\"viewBox\",(minx-20)+\" \"+(miny-20)+\" \"+(maxx-minx+40)+\" \"+(maxy-miny+40))\r\n        svg.on('mousedown',this.handleMousedown.bind(this));\r\n\r\n        this.offsetX = minx - 20;\r\n        this.offsetY = miny - 20;\r\n        this.scaleX = (maxx-minx+40)/this.width;\r\n        this.scaleY = (maxy-miny+40)/this.height;\r\n\r\n        svg = d3.select('svg');\r\n        svg.call(d3.zoom()\r\n            .extent([[this.offsetX, this.offsetY], [this.scaleX, this.scaleY]])\r\n            .scaleExtent([1, 8])\r\n            .on(\"zoom\", zoomed));\r\n\r\n        function zoomed({transform}) {\r\n            g.attr(\"transform\", transform);\r\n        }\r\n\r\n        //console.log([this.offsetX,this.offsetY,this.scaleX,this.scaleY])\r\n\r\n    }\r\n\r\n    handleMousedown(event){\r\n        //left click\r\n        if(event.button === 0 && is_input){\r\n\r\n            //console.log(\"IndexUI Click!\")\r\n            //console.log(g)\r\n\r\n            //let x = event.offsetX;\r\n            //let y = event.offsetY;\r\n            //console.log([x,y])\r\n            let cx = d3.pointer(event)[0]\r\n            let cy = d3.pointer(event)[1]\r\n            let attributes = g._groups[0][0].attributes\r\n            if(attributes.transform != undefined){\r\n                let val = attributes.transform.value\r\n                let offsetX = \"\";\r\n                let offsetY = \"\";\r\n                let Scale = \"\";\r\n                for(let j = 9; j < val.length; j ++){\r\n                    if(val[j]=='('){\r\n                        j++;\r\n                        if(offsetX==\"\"){\r\n                            while(val[j]!=','){\r\n                                offsetX+=val[j++];\r\n                            }\r\n                            j++;\r\n                            while(val[j]!=')'){\r\n                                offsetY+=val[j++];\r\n                            }\r\n                        }\r\n                        else{\r\n                            while(val[j]!=')'){\r\n                                Scale+=val[j++];\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                offsetX = parseFloat(offsetX)\r\n                offsetY = parseFloat(offsetY)\r\n                Scale = parseFloat(Scale)\r\n                //console.log(\"(\" + offsetX + \", \" + offsetY + \", \" + Scale +\")\")\r\n                cx = (cx - offsetX) / Scale\r\n                cy = (cy - offsetY) / Scale\r\n            }\r\n\r\n\r\n            if(this.shape === 'circle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('circle')\r\n                    .attr('r', 10)\r\n                    .attr('cx', cx)\r\n                    .attr('cy', cy)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                let tmpg = d3.select(\"#pointGroup\")\r\n                if(tmpg._groups[0][0] == null){\r\n                    tmpg = d3.select('g')\r\n                }\r\n                tmpg.append('rect')\r\n                    .attr('x', cx - 5)\r\n                    .attr('y', cy - 5)\r\n                    .attr('width', 10)\r\n                    .attr('height', 10)\r\n                    .attr('fill', colorArray[cur_set])\r\n                    .attr('set', cur_set)\r\n                    .attr('idx',this.cur_idx)\r\n                    .on('mousedown',this.handleDeleteNode.bind(this));\r\n            }\r\n            let tmp = {};\r\n            tmp.radius = 10;\r\n            tmp.width = 10;\r\n            tmp.height = 10;\r\n            tmp.x = cx;\r\n            tmp.y = cy;\r\n            tmp.cat = cur_set;\r\n            tmp.id = this.cur_idx++;\r\n            tmp.shape = this.shape\r\n\r\n            if(this.hasCreateMST == true){\r\n                this.child.addNewPoints(tmp)\r\n            }\r\n            else{\r\n                this.pointData.push(tmp);\r\n            }\r\n\r\n            this.setState({pointData:this.pointData})\r\n            console.log(this.pointData)\r\n        }\r\n    }\r\n\r\n\r\n    getVecNorm(vec){\r\n        return Math.sqrt(Math.pow(vec[0],2)+Math.pow(vec[1],2))\r\n    }\r\n\r\n    hasLinked(index1,index2){\r\n        for(let i=0;i<this.edges.length;i++){\r\n            let edge=this.edges[i]\r\n            if(edge.start==index1&&edge.end==index2){\r\n                return true\r\n            }\r\n            if(edge.start==index2&&edge.end==index1){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    findCrossingBetweenEdgeRect(start,end,cat){\r\n        let intersecInfo=[]\r\n        //check the crossing of a line and rectangle\r\n\r\n        // let cat=this.pointData[start].cat\r\n\r\n        let startp={x:start[0],y:start[1]}\r\n        let endp={x:end[0],y:end[1]}\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const rect=ShapeInfo.rectangle({top: this.itemBBox[i].bbox.y, left: this.itemBBox[i].bbox.x, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n            const line = ShapeInfo.line([startp.x, startp.y], [endp.x, endp.y]);\r\n            const intersections = Intersection.intersect(rect, line);\r\n            if(intersections.status==\"Intersection\" && intersections.points.length>1){\r\n                // console.log([startp.x, startp.y], [endp.x, endp.y])\r\n                // console.log({top: this.itemBBox[i].bbox.x, left: this.itemBBox[i].bbox.y, width: this.itemBBox[i].bbox.width, height: this.itemBBox[i].bbox.height})\r\n                // console.log(intersections.points.length)\r\n//                 for (let j=0;j<intersections.points.length;j++){\r\n//                     let ipoint=intersections.points[j]\r\n// /*                    d3.select(svgid)\r\n//                         .append(\"circle\")\r\n//                         .attr(\"cx\",ipoint.x)\r\n//                         .attr(\"cy\",ipoint.y)\r\n//                         .attr(\"r\",2)\r\n//                         .attr(\"fill\",\"red\")\r\n//                     console.log()*/\r\n//\r\n//                 }\r\n                intersecInfo.push({\r\n                    rect:this.itemBBox[i].bbox,\r\n                    points:intersections.points\r\n                })\r\n                break\r\n            }\r\n        }\r\n        return intersecInfo\r\n    }\r\n\r\n    checkVNodeInBound(vnode,cat){\r\n\r\n        for(let i=0;i<this.itemBBox.length;i++){\r\n            let index=parseInt(this.itemBBox[i].id)\r\n            if(cat==this.pointData[index].cat){\r\n                continue\r\n            }\r\n            const intersections = IntersectionQuery.pointInRectangle(  {x:vnode[0],y:vnode[1]}, {x:this.itemBBox[i].bbox.x,y:this.itemBBox[i].bbox.y},  {x:this.itemBBox[i].bbox.x+this.itemBBox[i].bbox.width,y:this.itemBBox[i].bbox.y+this.itemBBox[i].bbox.height})\r\n            if(intersections){\r\n                return true\r\n            }\r\n        }\r\n        return false\r\n    }\r\n\r\n    surfaceRoutingEdge(edge){\r\n\r\n        let startp=this.pointData[edge.start]\r\n        let endp=this.pointData[edge.end]\r\n        let pcat=this.pointData[edge.start].cat\r\n        let virtrualNodes=[]\r\n        virtrualNodes.push([startp.x,startp.y])\r\n        virtrualNodes.push([endp.x,endp.y])\r\n        let linesToCheck=[{\r\n            start:[startp.x,startp.y],\r\n            end:[endp.x,endp.y],\r\n            ids:[0,1]\r\n        }]\r\n\r\n        while(linesToCheck.length>0){\r\n\r\n            let buffer=5\r\n            let swap=false\r\n            let checkline=linesToCheck.pop()\r\n\r\n            startp=checkline.start\r\n            endp=checkline.end\r\n            let ids=checkline.ids\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",endp[0])\r\n            //     .attr(\"y2\",endp[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n            let intersecInfo=this.findCrossingBetweenEdgeRect(startp,endp,pcat)\r\n\r\n            if(intersecInfo.length==0){\r\n                continue\r\n            }\r\n            edge.virtrual=true\r\n            // handle crossing between edge and rect\r\n            let points=intersecInfo[0].points\r\n            let rec=intersecInfo[0].rect\r\n\r\n            let line1=[[rec.x,rec.y],[rec.x+rec.width,rec.y]]\r\n            let line3=[[rec.x,rec.y+rec.height],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let line2=[[rec.x,rec.y],[rec.x,rec.y+rec.height]]\r\n            let line4=[[rec.x+rec.width,rec.y],[rec.x+rec.width,rec.y+rec.height]]\r\n\r\n            let point1=points[0]\r\n            let point2=points[1]\r\n\r\n            let vnode\r\n\r\n            if(line1[1][1]==point1.y&&line3[1][1]==point2.y||line3[1][1]==point1.y&&line1[1][1]==point2.y||line2[0][0]==point1.x&&line4[0][0]==point2.x||line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                //parallel edges\r\n                let cornerpointindex=-1\r\n                if(line1[1][1]==point1.y&&line3[1][1]==point2.y){\r\n                    let x1=point1.x-rec.x\r\n                    let y1=point2.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line3[1][1]==point1.y&&line1[1][1]==point2.y){\r\n                    let x1=point2.x-rec.x\r\n                    let y1=point1.x-rec.x\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=2\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=4\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                else if(line2[0][0]==point1.x&&line4[0][0]==point2.x){\r\n                    let x1=point1.y-rec.y\r\n                    let y1=point2.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n                else if(line2[0][0]==point2.x&&line4[0][0]==point1.x){\r\n                    let x1=point2.y-rec.y\r\n                    let y1=point1.y-rec.y\r\n                    if(x1+y1<rec.width){\r\n                        if(x1>y1){\r\n                            cornerpointindex=3\r\n                        }\r\n                        else{\r\n                            cornerpointindex=4\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(x1<y1){\r\n                            cornerpointindex=2\r\n                        }\r\n                        else{\r\n                            cornerpointindex=1\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let cornerpoint=[]\r\n\r\n\r\n                let iternum=0\r\n                let vnode1=-1\r\n                let vnode2=-1\r\n                while(true) {\r\n                    if (cornerpointindex == 1) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 2) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        }\r\n                    } else if (cornerpointindex == 3) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x + rec.width, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x, rec.y]\r\n                        }\r\n                    } else if (cornerpointindex == 4) {\r\n                        if (!swap) {\r\n                            cornerpoint = [rec.x, rec.y + rec.height]\r\n                        } else {\r\n                            cornerpoint = [rec.x + rec.width, rec.y]\r\n                        }\r\n                    }\r\n\r\n                    let centerpoint = [rec.x + rec.width / 2, rec.y + rec.height / 2]\r\n                    let movevec = [cornerpoint[0] - centerpoint[0], cornerpoint[1] - centerpoint[1]]\r\n                    let movenorm = this.getVecNorm(movevec)\r\n                    movevec[0] = movevec[0] / movenorm\r\n                    movevec[1] = movevec[1] / movenorm\r\n\r\n                    vnode = [cornerpoint[0] + buffer * movevec[0], cornerpoint[1] + buffer * movevec[1]]\r\n\r\n                    // d3.selectAll(\"line\")\r\n                    //     .remove()\r\n                    // // .attr(\"stroke\",\"black\")\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",startp[0])\r\n                    //     .attr(\"y1\",startp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n                    //\r\n                    // d3.select(svgid).append(\"line\")\r\n                    //     .attr(\"x1\",endp[0])\r\n                    //     .attr(\"y1\",endp[1])\r\n                    //     .attr(\"x2\",vnode[0])\r\n                    //     .attr(\"y2\",vnode[1])\r\n                    //     .attr(\"stroke-width\",2)\r\n                    //     .attr(\"stroke\",\"red\")\r\n\r\n                    if(this.checkVNodeInBound(vnode,pcat)){\r\n                        if(!swap){\r\n                            buffer=buffer/1.5\r\n                        }\r\n                        swap=!swap\r\n                        iternum+=1\r\n                        if(iternum>10){\r\n                            break\r\n                        }\r\n                    }\r\n                    else{\r\n                        //not in obstacle, check if this virtrual edge corssing with other edges\r\n                        if(swap){\r\n                            vnode1=vnode\r\n                        }\r\n                        else{\r\n                            vnode2=vnode\r\n                        }\r\n                        swap=!swap\r\n                        if(vnode1!=-1&&vnode2!=-1){\r\n                            break\r\n                        }\r\n                        // iternum+=1\r\n                    }\r\n\r\n                }\r\n\r\n                if(vnode1==-1&&vnode2==-1){\r\n                    //fail to route the edge\r\n                    edge.virtrual=false\r\n                    continue\r\n                }\r\n                else if(vnode1!=-1&&vnode2!=-1){\r\n                    //use the one with least crossing\r\n                    let minCross=Number.MAX_VALUE\r\n                    let bestVnode=null\r\n                    let potentialNode=[vnode1,vnode2]\r\n                    for (let n=0;n<potentialNode.length;n++){\r\n                        let pnode=potentialNode[n]\r\n                        let count=0\r\n                        for(let i=0;i<this.edges.length;i++){\r\n                            let start1=this.pointData[this.edges[i].start]\r\n                            let end1=this.pointData[this.edges[i].end]\r\n                            if(start1.cat!=pcat){\r\n                                let node1={\r\n                                    x:startp[0],\r\n                                    y:startp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node2={\r\n                                    x:pnode[0],\r\n                                    y:pnode[1],\r\n                                    cat:pcat\r\n                                }\r\n                                let node3={\r\n                                    x:endp[0],\r\n                                    y:endp[1],\r\n                                    cat:pcat\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node1,node2)){\r\n                                    count+=1\r\n                                }\r\n                                if(this.checkEdgeCrossing(start1,end1,node2,node3)){\r\n                                    count+=1\r\n                                }\r\n                            }\r\n                        }\r\n                        if(count<minCross){\r\n                            minCross=count\r\n                            bestVnode=potentialNode[n]\r\n                        }\r\n\r\n                    }\r\n                    vnode=bestVnode\r\n\r\n                }\r\n                else{\r\n                    if(vnode1!=-1){\r\n                        vnode=vnode1\r\n                    }\r\n                    else{\r\n                        vnode=vnode2\r\n                    }\r\n                }\r\n\r\n            }\r\n            else{\r\n                //neighbouring edges\r\n                //find the corner point on the rectangle\r\n                let temppoint=[point1.x,point2.y]\r\n                let cornerpoint=[]\r\n                if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                    cornerpoint=[rec.x+rec.width,rec.y]\r\n                }\r\n                else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                }\r\n                else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                    cornerpoint=[rec.x,rec.y+rec.height]\r\n                }\r\n                else{\r\n                    temppoint=[point2.x,point1.y]\r\n                    if(temppoint[0]==rec.x&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y){\r\n                        cornerpoint=[rec.x+rec.width,rec.y]\r\n                    }\r\n                    else if(temppoint[0]==rec.x+rec.width&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x+rec.width,rec.y+rec.height]\r\n                    }\r\n                    else if(temppoint[0]==rec.x&&temppoint[1]==rec.y+rec.height){\r\n                        cornerpoint=[rec.x,rec.y+rec.height]\r\n                    }\r\n                }\r\n\r\n                let centerpoint=[rec.x+rec.width/2,rec.y+rec.height/2]\r\n                let movevec=[cornerpoint[0]-centerpoint[0],cornerpoint[1]-centerpoint[1]]\r\n                let movenorm=this.getVecNorm(movevec)\r\n                movevec[0]=movevec[0]/movenorm\r\n                movevec[1]=movevec[1]/movenorm\r\n\r\n                vnode=[cornerpoint[0]+buffer*movevec[0],cornerpoint[1]+buffer*movevec[1]]\r\n            }\r\n\r\n\r\n            // d3.selectAll(\"line\")\r\n            //     .remove()\r\n            // // .attr(\"stroke\",\"black\")\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",startp[0])\r\n            //     .attr(\"y1\",startp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n            //\r\n            // d3.select(svgid).append(\"line\")\r\n            //     .attr(\"x1\",endp[0])\r\n            //     .attr(\"y1\",endp[1])\r\n            //     .attr(\"x2\",vnode[0])\r\n            //     .attr(\"y2\",vnode[1])\r\n            //     .attr(\"stroke-width\",2)\r\n            //     .attr(\"stroke\",\"red\")\r\n\r\n\r\n            let samepoiint=false\r\n            for (let m=0;m<virtrualNodes.length;m++){\r\n                if(vnode[0]==virtrualNodes[m][0]&&vnode[1]==virtrualNodes[m][1]){\r\n                    samepoiint=true\r\n                    break\r\n                }\r\n            }\r\n            if(samepoiint){\r\n                continue\r\n            }\r\n\r\n            let newid\r\n\r\n\r\n            newid=ids[0]+1\r\n\r\n\r\n            virtrualNodes.splice(newid,0,vnode)\r\n\r\n            for (let n=0;n<linesToCheck.length;n++){\r\n                if(linesToCheck[n].ids[0]>=newid){\r\n                    linesToCheck[n].ids[0]=linesToCheck[n].ids[0]+1\r\n                }\r\n                if(linesToCheck[n].ids[1]>=newid){\r\n                    linesToCheck[n].ids[1]=linesToCheck[n].ids[1]+1\r\n                }\r\n            }\r\n            // virtrualNodes.push(vnode)\r\n            linesToCheck.push({\r\n                start:startp,\r\n                end:vnode,\r\n                ids:[ids[0],newid]\r\n            })\r\n            linesToCheck.push({\r\n                start:vnode,\r\n                end:endp,\r\n                ids:[newid,ids[1]+1]\r\n            })\r\n\r\n            // console.log(linesToCheck)\r\n\r\n        }\r\n\r\n        virtrualNodes.pop()\r\n        virtrualNodes.splice(0,1)\r\n        edge.virtrualNodes=virtrualNodes\r\n        return edge\r\n    }\r\n\r\n    deleteEdge(index){\r\n        let deleteindex=index\r\n        let that=this\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n            })\r\n            .remove()\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n            })\r\n            .remove()\r\n\r\n        g\r\n            .selectAll(\".controlPoints\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n            })\r\n            .attr(\"edgeindex\",function(){\r\n                return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n            })\r\n\r\n        g\r\n            .selectAll(\"line\")\r\n            .filter(function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n            })\r\n            .attr(\"index\",function(){\r\n                return parseInt(d3.select(this).attr(\"index\"))-1\r\n            })\r\n        that.edges.splice(deleteindex,1)\r\n\r\n        for (let i=0;i<that.edges.length;i++){\r\n            that.edges[i].id=i\r\n        }\r\n\r\n\r\n    }\r\n\r\n    drawOneEdge(index){\r\n\r\n        this.edges[index].SVGElement=[]\r\n        let oneEdge=this.edges[index]\r\n        let that=this\r\n\r\n        function handleMouseDown(event){\r\n            if(event.button==2){\r\n                // that.setState({\r\n                //     hasEdit:true\r\n                // })\r\n                let deleteindex=parseInt(d3.select(this).attr(\"index\"))\r\n                let start=that.edges[deleteindex].start\r\n                let end=that.edges[deleteindex].end\r\n                // that.deletedEdge.push([start,end])\r\n                that.deleteEdge(deleteindex)\r\n                // that.optimizeMST(true)\r\n\r\n                // for (var k in that.catPointDict){\r\n                //     that.findCircle(k)\r\n                // }\r\n                // console.log(that.edges.length)\r\n                /*                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n                                d3.select(svgid).select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))==deleteindex\r\n                                    })\r\n                                    .remove()\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\".controlPoints\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"edgeindex\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"edgeindex\"))-1\r\n                                    })\r\n\r\n                                d3.select(svgid)\r\n                                    .select(\"#edgeGroup\")\r\n                                    .selectAll(\"line\")\r\n                                    .filter(function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))>deleteindex\r\n                                    })\r\n                                    .attr(\"index\",function(){\r\n                                        return parseInt(d3.select(this).attr(\"index\"))-1\r\n                                    })\r\n                                that.edges.splice(deleteindex,1)\r\n\r\n                                for (let i=0;i<that.edges.length;i++){\r\n                                    that.edges[i].id=i\r\n                                }*/\r\n            }\r\n        }\r\n\r\n        let start=oneEdge.start\r\n        let end=oneEdge.end\r\n\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n        // this.nodeStartDict[start].push(i)\r\n        // this.nodeEndDict[end].push(i)\r\n\r\n        if(oneEdge.virtrual){\r\n            let vpoints=oneEdge.virtrualNodes\r\n            let vstart=[this.pointData[start].x,this.pointData[start].y]\r\n            let vend\r\n            for (let v=0;v<vpoints.length;v++){\r\n                vend=vpoints[v]\r\n                let newline=g\r\n                    .append(\"line\")\r\n                    .attr(\"x1\",vstart[0])\r\n                    .attr(\"y1\",vstart[1])\r\n                    .attr(\"x2\",vend[0])\r\n                    .attr(\"y2\",vend[1])\r\n                    .attr(\"stroke-width\",2)\r\n                    .attr(\"stroke\",\"black\")\r\n                    .attr(\"index\",index)\r\n                    .attr(\"isvirtrual\",true)\r\n                    .attr(\"segindex\",v)\r\n                    .on(\"mouseover\",function(d,i){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"red\")\r\n\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        let thisindex=d3.select(this).attr(\"index\")\r\n                        d3.selectAll(\"line\")\r\n                            .filter(function(){\r\n                                return d3.select(this).attr(\"index\")==thisindex\r\n                            })\r\n                            .attr(\"stroke\",\"black\")\r\n                            .attr(\"stroke-width\",2)\r\n                        console.log(that.edges[thisindex])\r\n                    })\r\n                    .on(\"mousedown\",handleMouseDown)\r\n\r\n                vstart=vend\r\n                this.edges[index].SVGElement.push(newline)\r\n            }\r\n            vend=[this.pointData[end].x,this.pointData[end].y]\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",vstart[0])\r\n                .attr(\"y1\",vstart[1])\r\n                .attr(\"x2\",vend[0])\r\n                .attr(\"y2\",vend[1])\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",true)\r\n                .attr(\"segindex\",vpoints.length)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n            // console.log()\r\n            for (let v=0;v<vpoints.length;v++){\r\n                    g\r\n                    .append(\"circle\")\r\n                    .attr(\"class\",\"controlPoints\")\r\n                    .attr(\"cx\",vpoints[v][0])\r\n                    .attr(\"cy\",vpoints[v][1])\r\n                    .attr(\"r\",5)\r\n                    .attr(\"edgeindex\",index)\r\n                    .attr(\"segindex\",v)\r\n                    .attr(\"fill\",\"red\")\r\n                    .attr(\"opacity\",0)\r\n                    // .attr(\"display\",\"none\")\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this).attr(\"opacity\",1)\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        d3.select(this).attr(\"opacity\",0)\r\n                    })\r\n\r\n            }\r\n        }\r\n        else{\r\n            let newline=g\r\n                .append(\"line\")\r\n                .attr(\"x1\",this.pointData[start].x)\r\n                .attr(\"y1\",this.pointData[start].y)\r\n                .attr(\"x2\",this.pointData[end].x)\r\n                .attr(\"y2\",this.pointData[end].y)\r\n                .attr(\"stroke-width\",2)\r\n                .attr(\"stroke\",\"black\")\r\n                .attr(\"index\",index)\r\n                .attr(\"isvirtrual\",false)\r\n                .on(\"mouseover\",function(d,i){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"red\")\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mouseout\",function(){\r\n                    let thisindex=d3.select(this).attr(\"index\")\r\n                    d3.selectAll(\"line\")\r\n                        .filter(function(){\r\n                            return d3.select(this).attr(\"index\")==thisindex\r\n                        })\r\n                        .attr(\"stroke\",\"black\")\r\n                        .attr(\"stroke-width\",2)\r\n                    console.log(that.edges[thisindex])\r\n                })\r\n                .on(\"mousedown\",handleMouseDown)\r\n\r\n            this.edges[index].SVGElement.push(newline)\r\n        }\r\n\r\n    }\r\n\r\n    addEdge(index1,index2,cat){\r\n        let that=this\r\n        let newedge={\r\n            start:index1,\r\n            end:index2,\r\n            weight:-1,\r\n            cat:cat,\r\n            dis:-1,\r\n            virtrual:false,\r\n            virtrualNodes:[],\r\n            id:this.edges.length,\r\n            isLocalTree:false\r\n        }\r\n        newedge=this.surfaceRoutingEdge(newedge)\r\n        this.edges.push(newedge)\r\n\r\n        this.drawOneEdge(newedge.id)\r\n    }\r\n\r\n    handleDeleteNode(e){\r\n        if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                this.pointData.splice(this.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n\r\n    }\r\n\r\n    drawInit(){\r\n\r\n        this.centralizeData();\r\n        let data = this.pointData;\r\n\r\n        let that=this\r\n\r\n        function dragged(event) {\r\n            // console.log(\"end!\")\r\n            let svg=d3.select(\"svg\")\r\n            let nodeindex=parseInt(d3.select(this).attr(\"idx\"))\r\n            that.pointData[nodeindex].x=event.x\r\n            that.pointData[nodeindex].y=event.y\r\n            if(that.shape==\"circle\"){\r\n                d3.select(this)\r\n                    .attr(\"cx\",event.x)\r\n                    .attr(\"cy\",event.y)\r\n            }\r\n            else{\r\n                let w=that.pointData[nodeindex].width\r\n                let h=that.pointData[nodeindex].height\r\n                d3.select(this)\r\n                    .attr(\"x\",event.x-0.5*w)\r\n                    .attr(\"y\",event.y-0.5*h)\r\n            }\r\n\r\n        }\r\n        function dragstart() {\r\n            // console.log(\"start!\")\r\n            // d3.select(this).classed(\"fixed\", true);\r\n            d3.select(this).attr(\"stroke\",\"red\")\r\n        }\r\n\r\n        var drag = d3.drag()\r\n            .on(\"start\",dragstart)\r\n            .on(\"drag\",dragged)\r\n            .on(\"end\",function(){\r\n                d3.select(this).attr(\"stroke\",\"none\")\r\n            })\r\n\r\n        function handleMouseDown(event){\r\n\r\n        }\r\n\r\n        function handleDeleteNode(e){\r\n            if(e.button === 2 && is_input){\r\n                console.log(e)\r\n                let tmp_set = parseInt(d3.select(e.path[0])._groups[0][0].attributes.set.value);\r\n                let tmp_index = parseInt(d3.select(e.path[0])._groups[0][0].attributes.idx.value);\r\n                d3.select(e.path[0]).remove();\r\n                that.pointData.splice(that.pointData.findIndex(e => e.id === tmp_index), 1);\r\n                // alert(\"Delete a node from set \" + tmp_set);\r\n\r\n            }\r\n            else if(e.button==2 && !is_input){\r\n                console.log(\"click\")\r\n                let clickIndex=parseInt(d3.select(this).attr(\"index\"))\r\n                if(that.lastClickIndex==-1){\r\n                    that.lastClickIndex=clickIndex\r\n                    that.lastClickItem=d3.select(this).attr(\"stroke\",\"red\")\r\n                        .attr(\"stroke-width\",5)\r\n                        .attr(\"selected\",true)\r\n                }\r\n                else{\r\n                    if(clickIndex==that.lastClickIndex){\r\n                        that.lastClickIndex=-1\r\n                        that.lastClickItem=null\r\n                        d3.select(this).attr(\"stroke\",\"red\")\r\n                            .attr(\"stroke-width\",1)\r\n                            .attr(\"selected\",false)\r\n                    }\r\n                    else{\r\n                        let lastcat=that.lastClickItem.attr(\"category\")\r\n                        if(lastcat==d3.select(this).attr(\"category\")){\r\n                            if(!that.hasLinked(that.lastClickIndex,clickIndex)){\r\n                                that.addEdge(that.lastClickIndex,clickIndex,lastcat)\r\n                                // that.addedEdge.push([that.lastClickIndex,clickIndex])\r\n                                //recommand an  edge to delete\r\n                                //check circle\r\n                                // that.findCircle(lastcat)\r\n                            }\r\n\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=null\r\n                            that.lastClickIndex=-1\r\n                            // that.optimizeMST(true)\r\n                        }\r\n                        else{\r\n                            that.lastClickItem\r\n                                .attr(\"stroke-width\",1)\r\n                                .attr(\"stroke\",\"none\")\r\n                                .attr(\"selected\",false)\r\n                            that.lastClickItem=d3.select(this)\r\n                                .attr(\"stroke\",\"red\")\r\n                                .attr(\"stroke-width\",5)\r\n                                .attr(\"selected\",true)\r\n\r\n                            that.lastClickIndex=clickIndex\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        var GroupCat = {}\r\n        for(let i = 0;i < data.length;i ++){\r\n\r\n            let curcat = -1;\r\n            let tmpcat = data[i].cat.toString()\r\n            let cats = tmpcat.split(\",\")\r\n            if (cats.length > 1){\r\n                for (let c = 0;c < cats.length;c ++){\r\n                    GroupCat[parseInt(cats[c])] = 1\r\n                    //GroupDict['Group '+ cats[c].toString()] = 1\r\n                    curcat = Math.max(parseInt(cats[c]), curcat);\r\n                }\r\n            }\r\n            else{\r\n                GroupCat[parseInt(tmpcat)] = 1\r\n                //GroupDict['Group '+ tmpcat.toString()] = 1\r\n                curcat = Math.max(parseInt(tmpcat), curcat);\r\n            }\r\n\r\n            cur_set = Math.max(curcat,cur_set);\r\n\r\n            if(this.shape === 'circle'){\r\n                g.append('circle')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('r', data[i].radius)\r\n                    .attr('cx', data[i].x)\r\n                    .attr('cy', data[i].y)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx',i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n            else if(this.shape === 'rectangle'){\r\n                g.append('rect')\r\n                    .attr(\"class\",\"dataPoint\")\r\n                    .attr('x', data[i].x - 0.5 * data[i].width)\r\n                    .attr('y', data[i].y - 0.5 * data[i].height)\r\n                    .attr('width', data[i].width)\r\n                    .attr('height', data[i].height)\r\n                    .attr('fill', colorArray[curcat])\r\n                    .attr(\"category\",curcat)\r\n                    .attr('set', curcat)\r\n                    .attr(\"index\",i)\r\n                    .attr('idx', i)\r\n                    .on('mousedown',handleDeleteNode)\r\n                    .on(\"mouseover\",function(){\r\n                        d3.select(this)\r\n                            .attr(\"stroke\",\"red\")\r\n                    })\r\n                    .on(\"mouseout\",function(){\r\n                        if(d3.select(this).attr(\"selected\")!=\"true\"){\r\n                            d3.select(this).attr(\"stroke\",\"none\")\r\n                        }\r\n                    })\r\n                    .call(drag)\r\n            }\r\n\r\n        }\r\n\r\n        this.itemBBox=[]\r\n\r\n        let items=document.getElementsByClassName(\"dataPoint\")\r\n\r\n        // console.log(items)\r\n        for (let i=0;i<items.length;i++){\r\n            this.itemBBox.push({\r\n                \"id\":items[i].getAttribute(\"index\"),\r\n                \"bbox\":items[i].getBBox()\r\n            })\r\n        }\r\n\r\n/*        if(d3.select(svgid).select(\"#edgeGroup\").empty()){\r\n            d3.select(svgid)\r\n                .insert(\"g\",\"#pointGroup\")\r\n                .attr(\"id\",\"edgeGroup\")\r\n        }*/\r\n\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        keynum = 0\r\n\r\n        GroupDict = {}\r\n        for(var c in GroupCat){\r\n            GroupDict['Group '+ c.toString()] = 1\r\n        }\r\n\r\n        for(var k in GroupDict){\r\n            console.log(k)\r\n            if(keynum == 0){\r\n                tmpGroupData[0].tags = [colorArray[parseInt(keynum)]]\r\n            }\r\n            else{\r\n                tmpGroupData.push({\r\n                    key:keynum.toString(),\r\n                    name:k,\r\n                    tags:[colorArray[parseInt(keynum)]]\r\n                })\r\n            }\r\n            keynum++;\r\n        }\r\n\r\n        this.setState({GroupData:tmpGroupData})\r\n\r\n        this.cur_idx = data.length\r\n        cur_set = keynum;\r\n\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 40)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n        //d3.select('svg').append('circle')\r\n        //    .attr('r', 10)\r\n        //    .attr('cx', 814)\r\n        //    .attr('cy', 279)\r\n        //    .attr('fill', colorArray[cur_set])\r\n        //    .attr('set', cur_set)\r\n        //    .attr('idx',this.cur_idx)\r\n        //    .on('mousedown',this.handleDeleteNode.bind(this));\r\n\r\n    }\r\n\r\n    addNewSet(){\r\n        keynum = 0\r\n        for(var k in GroupDict){\r\n            keynum ++;\r\n        }\r\n        //cur_set = keynum;\r\n        GroupDict['Group '+ keynum.toString()] = 1\r\n        let tmpGroupData = []\r\n        for(let i = 0;i < this.state.GroupData.length; i ++){\r\n            tmpGroupData.push(this.state.GroupData[i]);\r\n        }\r\n        tmpGroupData.push({\r\n            key:keynum.toString(),\r\n            name:'Group '+ keynum.toString(),\r\n            tags:[colorArray[parseInt(keynum.toString())]]\r\n        })\r\n        keynum ++;\r\n        this.setState({GroupData:tmpGroupData})\r\n        alert(\"Succellfully add new set \" + (keynum-1)  + \" !\");\r\n    }\r\n\r\n    scaleData(){\r\n\r\n        let minX = Number.MAX_VALUE\r\n        let minY = Number.MAX_VALUE\r\n        let maxX = Number.MIN_VALUE\r\n        let maxY = Number.MIN_VALUE\r\n        let scale_ratio_x = 1\r\n        let scale_ratio_y = 1\r\n        let transform_dx = 0\r\n        let transform_dy = 0\r\n\r\n        if(this.pointData.length <= 0){\r\n            return\r\n        }\r\n\r\n        if(this.pointData[0].shape == \"rectangle\"){\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].width / 2\r\n                let x2 = this.pointData[i].x + this.pointData[i].width / 2\r\n                let y1 = this.pointData[i].y - this.pointData[i].height / 2\r\n                let y2 = this.pointData[i].y + this.pointData[i].height / 2\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n        else{\r\n            for(let i = 0; i < this.pointData.length; i ++){\r\n                let x1 = this.pointData[i].x - this.pointData[i].radius\r\n                let x2 = this.pointData[i].x + this.pointData[i].radius\r\n                let y1 = this.pointData[i].y - this.pointData[i].radius\r\n                let y2 = this.pointData[i].y + this.pointData[i].radius\r\n                minX = Math.min(minX, x1)\r\n                minY = Math.min(minY, y1)\r\n                maxX = Math.max(maxX, x2)\r\n                maxY = Math.max(maxY, y2)\r\n            }\r\n        }\r\n\r\n\r\n        let cur_width = maxX - minX\r\n        let cur_height = maxY - minY\r\n\r\n        // let svgwidth1 = 1200\r\n        // let svgheight1 = 1200\r\n\r\n        let svgwidth1 = 1500\r\n        let svgheight1 = 1500\r\n\r\n        //let svgwidth2 = 2000\r\n        //let svgheight2 = 2000\r\n\r\n        //if(cur_width > svgwidth1){\r\n            scale_ratio_x = svgwidth1 / cur_width\r\n        //}\r\n\r\n        //if(cur_height > svgheight1){\r\n            scale_ratio_y = svgheight1 / cur_height\r\n        //}\r\n\r\n        let ratio = Math.min(scale_ratio_x, scale_ratio_y)\r\n\r\n        transform_dx = 0 - minX\r\n        transform_dy = 0 - minY\r\n\r\n        //let ddx = (svgwidth2 / 2)  - ( (minX + transform_dx) * ratio + (maxX + transform_dx) * ratio ) / 2\r\n        //let ddy = (svgheight2 / 2) - ( (minY + transform_dy) * ratio + (maxY + transform_dy) * ratio ) / 2\r\n\r\n        for(let i = 0; i < this.pointData.length; i ++){\r\n\r\n            this.pointData[i].x = (this.pointData[i].x + transform_dx) * ratio\r\n            this.pointData[i].y = (this.pointData[i].y + transform_dy) * ratio\r\n            this.pointData[i].radius *= ratio\r\n            this.pointData[i].width *= ratio\r\n            this.pointData[i].height *= ratio\r\n            //this.pointData[i].shape = \"rectangle\"\r\n\r\n        }\r\n\r\n    }\r\n\r\n    handleUpload(){\r\n\r\n\r\n        let filename = this.selValue\r\n\r\n        this.init()\r\n        this.componentWillMount()\r\n        this.render()\r\n        this.componentDidMount()\r\n\r\n        if(filename == \"Manhattan.txt\"){\r\n            colorArray = ['#f16b22','#7e519f','#713e3a']\r\n        }\r\n        else if(filename == \"simpleScatterplot.json\"){\r\n            colorArray = ['#d35d6d','#0885c2','#4aa15f']\r\n        }\r\n\r\n        this.setState({\r\n            colorArray:colorArray\r\n        })\r\n\r\n        console.log(\"filename:\")\r\n        console.log(filename)\r\n\r\n        fetch('/data/'+filename,{\r\n            method:'GET',\r\n            headers:{\r\n                'Content-Type':'application/json;charset=UTF-8'\r\n            },\r\n            mode:'cors',\r\n            cache:'default'\r\n        })\r\n            .then(res=>res.json())\r\n            .then(data=>{\r\n                this.setState({\r\n                    hasLoadData:true\r\n                })\r\n                this.pointData = data;\r\n                //for(let i = 0; i < this.pointData.length; i ++){\r\n                //    this.pointData[i].shape = \"rectangle\"\r\n                //}\r\n                //this.scaleData()\r\n\r\n                for (let i=0;i<this.pointData.length;i++){\r\n                    // this.pointData[i].width=this.pointData[i].width*1.5\r\n                    // this.pointData[i].height=this.pointData[i].height*1.5\r\n                    this.pointData[i].radius=10\r\n\r\n                }\r\n                //this.setState({\r\n                //    upload: true\r\n                //})\r\n\r\n                this.setState({pointData:this.pointData})\r\n                this.shape = data[0].shape;\r\n\r\n\r\n                this.drawInit();\r\n                this.setState({\r\n                    edges:this.edges\r\n                })\r\n            })\r\n\r\n    }\r\n\r\n    changeSel(e){\r\n        this.selValue = e;\r\n    }\r\n\r\n    handleInput(){\r\n        is_input = !is_input;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    onRef = (ref) => {\r\n        this.child = ref\r\n    }\r\n\r\n    hasCreate(){\r\n        this.hasCreateMST = true;\r\n    }\r\n    saveData(){\r\n        this.child.saveData()\r\n    }\r\n    savePNG(){\r\n        svgsaver.saveSvgAsPng(document.getElementById(\"mainsvg\"), \"result.png\");\r\n    }\r\n    saveSVG(){\r\n        let svg=d3.select(\"#mainsvg\")\r\n        let width=svg.attr(\"width\")\r\n        let height=svg.attr(\"height\")\r\n        let viewbox=svg.attr(\"viewBox\")\r\n        let svgstr=svg.html()\r\n        let xmlns=\"http://www.w3.org/2000/svg\"\r\n        svgstr=\"<svg xmlns=\\\"\"+xmlns+\"\\\" width=\\\"\"+width+\"\\\" height=\\\"\"+height+\"\\\" viewBox=\\\"\"+viewbox+\"\\\" >\\n\"+svgstr+\"\\n</svg>\"\r\n        let content = svgstr;\r\n        let blob = new Blob([content], {type: \"text/plain;charset=utf-8\"});\r\n\r\n        FileSaver.saveAs(blob, \"result.svg\");\r\n        // console.log(svgstr)\r\n    }\r\n\r\n    handleManually(flag){\r\n        is_input = flag;\r\n        this.setState({\r\n            is_input: is_input\r\n        })\r\n    }\r\n\r\n    render(){\r\n        let options=this.state.dataFile.map((d)=>{return <option value={d}>{d}</option> })\r\n        // console.log(\"Ratio\")\r\n        // console.log(ScreenHeight/BeforeHeight)\r\n        // console.log(ScreenWidth/BeforeWidth)\r\n        let p1 = 20 * ScreenHeight / BeforeHeight\r\n        let p2 = 50 * ScreenWidth / BeforeWidth\r\n        let p3 = 20 * ScreenHeight / BeforeHeight\r\n        let p4 = 20 * ScreenWidth / BeforeWidth\r\n        let p5 = 25 * ScreenHeight / BeforeHeight\r\n        let pad1 = p1.toString() + \"px \" + p2.toString() + \"px \" + p3.toString() + \"px \" + p4.toString() + \"px\"\r\n        let pad2 = p5.toString() + \"px \" + p4.toString() + \"px\"\r\n        return (\r\n            <>\r\n                <Layout>\r\n                    <Header style={{background: 'rgb(255, 255, 255, 0.1)',textAlign: 'center', fontFamily:\"Segoe UI\",fontWeight:\"bold\",fontSize: '25px', color:\"black\"}}>F2-Bubbles</Header>\r\n                    <Layout>\r\n                        <Content theme={'light'} style={{ padding: pad1, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\" style={{float: \"right\"}}>\r\n                                <svg id=\"mainsvg\" width={1200 * ScreenWidth / BeforeWidth} height={750 * ScreenHeight / BeforeHeight} style={{border:\"1px solid #000000\"}}></svg>\r\n                            </div>\r\n                            <div className=\"left\" style={{float: \"left\"}}>\r\n                                <svg id=\"leftsvg\" width={0} height={0}></svg>\r\n                            </div>\r\n                        </Content>\r\n                        <Sider theme={'light'} width={600 * ScreenWidth / BeforeWidth} className=\"site-layout-background\" style={{ padding: pad2, background: 'rgb(255, 255, 255)'}}>\r\n                            <div className=\"right\">\r\n                                <Select showSearch style={{ width: 320 * ScreenWidth / BeforeWidth }} placeholder=\"Select an example data..\" onChange={this.changeSel.bind(this)}>\r\n                                    {options}\r\n{/*                                    <Option value='BubbleSetExample1.txt'>example1</Option>\r\n                                    <Option value='BubbleSetExample2.txt'>example2</Option>\r\n                                    <Option value='BubbleSetExample3.txt'>Manually Made Data</Option>\r\n                                    <Option value='test.txt'>test</Option>\r\n                                    <Option value='test(1).txt'>test(1).txt</Option>\r\n                                        <Option value='co2_gdppercapita.txt'>co2_gdppercapita.txt</Option>\r\n                                    <Option value='life_children.txt'>life_children.txt</Option>\r\n                                    <Option value='co2_income.txt'>co2_income.txt</Option>\r\n                                    <Option value='life_income.txt'>life_income.txt</Option>*/}\r\n\r\n\r\n\r\n\r\n\r\n                                </Select>\r\n                                <Button onClick={this.handleUpload.bind(this)}>Load Example Data</Button>\r\n                                <br/>\r\n                                <br/>\r\n                                <p>\r\n                                    <Dropdown overlay={this.menu} arrow>\r\n                                        <Button>Save As <DownOutlined /></Button>\r\n                                    </Dropdown>\r\n                                </p>\r\n\r\n                                <div style={{width:\"80%\"}}>\r\n                                    <Table pagination={{disabled:true, position: ['none', 'none'] }}\r\n                                           scroll={{ y: 200 * ScreenHeight / BeforeHeight }}\r\n                                           columns={columns}\r\n                                           dataSource={this.state.GroupData}\r\n                                    />\r\n                                </div>\r\n                                <br/>\r\n                                <HierarchicalCluster pointData={this.state.pointData} hasLoadData={this.state.hasLoadData} isedit={this.state.is_input} edges={this.state.edges} hasCreate={this.hasCreate.bind(this)} handleManually={this.handleManually.bind(this)} onRef={this.onRef} colorArray = {this.state.colorArray}/>\r\n                            </div>\r\n                        </Sider>\r\n                    </Layout>\r\n                    <Footer style={{background: 'rgb(255, 255, 255, 0.1)', textAlign: 'center' ,fontSize: '16px'}}>F2-Bubbles 2021</Footer>\r\n                </Layout>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default IndexUI;","import ReactDOM from 'react-dom';\r\nimport React, { Component } from 'react'\r\n\r\nimport IndexUI from \"./IndexUI\";\r\n\r\nclass BubbleDemo extends  Component{\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    render(){\r\n        return(<IndexUI></IndexUI>)\r\n    }\r\n}\r\n\r\nexport default BubbleDemo","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport BubbleDemo from \"./BubbleDemo\"\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n\r\n      <BubbleDemo></BubbleDemo>\r\n\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}